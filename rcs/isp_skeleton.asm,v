head	1.0;
branch	1.0.1;
access;
symbols
	AMIGAISP_40_3:1.0.1.4;
locks; strict;
comment	@;; @;


1.0
date	96.02.19.22.45.49;	author schlote;	state Exp;
branches
	1.0.1.1;
next	;

1.0.1.1
date	96.02.19.22.54.15;	author schlote;	state Exp;
branches;
next	1.0.1.2;

1.0.1.2
date	96.02.19.22.57.33;	author schlote;	state Exp;
branches;
next	1.0.1.3;

1.0.1.3
date	96.02.19.23.06.00;	author schlote;	state Exp;
branches;
next	1.0.1.4;

1.0.1.4
date	96.02.19.23.07.01;	author schlote;	state Exp;
branches;
next	;


desc
@Integer Exeception Software Package
Motorola Release 1.01 vom 7-Okt-1994
@


1.0
log
@Initial revision
@
text
@#
# iskeleton.s
#
# This file contains:
#	(1) example "Call-out"s
#	(2) example package entry code
#	(3) example "Call-out" table
#


#################################
# (1) EXAMPLE CALL-OUTS 	#
#				#
# _060_isp_done()		#
# _060_real_chk()		#
# _060_real_divbyzero()		#
#				#
# _060_real_cas()		#
# _060_real_cas2()		#
# _060_real_lock_page()		#
# _060_real_unlock_page()	#
#################################

#
# _060_isp_done():
#
# This is and example main exit point for the Unimplemented Integer
# Instruction exception handler. For a normal exit, the 
# _isp_unimp() branches to here so that the operating system
# can do any clean-up desired. The stack frame is the
# Unimplemented Integer Instruction stack frame with
# the PC pointing to the instruction following the instruction
# just emulated.
# To simply continue execution at the next instruction, just
# do an "rte".
#
	global		_060_isp_done
_060_isp_done:
	rte

#
# _060_real_chk():
#
# This is an alternate exit point for the Unimplemented Integer
# Instruction exception handler. If the instruction was a "chk2"
# and the operand was out of bounds, then _isp_unimp() creates
# a CHK exception stack frame from the Unimplemented Integer Instrcution
# stack frame and branches to this routine.
#
	global		_060_real_chk
_060_real_chk:
	tst.b		(%sp)			# is tracing enabled?
	bpl.b		real_chk_end		# no

#
#	    CHK FRAME		   TRACE FRAME
#	*****************	*****************
#	*   Current PC	*	*   Current PC	*
#	*****************	*****************
#	* 0x2 *  0x018	*	* 0x2 *  0x024	*
#	*****************	*****************
#	*     Next	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#
	mov.b		&0x24,0x7(%sp)		# set trace vecno
	bra.l		_060_real_trace

real_chk_end:
	rte

#
# _060_real_divbyzero:
#
# This is an alternate exit point for the Unimplemented Integer 
# Instruction exception handler isp_unimp(). If the instruction is a 64-bit
# integer divide where the source operand is a zero, then the _isp_unimp() 
# creates a Divide-by-zero exception stack frame from the Unimplemented
# Integer Instruction stack frame and branches to this routine.
#
# Remember that a trace exception may be pending. The code below performs
# no action associated with the "chk" exception. If tracing is enabled,
# then it create a Trace exception stack frame from the "chk" exception
# stack frame and branches to the _real_trace() entry point.
# 
	global		_060_real_divbyzero
_060_real_divbyzero:
	tst.b		(%sp)			# is tracing enabled?
	bpl.b		real_divbyzero_end	# no

#
#	 DIVBYZERO FRAME	   TRACE FRAME
#	*****************	*****************
#	*   Current PC	*	*   Current PC	*
#	*****************	*****************
#	* 0x2 *  0x014	*	* 0x2 *  0x024	*
#	*****************	*****************
#	*     Next	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#
	mov.b		&0x24,0x7(%sp)		# set trace vecno
	bra.l		_060_real_trace

real_divbyzero_end:
	rte

###########################

#
# _060_real_cas():
#
# Entry point for the selected cas emulation code implementation.
# If the implementation provided by the 68060ISP is sufficient,
# then this routine simply re-enters the package through _isp_cas.
#
	global		_060_real_cas
_060_real_cas:
	bra.l		_I_CALL_TOP+0x80+0x08

#
# _060_real_cas2():
#
# Entry point for the selected cas2 emulation code implementation.
# If the implementation provided by the 68060ISP is sufficient,
# then this routine simply re-enters the package through _isp_cas2.
#
	global		_060_real_cas2
_060_real_cas2:
	bra.l		_I_CALL_TOP+0x80+0x10

#
# _060_lock_page():
#
# Entry point for the operating system's routine to "lock" a page
# from being paged out. This routine is needed by the cas/cas2
# algorithms so that no page faults occur within the "core" code
# region. Note: the routine must lock two pages if the operand 
# spans two pages.
# NOTE: THE ROUTINE SHOULD RETURN AN FSLW VALUE IN D0 ON FAILURE
# SO THAT THE 060SP CAN CREATE A PROPER ACCESS ERROR FRAME.
# Arguments:
#	a0 = operand address
#	d0 = `xxxxxxff -> supervisor; `xxxxxx00 -> user
#	d1 = `xxxxxxff -> longword; `xxxxxx00 -> word
# Expected outputs:
#	d0 = 0 -> success; non-zero -> failure
#
	global		_060_real_lock_page
_060_real_lock_page:
	clr.l		%d0
	rts

#
# _060_unlock_page():
#
# Entry point for the operating system's routine to "unlock" a
# page that has been "locked" previously with _real_lock_page.
# Note: the routine must unlock two pages if the operand spans
# two pages.
# Arguments:
# 	a0 = operand address
#	d0 = `xxxxxxff -> supervisor; `xxxxxx00 -> user
#	d1 = `xxxxxxff -> longword; `xxxxxx00 -> word
#
	global		_060_real_unlock_page
_060_real_unlock_page:
	clr.l		%d0
	rts

############################################################################

##################################
# (2) EXAMPLE PACKAGE ENTRY CODE #
##################################

	global		_060_isp_unimp
_060_isp_unimp:
	bra.l		_I_CALL_TOP+0x80+0x00

	global		_060_isp_cas
_060_isp_cas:
	bra.l		_I_CALL_TOP+0x80+0x08

	global		_060_isp_cas2
_060_isp_cas2:
	bra.l		_I_CALL_TOP+0x80+0x10

	global		_060_isp_cas_finish
_060_isp_cas_finish:
	bra.l		_I_CALL_TOP+0x80+0x18

	global		_060_isp_cas2_finish
_060_isp_cas2_finish:
	bra.l		_I_CALL_TOP+0x80+0x20

	global		_060_isp_cas_inrange
_060_isp_cas_inrange:
	bra.l		_I_CALL_TOP+0x80+0x28

	global		_060_isp_cas_terminate
_060_isp_cas_terminate:
	bra.l		_I_CALL_TOP+0x80+0x30

	global		_060_isp_cas_restart
_060_isp_cas_restart:
	bra.l		_I_CALL_TOP+0x80+0x38

############################################################################

################################
# (3) EXAMPLE CALL-OUT SECTION #
################################

# The size of this section MUST be 128 bytes!!!

	global	_I_CALL_TOP
_I_CALL_TOP:
	long	_060_real_chk		- _I_CALL_TOP
	long	_060_real_divbyzero	- _I_CALL_TOP
	long	_060_real_trace		- _I_CALL_TOP
	long	_060_real_access	- _I_CALL_TOP
	long	_060_isp_done		- _I_CALL_TOP

	long	_060_real_cas		- _I_CALL_TOP
	long	_060_real_cas2		- _I_CALL_TOP
	long	_060_real_lock_page	- _I_CALL_TOP
	long	_060_real_unlock_page	- _I_CALL_TOP

	long	0x00000000, 0x00000000, 0x00000000, 0x00000000
	long	0x00000000, 0x00000000, 0x00000000

	long	_060_imem_read		- _I_CALL_TOP
	long	_060_dmem_read		- _I_CALL_TOP
	long	_060_dmem_write		- _I_CALL_TOP
	long	_060_imem_read_word	- _I_CALL_TOP
	long	_060_imem_read_long	- _I_CALL_TOP
	long	_060_dmem_read_byte	- _I_CALL_TOP
	long	_060_dmem_read_word	- _I_CALL_TOP
	long	_060_dmem_read_long	- _I_CALL_TOP
	long	_060_dmem_write_byte	- _I_CALL_TOP
	long	_060_dmem_write_word	- _I_CALL_TOP
	long	_060_dmem_write_long	- _I_CALL_TOP

	long	0x00000000
	long	0x00000000, 0x00000000, 0x00000000, 0x00000000

############################################################################

# 060 INTEGER KERNEL PACKAGE MUST GO HERE!!!
@


1.0.1.1
log
@Changed to ISO latin-1
@
text
@d1 254
a254 257
#
# iskeleton.s
#
# This file contains:
#	(1) example "Call-out"s
#	(2) example package entry code
#	(3) example "Call-out" table
#
# $Id: isp_skeleton.asm 1.0.1.0 1996/02/19 22:53:28 schlote Exp schlote $
#



#################################
# (1) EXAMPLE CALL-OUTS 	#
#				#
# _060_isp_done()		#
# _060_real_chk()		#
# _060_real_divbyzero()		#
#				#
# _060_real_cas()		#
# _060_real_cas2()		#
# _060_real_lock_page()		#
# _060_real_unlock_page()	#
#################################

#
# _060_isp_done():
#
# This is and example main exit point for the Unimplemented Integer
# Instruction exception handler. For a normal exit, the
# _isp_unimp() branches to here so that the operating system
# can do any clean-up desired. The stack frame is the
# Unimplemented Integer Instruction stack frame with
# the PC pointing to the instruction following the instruction
# just emulated.
# To simply continue execution at the next instruction, just
# do an "rte".
#
	global		_060_isp_done
_060_isp_done:
	rte

#
# _060_real_chk():
#
# This is an alternate exit point for the Unimplemented Integer
# Instruction exception handler. If the instruction was a "chk2"
# and the operand was out of bounds, then _isp_unimp() creates
# a CHK exception stack frame from the Unimplemented Integer Instrcution
# stack frame and branches to this routine.
#
	global		_060_real_chk
_060_real_chk:
	tst.b		(%sp)			# is tracing enabled?
	bpl.b		real_chk_end		# no

#
#	    CHK FRAME		   TRACE FRAME
#	*****************	*****************
#	*   Current PC	*	*   Current PC	*
#	*****************	*****************
#	* 0x2 *  0x018	*	* 0x2 *  0x024	*
#	*****************	*****************
#	*     Next	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#
	mov.b		&0x24,0x7(%sp)		# set trace vecno
	bra.l		_060_real_trace

real_chk_end:
	rte

#
# _060_real_divbyzero:
#
# This is an alternate exit point for the Unimplemented Integer 
# Instruction exception handler isp_unimp(). If the instruction is a 64-bit
# integer divide where the source operand is a zero, then the _isp_unimp() 
# creates a Divide-by-zero exception stack frame from the Unimplemented
# Integer Instruction stack frame and branches to this routine.
#
# Remember that a trace exception may be pending. The code below performs
# no action associated with the "chk" exception. If tracing is enabled,
# then it create a Trace exception stack frame from the "chk" exception
# stack frame and branches to the _real_trace() entry point.
# 
	global		_060_real_divbyzero
_060_real_divbyzero:
	tst.b		(%sp)			# is tracing enabled?
	bpl.b		real_divbyzero_end	# no

#
#	 DIVBYZERO FRAME	   TRACE FRAME
#	*****************	*****************
#	*   Current PC	*	*   Current PC	*
#	*****************	*****************
#	* 0x2 *  0x014	*	* 0x2 *  0x024	*
#	*****************	*****************
#	*     Next	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#
	mov.b		&0x24,0x7(%sp)		# set trace vecno
	bra.l		_060_real_trace

real_divbyzero_end:
	rte

###########################

#
# _060_real_cas():
#
# Entry point for the selected cas emulation code implementation.
# If the implementation provided by the 68060ISP is sufficient,
# then this routine simply re-enters the package through _isp_cas.
#
	global		_060_real_cas
_060_real_cas:
	bra.l		_I_CALL_TOP+0x80+0x08

#
# _060_real_cas2():
#
# Entry point for the selected cas2 emulation code implementation.
# If the implementation provided by the 68060ISP is sufficient,
# then this routine simply re-enters the package through _isp_cas2.
#
	global		_060_real_cas2
_060_real_cas2:
	bra.l		_I_CALL_TOP+0x80+0x10

#
# _060_lock_page():
#
# Entry point for the operating system's routine to "lock" a page
# from being paged out. This routine is needed by the cas/cas2
# algorithms so that no page faults occur within the "core" code
# region. Note: the routine must lock two pages if the operand 
# spans two pages.
# NOTE: THE ROUTINE SHOULD RETURN AN FSLW VALUE IN D0 ON FAILURE
# SO THAT THE 060SP CAN CREATE A PROPER ACCESS ERROR FRAME.
# Arguments:
#	a0 = operand address
#	d0 = `xxxxxxff -> supervisor; `xxxxxx00 -> user
#	d1 = `xxxxxxff -> longword; `xxxxxx00 -> word
# Expected outputs:
#	d0 = 0 -> success; non-zero -> failure
#
	global		_060_real_lock_page
_060_real_lock_page:
	clr.l		%d0
	rts

#
# _060_unlock_page():
#
# Entry point for the operating system's routine to "unlock" a
# page that has been "locked" previously with _real_lock_page.
# Note: the routine must unlock two pages if the operand spans
# two pages.
# Arguments:
# 	a0 = operand address
#	d0 = `xxxxxxff -> supervisor; `xxxxxx00 -> user
#	d1 = `xxxxxxff -> longword; `xxxxxx00 -> word
#
	global		_060_real_unlock_page
_060_real_unlock_page:
	clr.l		%d0
	rts

############################################################################

##################################
# (2) EXAMPLE PACKAGE ENTRY CODE #
##################################

	global		_060_isp_unimp
_060_isp_unimp:
	bra.l		_I_CALL_TOP+0x80+0x00

	global		_060_isp_cas
_060_isp_cas:
	bra.l		_I_CALL_TOP+0x80+0x08

	global		_060_isp_cas2
_060_isp_cas2:
	bra.l		_I_CALL_TOP+0x80+0x10

	global		_060_isp_cas_finish
_060_isp_cas_finish:
	bra.l		_I_CALL_TOP+0x80+0x18

	global		_060_isp_cas2_finish
_060_isp_cas2_finish:
	bra.l		_I_CALL_TOP+0x80+0x20

	global		_060_isp_cas_inrange
_060_isp_cas_inrange:
	bra.l		_I_CALL_TOP+0x80+0x28

	global		_060_isp_cas_terminate
_060_isp_cas_terminate:
	bra.l		_I_CALL_TOP+0x80+0x30

	global		_060_isp_cas_restart
_060_isp_cas_restart:
	bra.l		_I_CALL_TOP+0x80+0x38

############################################################################

################################
# (3) EXAMPLE CALL-OUT SECTION #
################################

# The size of this section MUST be 128 bytes!!!

	global	_I_CALL_TOP
_I_CALL_TOP:
	long	_060_real_chk		- _I_CALL_TOP
	long	_060_real_divbyzero	- _I_CALL_TOP
	long	_060_real_trace		- _I_CALL_TOP
	long	_060_real_access	- _I_CALL_TOP
	long	_060_isp_done		- _I_CALL_TOP

	long	_060_real_cas		- _I_CALL_TOP
	long	_060_real_cas2		- _I_CALL_TOP
	long	_060_real_lock_page	- _I_CALL_TOP
	long	_060_real_unlock_page	- _I_CALL_TOP

	long	0x00000000, 0x00000000, 0x00000000, 0x00000000
	long	0x00000000, 0x00000000, 0x00000000

	long	_060_imem_read		- _I_CALL_TOP
	long	_060_dmem_read		- _I_CALL_TOP
	long	_060_dmem_write		- _I_CALL_TOP
	long	_060_imem_read_word	- _I_CALL_TOP
	long	_060_imem_read_long	- _I_CALL_TOP
	long	_060_dmem_read_byte	- _I_CALL_TOP
	long	_060_dmem_read_word	- _I_CALL_TOP
	long	_060_dmem_read_long	- _I_CALL_TOP
	long	_060_dmem_write_byte	- _I_CALL_TOP
	long	_060_dmem_write_word	- _I_CALL_TOP
	long	_060_dmem_write_long	- _I_CALL_TOP

	long	0x00000000
	long	0x00000000, 0x00000000, 0x00000000, 0x00000000

############################################################################

# 060 INTEGER KERNEL PACKAGE MUST GO HERE!!!
@


1.0.1.2
log
@Additions
@
text
@d1 40
a40 51
**---------------------------------------------------------------------------
**  /\  |\     Silicon Department      Telefax     06404-64760
**  \_ o| \_ _  Software Entwicklung    Telefon        06404-7996
**    \|| |_)|)   Carsten Schlote         Egelseeweg 52     35423 Lich
** \__/||_/\_|     Branko Mikiç            Limmerstrasse 10   30451 Hannover
**--------------------------------------------------------------------------
*
* $Id: isp_skeleton.asm,v 1.1 1996/02/11 19:32:58 schlote Exp $
* $Log: isp_skeleton.asm,v $
;; Revision 1.1  1996/02/11  19:32:58  schlote
;; Amiga Port, PhxAss 3.x
;; Optimizing switches added
;; Beautified source
;;
*
* iskeleton.s
*
* This file contains:
*	(1) example "Call-out"s
*	(2) example package entry code
*	(3) example "Call-out" table
*


*********************************
* (1) EXAMPLE CALL-OUTS 	*
*				*
* _060_isp_done()		*
* _060_real_chk()		*
* _060_real_divbyzero()		*
*				*
* _060_real_cas()		*
* _060_real_cas2()		*
* _060_real_lock_page()		*
* _060_real_unlock_page()	*
*********************************

*
* _060_isp_done():
*
* This is and example main exit point for the Unimplemented Integer
* Instruction exception handler. For a normal exit, the 
* _isp_unimp() branches to here so that the operating system
* can do any clean-up desired. The stack frame is the
* Unimplemented Integer Instruction stack frame with
* the PC pointing to the instruction following the instruction
* just emulated.
* To simply continue execution at the next instruction, just
* do an "rte".
*
	xdef		_060_isp_done
d44 10
a53 10
*
* _060_real_chk():
*
* This is an alternate exit point for the Unimplemented Integer
* Instruction exception handler. If the instruction was a "chk2"
* and the operand was out of bounds, then _isp_unimp() creates
* a CHK exception stack frame from the Unimplemented Integer Instrcution
* stack frame and branches to this routine.
*
	xdef		_060_real_chk
d55 2
a56 2
	tst.b		(sp)			* is tracing enabled?
	bpl.b		real_chk_end		* no
d58 14
a71 14
*
*	    CHK FRAME		   TRACE FRAME
*	*****************	*****************
*	*   Current PC	*	*   Current PC	*
*	*****************	*****************
*	* 0x2 *  0x018	*	* 0x2 *  0x024	*
*	*****************	*****************
*	*     Next	*	*     Next	*
*	*      PC	*	*      PC	*
*	*****************	*****************
*	*      SR	*	*      SR	*
*	*****************	*****************
*
	mov.b		&0x24,0x7(sp)		* set trace vecno
d77 15
a91 15
*
* _060_real_divbyzero:
*
* This is an alternate exit point for the Unimplemented Integer 
* Instruction exception handler isp_unimp(). If the instruction is a 64-bit
* integer divide where the source operand is a zero, then the _isp_unimp() 
* creates a Divide-by-zero exception stack frame from the Unimplemented
* Integer Instruction stack frame and branches to this routine.
*
* Remember that a trace exception may be pending. The code below performs
* no action associated with the "chk" exception. If tracing is enabled,
* then it create a Trace exception stack frame from the "chk" exception
* stack frame and branches to the _real_trace() entry point.
* 
	xdef		_060_real_divbyzero
d93 2
a94 2
	tst.b		(sp)			* is tracing enabled?
	bpl.b		real_divbyzero_end	* no
d96 14
a109 14
*
*	 DIVBYZERO FRAME	   TRACE FRAME
*	*****************	*****************
*	*   Current PC	*	*   Current PC	*
*	*****************	*****************
*	* 0x2 *  0x014	*	* 0x2 *  0x024	*
*	*****************	*****************
*	*     Next	*	*     Next	*
*	*      PC	*	*      PC	*
*	*****************	*****************
*	*      SR	*	*      SR	*
*	*****************	*****************
*
	mov.b		&0x24,0x7(sp)		* set trace vecno
d115 1
a115 1
***************************
d117 8
a124 8
*
* _060_real_cas():
*
* Entry point for the selected cas emulation code implementation.
* If the implementation provided by the 68060ISP is sufficient,
* then this routine simply re-enters the package through _isp_cas.
*
	xdef		_060_real_cas
d128 8
a135 8
*
* _060_real_cas2():
*
* Entry point for the selected cas2 emulation code implementation.
* If the implementation provided by the 68060ISP is sufficient,
* then this routine simply re-enters the package through _isp_cas2.
*
	xdef		_060_real_cas2
d139 18
a156 18
*
* _060_lock_page():
*
* Entry point for the operating system's routine to "lock" a page
* from being paged out. This routine is needed by the cas/cas2
* algorithms so that no page faults occur within the "core" code
* region. Note: the routine must lock two pages if the operand 
* spans two pages.
* NOTE: THE ROUTINE SHOULD RETURN AN FSLW VALUE IN D0 ON FAILURE
* SO THAT THE 060SP CAN CREATE A PROPER ACCESS ERROR FRAME.
* Arguments:
*	a0 = operand address
*	d0 = `xxxxxxff -> supervisor; `xxxxxx00 -> user
*	d1 = `xxxxxxff -> longword; `xxxxxx00 -> word
* Expected outputs:
*	d0 = 0 -> success; non-zero -> failure
*
	xdef		_060_real_lock_page
d158 1
a158 1
	clr.l		d0
d161 13
a173 13
*
* _060_unlock_page():
*
* Entry point for the operating system's routine to "unlock" a
* page that has been "locked" previously with _real_lock_page.
* Note: the routine must unlock two pages if the operand spans
* two pages.
* Arguments:
* 	a0 = operand address
*	d0 = `xxxxxxff -> supervisor; `xxxxxx00 -> user
*	d1 = `xxxxxxff -> longword; `xxxxxx00 -> word
*
	xdef		_060_real_unlock_page
d175 1
a175 1
	clr.l		d0
d178 1
a178 1
****************************************************************************
d180 3
a182 3
**********************************
* (2) EXAMPLE PACKAGE ENTRY CODE *
**********************************
d184 1
a184 1
	xdef		_060_isp_unimp
d188 1
a188 1
	xdef		_060_isp_cas
d192 1
a192 1
	xdef		_060_isp_cas2
d196 1
a196 1
	xdef		_060_isp_cas_finish
d200 1
a200 1
	xdef		_060_isp_cas2_finish
d204 1
a204 1
	xdef		_060_isp_cas_inrange
d208 1
a208 1
	xdef		_060_isp_cas_terminate
d212 1
a212 1
	xdef		_060_isp_cas_restart
d216 1
a216 1
****************************************************************************
d218 3
a220 3
********************************
* (3) EXAMPLE CALL-OUT SECTION *
********************************
d222 1
a222 1
* The size of this section MUST be 128 bytes!!!
d224 1
a224 1
	xdef	_I_CALL_TOP
d255 1
a255 1
****************************************************************************
d257 1
a257 1
* 060 INTEGER KERNEL PACKAGE MUST GO HERE!!!
@


1.0.1.3
log
@Amiga Port, PhxAss 3.x
Optimizing switches added
Beautified source
@
text
@@


1.0.1.4
log
@Call 0ut Stubs cleaned
Moveq #0,d0 ; rts    added to skeleton
@
text
@d8 7
a14 1
* $Id: isp_skeleton.asm,v 1.12 1996/02/16 15:13:24 schlote Exp $
d16 1
a16 1
* iskeleton.a
a22 6
	MACHINE	MC68060
	NEAR CODE
	OPT 0

        Moveq #0,d0
	rts
d42 1
a42 1
* Instruction exception handler. For a normal exit, the
d74 1
a74 1
*	* $2 *  $018	*	* $2 *  $024	*
d82 1
a82 1
	move.b		#$24,$7(sp)		* set trace vecno
d91 1
a91 1
* This is an alternate exit point for the Unimplemented Integer
d93 1
a93 1
* integer divide where the source operand is a zero, then the _isp_unimp()
d101 1
a101 1
*
d112 1
a112 1
*	* $2 *  $014	*	* $2 *  $024	*
d120 1
a120 1
	move.b		#$24,$7(sp)		* set trace vecno
d137 1
a137 1
	bra.l		_I_CALL_TOP+$80+$08
d148 1
a148 1
	bra.l		_I_CALL_TOP+$80+$10
d156 1
a156 1
* region. Note: the routine must lock two pages if the operand
a194 1

d197 1
a197 1
	bra.l		_I_CALL_TOP+$80+$00
d201 1
a201 1
	bra.l		_I_CALL_TOP+$80+$08
d205 1
a205 1
	bra.l		_I_CALL_TOP+$80+$10
d209 1
a209 1
	bra.l		_I_CALL_TOP+$80+$18
d213 1
a213 1
	bra.l		_I_CALL_TOP+$80+$20
d217 1
a217 1
	bra.l		_I_CALL_TOP+$80+$28
d221 1
a221 1
	bra.l		_I_CALL_TOP+$80+$30
d225 1
a225 1
	bra.l		_I_CALL_TOP+$80+$38
a234 15
_060_real_trace:		rte
_060_real_access:        	rte
_060_imem_read:                 rts
_060_dmem_read:                 rts
_060_dmem_write:                rts
_060_imem_read_word:            rts
_060_imem_read_long:            rts
_060_dmem_read_byte:            rts
_060_dmem_read_word:            rts
_060_dmem_read_long:            rts
_060_dmem_write_byte:           rts
_060_dmem_write_word:           rts
_060_dmem_write_long:           rts

	cnop	0,4
d237 25
a261 25
	dc.l	_060_real_chk		- _I_CALL_TOP
	dc.l	_060_real_divbyzero	- _I_CALL_TOP
	dc.l	_060_real_trace		- _I_CALL_TOP
	dc.l	_060_real_access	- _I_CALL_TOP
	dc.l	_060_isp_done		- _I_CALL_TOP

	dc.l	_060_real_cas		- _I_CALL_TOP
	dc.l	_060_real_cas2		- _I_CALL_TOP
	dc.l	_060_real_lock_page	- _I_CALL_TOP
	dc.l	_060_real_unlock_page	- _I_CALL_TOP

	dc.l	$00000000, $00000000, $00000000, $00000000
	dc.l	$00000000, $00000000, $00000000

	dc.l	_060_imem_read		- _I_CALL_TOP
	dc.l	_060_dmem_read		- _I_CALL_TOP
	dc.l	_060_dmem_write		- _I_CALL_TOP
	dc.l	_060_imem_read_word	- _I_CALL_TOP
	dc.l	_060_imem_read_long	- _I_CALL_TOP
	dc.l	_060_dmem_read_byte	- _I_CALL_TOP
	dc.l	_060_dmem_read_word	- _I_CALL_TOP
	dc.l	_060_dmem_read_long	- _I_CALL_TOP
	dc.l	_060_dmem_write_byte	- _I_CALL_TOP
	dc.l	_060_dmem_write_word	- _I_CALL_TOP
	dc.l	_060_dmem_write_long	- _I_CALL_TOP
d263 2
a264 2
	dc.l	$00000000
	dc.l	$00000000, $00000000, $00000000, $00000000
a268 1

@




















































































