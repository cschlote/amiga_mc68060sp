head	1.0;
branch	1.0.1;
access;
symbols;
locks
	schlote:1.0.1.23; strict;
comment	@;; @;


1.0
date	96.02.19.22.45.49;	author schlote;	state Exp;
branches
	1.0.1.1;
next	;

1.0.1.1
date	96.02.19.22.54.15;	author schlote;	state Exp;
branches;
next	1.0.1.2;

1.0.1.2
date	96.02.19.22.57.33;	author schlote;	state Exp;
branches;
next	1.0.1.3;

1.0.1.3
date	96.02.19.23.01.38;	author schlote;	state Exp;
branches;
next	1.0.1.4;

1.0.1.4
date	96.02.19.23.02.26;	author schlote;	state Exp;
branches;
next	1.0.1.5;

1.0.1.5
date	97.03.25.20.42.37;	author schlote;	state Exp;
branches;
next	1.0.1.6;

1.0.1.6
date	97.03.25.21.56.16;	author schlote;	state Exp;
branches;
next	1.0.1.7;

1.0.1.7
date	97.03.26.15.28.33;	author schlote;	state Exp;
branches;
next	1.0.1.8;

1.0.1.8
date	97.03.27.14.18.03;	author schlote;	state beta;
branches;
next	1.0.1.9;

1.0.1.9
date	97.03.27.16.15.03;	author schlote;	state Exp;
branches;
next	1.0.1.10;

1.0.1.10
date	97.03.27.17.10.46;	author schlote;	state Exp;
branches;
next	1.0.1.11;

1.0.1.11
date	97.03.27.17.31.37;	author schlote;	state Exp;
branches;
next	1.0.1.12;

1.0.1.12
date	97.03.27.17.48.31;	author schlote;	state Exp;
branches;
next	1.0.1.13;

1.0.1.13
date	97.03.27.20.17.15;	author schlote;	state Exp;
branches;
next	1.0.1.14;

1.0.1.14
date	97.03.27.20.34.09;	author schlote;	state stable;
branches;
next	1.0.1.15;

1.0.1.15
date	97.04.02.15.30.56;	author schlote;	state Exp;
branches;
next	1.0.1.16;

1.0.1.16
date	97.04.02.16.39.37;	author schlote;	state Exp;
branches;
next	1.0.1.17;

1.0.1.17
date	97.04.07.19.05.07;	author schlote;	state Exp;
branches;
next	1.0.1.18;

1.0.1.18
date	97.04.08.16.25.18;	author schlote;	state Exp;
branches;
next	1.0.1.19;

1.0.1.19
date	97.04.08.20.07.14;	author schlote;	state Exp;
branches;
next	1.0.1.20;

1.0.1.20
date	97.04.08.21.36.35;	author schlote;	state Exp;
branches;
next	1.0.1.21;

1.0.1.21
date	97.04.09.19.28.14;	author schlote;	state Exp;
branches;
next	1.0.1.22;

1.0.1.22
date	97.04.09.22.45.57;	author schlote;	state Exp;
branches;
next	1.0.1.23;

1.0.1.23
date	97.04.21.19.27.14;	author schlote;	state Exp;
branches;
next	;


desc
@Integer Exeception Software Package
Motorola Release 1.01 vom 7-Okt-1994
@


1.0
log
@Initial revision
@
text
@
#
# ireal.s:
#	This file is appended to the top of the 060ISP package
# and contains the entry points into the package. The user, in
# effect, branches to one of the branch table entries located
# after _060ISP_TABLE.
#	Also, subroutine stubs exist in this file (_isp_done for
# example) that are referenced by the ISP package itself in order
# to call a given routine. The stub routine actually performs the
# callout. The ISP code does a "bsr" to the stub routine. This
# extra layer of hierarchy adds a slight performance penalty but
# it makes the ISP code easier to read and more mainatinable.
#

set	_off_chk,	0x00
set	_off_divbyzero,	0x04
set	_off_trace,	0x08
set	_off_access,	0x0c
set	_off_done,	0x10

set	_off_cas,	0x14
set	_off_cas2,	0x18
set	_off_lock,	0x1c
set	_off_unlock,	0x20

set	_off_imr,	0x40
set	_off_dmr,	0x44
set	_off_dmw,	0x48
set	_off_irw,	0x4c
set	_off_irl,	0x50
set	_off_drb,	0x54
set	_off_drw,	0x58
set	_off_drl,	0x5c
set	_off_dwb,	0x60
set	_off_dww,	0x64
set	_off_dwl,	0x68

_060ISP_TABLE:

# Here's the table of ENTRY POINTS for those linking the package.
	bra.l		_isp_unimp
	short		0x0000

	bra.l		_isp_cas
	short		0x0000

	bra.l		_isp_cas2
	short		0x0000

	bra.l		_isp_cas_finish
	short		0x0000

	bra.l		_isp_cas2_finish
	short		0x0000

	bra.l		_isp_cas_inrange
	short		0x0000

	bra.l		_isp_cas_terminate
	short		0x0000

	bra.l		_isp_cas_restart
	short		0x0000

	space		64

#############################################################

	global		_real_chk
_real_chk:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_chk,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_divbyzero
_real_divbyzero:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_divbyzero,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_trace
_real_trace:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_trace,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_access
_real_access:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_access,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_isp_done
_isp_done:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_done,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

#######################################

	global		_real_cas
_real_cas:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_cas,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_cas2
_real_cas2:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_cas2,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_lock_page
_real_lock_page:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_lock,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_unlock_page
_real_unlock_page:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_unlock,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

#######################################

	global		_imem_read
_imem_read:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_imr,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_read
_dmem_read:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dmr,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_write
_dmem_write:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dmw,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_imem_read_word
_imem_read_word:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_irw,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_imem_read_long
_imem_read_long:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_irl,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_read_byte
_dmem_read_byte:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_drb,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_read_word
_dmem_read_word:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_drw,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_read_long
_dmem_read_long:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_drl,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_write_byte
_dmem_write_byte:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dwb,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_write_word
_dmem_write_word:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dww,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_write_long
_dmem_write_long:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dwl,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

#
# This file contains a set of define statements for constants
# in oreder to promote readability within the core code itself.
#

set LOCAL_SIZE,		96			# stack frame size(bytes)
set LV,			-LOCAL_SIZE		# stack offset

set EXC_ISR,		0x4			# stack status register
set EXC_IPC,		0x6			# stack pc
set EXC_IVOFF,		0xa			# stacked vector offset

set EXC_AREGS,		LV+64			# offset of all address regs
set EXC_DREGS,		LV+32			# offset of all data regs

set EXC_A7,		EXC_AREGS+(7*4)		# offset of a7
set EXC_A6,		EXC_AREGS+(6*4)		# offset of a6
set EXC_A5,		EXC_AREGS+(5*4)		# offset of a5
set EXC_A4,		EXC_AREGS+(4*4)		# offset of a4
set EXC_A3,		EXC_AREGS+(3*4)		# offset of a3
set EXC_A2,		EXC_AREGS+(2*4)		# offset of a2
set EXC_A1,		EXC_AREGS+(1*4)		# offset of a1
set EXC_A0,		EXC_AREGS+(0*4)		# offset of a0
set EXC_D7,		EXC_DREGS+(7*4)		# offset of d7
set EXC_D6,		EXC_DREGS+(6*4)		# offset of d6
set EXC_D5,		EXC_DREGS+(5*4)		# offset of d5
set EXC_D4,		EXC_DREGS+(4*4)		# offset of d4
set EXC_D3,		EXC_DREGS+(3*4)		# offset of d3
set EXC_D2,		EXC_DREGS+(2*4)		# offset of d2
set EXC_D1,		EXC_DREGS+(1*4)		# offset of d1
set EXC_D0,		EXC_DREGS+(0*4)		# offset of d0

set EXC_TEMP,		LV+16			# offset of temp stack space

set EXC_SAVVAL,		LV+12			# offset of old areg value
set EXC_SAVREG,		LV+11			# offset of old areg index

set SPCOND_FLG,		LV+10			# offset of spc condition flg

set EXC_CC,		LV+8			# offset of cc register
set EXC_EXTWPTR,	LV+4			# offset of current PC
set EXC_EXTWORD,	LV+2			# offset of current ext opword
set EXC_OPWORD,		LV+0			# offset of current opword

###########################
# SPecial CONDition FLaGs #
###########################
set mia7_flg,		0x04			# (a7)+ flag
set mda7_flg,		0x08			# -(a7) flag
set ichk_flg,		0x10			# chk exception flag
set idbyz_flg,		0x20			# divbyzero flag
set restore_flg,	0x40			# restore -(an)+ flag
set immed_flg,		0x80			# immediate data flag

set mia7_bit,		0x2			# (a7)+ bit
set mda7_bit,		0x3			# -(a7) bit
set ichk_bit,		0x4			# chk exception bit
set idbyz_bit,		0x5			# divbyzero bit
set restore_bit,	0x6			# restore -(a7)+ bit
set immed_bit,		0x7			# immediate data bit

#########
# Misc. #
#########
set BYTE,		1			# len(byte) == 1 byte
set WORD, 		2			# len(word) == 2 bytes
set LONG, 		4			# len(longword) == 4 bytes

#########################################################################
# XDEF ****************************************************************	#
#	_isp_unimp(): 060ISP entry point for Unimplemented Instruction	#
#									#
#	This handler should be the first code executed upon taking the 	#
# 	"Unimplemented Integer Instruction" exception in an operating	#
#	system.								#
#									#
# XREF ****************************************************************	#
#	_imem_read_{word,long}() - read instruction word/longword	#
#	_mul64() - emulate 64-bit multiply				#
# 	_div64() - emulate 64-bit divide				#
#	_moveperipheral() - emulate "movep"				#
#	_compandset() - emulate misaligned "cas"			#
#	_compandset2() - emulate "cas2"					#
#	_chk2_cmp2() - emulate "cmp2" and "chk2"			#
#	_isp_done() - "callout" for normal final exit			#
#	_real_trace() - "callout" for Trace exception			#
#	_real_chk() - "callout" for Chk exception			#
#	_real_divbyzero() - "callout" for DZ exception			#
#	_real_access() - "callout" for access error exception		#
#									#
# INPUT ***************************************************************	#
#	- The system stack contains the Unimp Int Instr stack frame	#
# 									#
# OUTPUT **************************************************************	#
#	If Trace exception:						#
#	- The system stack changed to contain Trace exc stack frame	#
#	If Chk exception:						#
#	- The system stack changed to contain Chk exc stack frame	#
#	If DZ exception:						#
#	- The system stack changed to contain DZ exc stack frame	#
#	If access error exception:					#
#	- The system stack changed to contain access err exc stk frame	#
#	Else:								#
#	- Results saved as appropriate					#
#									#
# ALGORITHM ***********************************************************	#
#	This handler fetches the first instruction longword from	#
# memory and decodes it to determine which of the unimplemented		#
# integer instructions caused this exception. This handler then calls	#
# one of _mul64(), _div64(), _moveperipheral(), _compandset(), 		#
# _compandset2(), or _chk2_cmp2() as appropriate. 			#
#	Some of these instructions, by their nature, may produce other	#
# types of exceptions. "div" can produce a divide-by-zero exception,	#
# and "chk2" can cause a "Chk" exception. In both cases, the current	#
# exception stack frame must be converted to an exception stack frame	#
# of the correct exception type and an exit must be made through	#
# _real_divbyzero() or _real_chk() as appropriate. In addition, all	#
# instructions may be executing while Trace is enabled. If so, then	#
# a Trace exception stack frame must be created and an exit made 	#
# through _real_trace().						#
#	Meanwhile, if any read or write to memory using the		#
# _mem_{read,write}() "callout"s returns a failing value, then an	#
# access error frame must be created and an exit made through		#
# _real_access().							#
#	If none of these occur, then a normal exit is made through	#
# _isp_done().								#
#									#
#	This handler, upon entry, saves almost all user-visible 	#
# address and data registers to the stack. Although this may seem to	#
# cause excess memory traffic, it was found that due to having to	#
# access these register files for things like data retrieval and <ea>	#
# calculations, it was more efficient to have them on the stack where	#
# they could be accessed by indexing rather than to make subroutine 	#
# calls to retrieve a register of a particular index. 			#
#									#
#########################################################################

	global		_isp_unimp
_isp_unimp:
	link.w 		%a6,&-LOCAL_SIZE	# create room for stack frame

	movm.l		&0x3fff,EXC_DREGS(%a6)	# store d0-d7/a0-a5
	mov.l		(%a6),EXC_A6(%a6)	# store a6

	btst		&0x5,EXC_ISR(%a6)	# from s or u mode?
	bne.b		uieh_s			# supervisor mode
uieh_u:
	mov.l		%usp,%a0		# fetch user stack pointer
	mov.l		%a0,EXC_A7(%a6)		# store a7
	bra.b		uieh_cont
uieh_s:
	lea		0xc(%a6),%a0
	mov.l		%a0,EXC_A7(%a6)		# store corrected sp

###############################################################################

uieh_cont:
	clr.b		SPCOND_FLG(%a6)		# clear "special case" flag

	mov.w		EXC_ISR(%a6),EXC_CC(%a6) # store cc copy on stack
	mov.l		EXC_IPC(%a6),EXC_EXTWPTR(%a6) # store extwptr on stack

#
# fetch the opword and first extension word pointed to by the stacked pc
# and store them to the stack for now
#
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x4,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_long		# fetch opword & extword
	mov.l		%d0,EXC_OPWORD(%a6)	# store extword on stack

	
#########################################################################
# muls.l	0100 1100 00 |<ea>|	0*** 1100 0000 0*** 		#
# mulu.l	0100 1100 00 |<ea>|	0*** 0100 0000 0***		#
#									#
# divs.l	0100 1100 01 |<ea>|	0*** 1100 0000 0***		#
# divu.l	0100 1100 01 |<ea>|	0*** 0100 0000 0***		#
#									#
# movep.w m2r	0000 ***1 00 001***	| <displacement>  |		#
# movep.l m2r	0000 ***1 01 001***	| <displacement>  |		#
# movep.w r2m	0000 ***1 10 001***	| <displacement>  |		#
# movep.l r2m	0000 ***1 11 001***	| <displacement>  |		#
#									#
# cas.w		0000 1100 11 |<ea>|	0000 000* **00 0***		#
# cas.l		0000 1110 11 |<ea>|	0000 000* **00 0***		#
#									#
# cas2.w	0000 1100 11 111100	**** 000* **00 0***		#
#					**** 000* **00 0***		#
# cas2.l	0000 1110 11 111100	**** 000* **00 0***		#
#					**** 000* **00 0***		#
#									#
# chk2.b	0000 0000 11 |<ea>|	**** 1000 0000 0000		#
# chk2.w	0000 0010 11 |<ea>|	**** 1000 0000 0000		#
# chk2.l	0000 0100 11 |<ea>|	**** 1000 0000 0000		#
#									#
# cmp2.b	0000 0000 11 |<ea>|	**** 0000 0000 0000		#
# cmp2.w	0000 0010 11 |<ea>|	**** 0000 0000 0000		#
# cmp2.l	0000 0100 11 |<ea>|	**** 0000 0000 0000		#
#########################################################################

#
# using bit 14 of the operation word, separate into 2 groups:
# (group1) mul64, div64
# (group2) movep, chk2, cmp2, cas2, cas
#
	btst		&0x1e,%d0		# group1 or group2
	beq.b		uieh_group2		# go handle group2

#
# now, w/ group1, make mul64's decode the fastest since it will
# most likely be used the most.
#
uieh_group1:
	btst		&0x16,%d0		# test for div64
	bne.b		uieh_div64		# go handle div64

uieh_mul64:
# mul64() may use ()+ addressing and may, therefore, alter a7

	bsr.l		_mul64			# _mul64()

	btst		&0x5,EXC_ISR(%a6)	# supervisor mode?
	beq.w		uieh_done
	btst		&mia7_bit,SPCOND_FLG(%a6) # was a7 changed?
	beq.w		uieh_done		# no
	btst		&0x7,EXC_ISR(%a6)	# is trace enabled?
	bne.w		uieh_trace_a7		# yes
	bra.w		uieh_a7			# no

uieh_div64:
# div64() may use ()+ addressing and may, therefore, alter a7.
# div64() may take a divide by zero exception.

	bsr.l		_div64			# _div64()

# here, we sort out all of the special cases that may have happened.
	btst		&mia7_bit,SPCOND_FLG(%a6) # was a7 changed?
	bne.b		uieh_div64_a7		# yes
uieh_div64_dbyz:
	btst		&idbyz_bit,SPCOND_FLG(%a6) # did divide-by-zero occur?
	bne.w		uieh_divbyzero		# yes
	bra.w		uieh_done		# no
uieh_div64_a7:
	btst		&0x5,EXC_ISR(%a6)	# supervisor mode?
	beq.b		uieh_div64_dbyz		# no
# here, a7 has been incremented by 4 bytes in supervisor mode. we still
# may have the following 3 cases:
#	(i)	(a7)+
#	(ii)	(a7)+; trace
#	(iii)	(a7)+; divide-by-zero
#
	btst		&idbyz_bit,SPCOND_FLG(%a6) # did divide-by-zero occur?
	bne.w		uieh_divbyzero_a7	# yes
	tst.b		EXC_ISR(%a6)		# no; is trace enabled?
	bmi.w		uieh_trace_a7		# yes
	bra.w		uieh_a7			# no
	
#
# now, w/ group2, make movep's decode the fastest since it will
# most likely be used the most.
#
uieh_group2:
	btst		&0x18,%d0		# test for not movep
	beq.b		uieh_not_movep


	bsr.l		_moveperipheral		# _movep()
	bra.w		uieh_done

uieh_not_movep:
	btst		&0x1b,%d0		# test for chk2,cmp2
	beq.b		uieh_chk2cmp2		# go handle chk2,cmp2

	swap		%d0			# put opword in lo word
	cmpi.b	 	%d0,&0xfc		# test for cas2
	beq.b		uieh_cas2		# go handle cas2

uieh_cas:

	bsr.l		_compandset		# _cas()

# the cases of "cas Dc,Du,(a7)+" and "cas Dc,Du,-(a7)" used from supervisor
# mode are simply not considered valid and therefore are not handled.

	bra.w		uieh_done

uieh_cas2:

	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# read extension word

	tst.l		%d1			# ifetch error?
	bne.w		isp_iacc		# yes

	bsr.l		_compandset2		# _cas2()
	bra.w		uieh_done

uieh_chk2cmp2:
# chk2 may take a chk exception

	bsr.l		_chk2_cmp2		# _chk2_cmp2()

# here we check to see if a chk trap should be taken
	cmpi.b		SPCOND_FLG(%a6),&ichk_flg
	bne.w		uieh_done
	bra.b		uieh_chk_trap

###########################################################################

#
# the required emulation has been completed. now, clean up the necessary stack
# info and prepare for rte
#
uieh_done:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes

# if exception occurred in user mode, then we have to restore a7 in case it
# changed. we don't have to update a7  for supervisor mose because that case
# doesn't flow through here
	btst		&0x5,EXC_ISR(%a6)	# user or supervisor?
	bne.b		uieh_finish		# supervisor

	mov.l		EXC_A7(%a6),%a0		# fetch user stack pointer
	mov.l		%a0,%usp		# restore it

uieh_finish:
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	btst		&0x7,EXC_ISR(%a6)	# is trace mode on?
	bne.b		uieh_trace		# yes;go handle trace mode

	mov.l		EXC_EXTWPTR(%a6),EXC_IPC(%a6) # new pc on stack frame
	mov.l		EXC_A6(%a6),(%a6)	# prepare new a6 for unlink
	unlk		%a6			# unlink stack frame
	bra.l		_isp_done

#
# The instruction that was just emulated was also being traced. The trace 
# trap for this instruction will be lost unless we jump to the trace handler.
# So, here we create a Trace Exception format number two exception stack
# frame from the Unimplemented Integer Intruction Exception stack frame
# format number zero and jump to the user supplied hook "_real_trace()".
#
#		   UIEH FRAME		   TRACE FRAME
#		*****************	*****************
#		* 0x0 *  0x0f4	*	*    Current	*
#		*****************	*      PC	*
#		*    Current	*	*****************
#		*      PC 	*	* 0x2 *  0x024	*
#		*****************	*****************
#		*      SR	*	*     Next	*
#		*****************	*      PC	*
#	      ->*     Old   	*	*****************
#  from link -->*      A6	*	*      SR	*
#	        *****************	*****************
#	       /*      A7	*	*      New	* <-- for final unlink
#	      / *		*	*      A6	*
# link frame <  *****************	*****************
#	      \ ~		~	~		~
#	       \*****************	*****************
#
uieh_trace:
	mov.l		EXC_A6(%a6),-0x4(%a6)
	mov.w		EXC_ISR(%a6),0x0(%a6)
	mov.l		EXC_IPC(%a6),0x8(%a6)
	mov.l		EXC_EXTWPTR(%a6),0x2(%a6)
	mov.w		&0x2024,0x6(%a6)
	sub.l		&0x4,%a6
	unlk		%a6
	bra.l		_real_trace

#
#	   UIEH FRAME		    CHK FRAME
#	*****************	*****************
#	* 0x0 *  0x0f4	*	*    Current	*
#	*****************	*      PC	*
#	*    Current	*	*****************
#	*      PC	*	* 0x2 *  0x018	*
#	*****************	*****************
#	*      SR	*	*     Next	*
#	*****************	*      PC	*
#	    (4 words)		*****************
#				*      SR	*
#				*****************
#				    (6 words)
#
# the chk2 instruction should take a chk trap. so, here we must create a
# chk stack frame from an unimplemented integer instruction exception frame
# and jump to the user supplied entry point "_real_chk()".
#
uieh_chk_trap:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.w		EXC_ISR(%a6),(%a6)	# put new SR on stack
	mov.l		EXC_IPC(%a6),0x8(%a6)	# put "Current PC" on stack
	mov.l		EXC_EXTWPTR(%a6),0x2(%a6) # put "Next PC" on stack
	mov.w		&0x2018,0x6(%a6)	# put Vector Offset on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&LOCAL_SIZE,%sp		# clear stack frame

	bra.l		_real_chk

#
#	   UIEH FRAME		 DIVBYZERO FRAME
#	*****************	*****************
#	* 0x0 *  0x0f4	*	*    Current	*
#	*****************	*      PC	*
#	*    Current	*	*****************
#	*      PC	*	* 0x2 *  0x014	*
#	*****************	*****************
#	*      SR	*	*     Next	*
#	*****************	*      PC	*
#	    (4 words)		*****************
#				*      SR	*
#				*****************
#				    (6 words)
#
# the divide instruction should take an integer divide by zero trap. so, here 
# we must create a divbyzero stack frame from an unimplemented integer 
# instruction exception frame and jump to the user supplied entry point 
# "_real_divbyzero()".
#
uieh_divbyzero:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.w		EXC_ISR(%a6),(%a6)	# put new SR on stack
	mov.l		EXC_IPC(%a6),0x8(%a6)	# put "Current PC" on stack
	mov.l		EXC_EXTWPTR(%a6),0x2(%a6) # put "Next PC" on stack
	mov.w		&0x2014,0x6(%a6)	# put Vector Offset on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&LOCAL_SIZE,%sp		# clear stack frame

	bra.l		_real_divbyzero

#
#				 DIVBYZERO FRAME
#				*****************
#				*    Current	*
#	   UIEH FRAME		*      PC	*
#	*****************	*****************
#	* 0x0 *  0x0f4	*	* 0x2 * 0x014	*
#	*****************	*****************
#	*    Current	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#	    (4 words)		    (6 words)
#
# the divide instruction should take an integer divide by zero trap. so, here 
# we must create a divbyzero stack frame from an unimplemented integer 
# instruction exception frame and jump to the user supplied entry point 
# "_real_divbyzero()".
#
# However, we must also deal with the fact that (a7)+ was used from supervisor
# mode, thereby shifting the stack frame up 4 bytes.
#
uieh_divbyzero_a7:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.l		EXC_IPC(%a6),0xc(%a6)	# put "Current PC" on stack
	mov.w		&0x2014,0xa(%a6)	# put Vector Offset on stack
	mov.l		EXC_EXTWPTR(%a6),0x6(%a6) # put "Next PC" on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&4+LOCAL_SIZE,%sp	# clear stack frame

	bra.l		_real_divbyzero

#
#				   TRACE FRAME
#				*****************
#				*    Current	*
#	   UIEH FRAME		*      PC	*
#	*****************	*****************
#	* 0x0 *  0x0f4	*	* 0x2 * 0x024	*
#	*****************	*****************
#	*    Current	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#	    (4 words)		    (6 words)
#
# 
# The instruction that was just emulated was also being traced. The trace 
# trap for this instruction will be lost unless we jump to the trace handler.
# So, here we create a Trace Exception format number two exception stack
# frame from the Unimplemented Integer Intruction Exception stack frame
# format number zero and jump to the user supplied hook "_real_trace()".
#
# However, we must also deal with the fact that (a7)+ was used from supervisor
# mode, thereby shifting the stack frame up 4 bytes.
#
uieh_trace_a7:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.l		EXC_IPC(%a6),0xc(%a6)	# put "Current PC" on stack
	mov.w		&0x2024,0xa(%a6)	# put Vector Offset on stack
	mov.l		EXC_EXTWPTR(%a6),0x6(%a6) # put "Next PC" on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&4+LOCAL_SIZE,%sp	# clear stack frame

	bra.l		_real_trace

#
#				   UIEH FRAME	
#				*****************
#				* 0x0 * 0x0f4	*
#	   UIEH FRAME		*****************
#	*****************	*     Next	*
#	* 0x0 *  0x0f4	*	*      PC	*	
#	*****************	*****************
#	*    Current	*	*      SR	*
#	*      PC	*	*****************
#	*****************	    (4 words)
#	*      SR	*
#	*****************
#	    (4 words)
uieh_a7:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.w		&0x00f4,0xe(%a6)	# put Vector Offset on stack
	mov.l		EXC_EXTWPTR(%a6),0xa(%a6) # put "Next PC" on stack
	mov.w		EXC_ISR(%a6),0x8(%a6)	# put SR on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&8+LOCAL_SIZE,%sp	# clear stack frame
	bra.l		_isp_done

##########

# this is the exit point if a data read or write fails.
# a0 = failing address
# d0 = fslw
isp_dacc:
	mov.l		%a0,(%a6)		# save address	
	mov.l		%d0,-0x4(%a6)		# save partial fslw

	lea		-64(%a6),%sp
	movm.l		(%sp)+,&0x7fff 		# restore d0-d7/a0-a6

	mov.l		0xc(%sp),-(%sp)		# move voff,hi(pc)
	mov.l		0x4(%sp),0x10(%sp)	# store fslw
	mov.l		0xc(%sp),0x4(%sp)	# store sr,lo(pc)
	mov.l		0x8(%sp),0xc(%sp)	# store address
	mov.l		(%sp)+,0x4(%sp)		# store voff,hi(pc)
	mov.w		&0x4008,0x6(%sp)	# store new voff

	bra.b		isp_acc_exit

# this is the exit point if an instruction word read fails.
# FSLW:
#	misaligned = true
#	read = true
# 	size = word
# 	instruction = true
# 	software emulation error = true
isp_iacc:
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5
	unlk		%a6			# unlink frame
	sub.w		&0x8,%sp		# make room for acc frame
	mov.l		0x8(%sp),(%sp)		# store sr,lo(pc)
	mov.w		0xc(%sp),0x4(%sp)	# store hi(pc)
	mov.w		&0x4008,0x6(%sp)	# store new voff
	mov.l		0x2(%sp),0x8(%sp)	# store address (=pc)
	mov.l		&0x09428001,0xc(%sp)	# store fslw

isp_acc_exit:
	btst		&0x5,(%sp)		# user or supervisor?
	beq.b		isp_acc_exit2		# user
	bset		&0x2,0xd(%sp)		# set supervisor TM bit
isp_acc_exit2:
	bra.l		_real_access		

# if the addressing mode was (an)+ or -(an), the address register must
# be restored to it's pre-exception value before entering _real_access.
isp_restore:
	cmpi.b		SPCOND_FLG(%a6),&restore_flg # do we need a restore?
	bne.b		isp_restore_done	# no
	clr.l		%d0
	mov.b		EXC_SAVREG(%a6),%d0	# regno to restore
	mov.l		EXC_SAVVAL(%a6),(EXC_AREGS,%a6,%d0.l*4) # restore value
isp_restore_done:
	rts

#########################################################################
# XDEF ****************************************************************	#
#	_calc_ea(): routine to calculate effective address		#
#									#
# XREF ****************************************************************	#
# 	_imem_read_word() - read instruction word			#
# 	_imem_read_long() - read instruction longword			#
# 	_dmem_read_long() - read data longword (for memory indirect)	#
# 	isp_iacc() - handle instruction access error exception		#
#	isp_dacc() - handle data access error exception			#
#									#
# INPUT ***************************************************************	#
# 	d0 = number of bytes related to effective address (w,l)		#
#									#
# OUTPUT **************************************************************	#
#	If exiting through isp_dacc...					#
#		a0 = failing address					#
#		d0 = FSLW						#
#	elsif exiting though isp_iacc...				#
#		none							#
#	else								#
#		a0 = effective address					#
#									#
# ALGORITHM ***********************************************************	#
# 	The effective address type is decoded from the opword residing	#
# on the stack. A jump table is used to vector to a routine for the 	#
# appropriate mode. Since none of the emulated integer instructions	#
# uses byte-sized operands, only handle word and long operations.	#
#									#
# 	Dn,An	- shouldn't enter here					#
#	(An)	- fetch An value from stack				#
# 	-(An)	- fetch An value from stack; return decr value;		#
#		  place decr value on stack; store old value in case of	#
#		  future access error; if -(a7), set mda7_flg in 	#
#		  SPCOND_FLG						#
#	(An)+	- fetch An value from stack; return value;		#
#		  place incr value on stack; store old value in case of	#
#		  future access error; if (a7)+, set mia7_flg in	#
#		  SPCOND_FLG						#
#	(d16,An) - fetch An value from stack; read d16 using 		#
#		  _imem_read_word(); fetch may fail -> branch to	#
#		  isp_iacc()						#
#	(xxx).w,(xxx).l - use _imem_read_{word,long}() to fetch		#
#		  address; fetch may fail				#
#	#<data> - return address of immediate value; set immed_flg	#
#		  in SPCOND_FLG						#
#	(d16,PC) - fetch stacked PC value; read d16 using		#
#		  _imem_read_word(); fetch may fail -> branch to	#
#		  isp_iacc()						#
#	everything else - read needed displacements as appropriate w/	#
#		  _imem_read_{word,long}(); read may fail; if memory	#
# 		  indirect, read indirect address using			#
#		  _dmem_read_long() which may also fail			#
#									#
#########################################################################

	global		_calc_ea
_calc_ea:
	mov.l		%d0,%a0			# move # bytes to a0

# MODE and REG are taken from the EXC_OPWORD.
	mov.w		EXC_OPWORD(%a6),%d0	# fetch opcode word
	mov.w		%d0,%d1			# make a copy

	andi.w		&0x3f,%d0		# extract mode field
	andi.l		&0x7,%d1		# extract reg  field

# jump to the corresponding function for each {MODE,REG} pair.
	mov.w		(tbl_ea_mode.b,%pc,%d0.w*2), %d0 # fetch jmp distance
	jmp		(tbl_ea_mode.b,%pc,%d0.w*1) # jmp to correct ea mode

	swbeg		&64
tbl_ea_mode:
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode

	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode

	short		addr_ind_a0	- 	tbl_ea_mode
	short		addr_ind_a1	- 	tbl_ea_mode
	short		addr_ind_a2	- 	tbl_ea_mode
	short		addr_ind_a3 	- 	tbl_ea_mode
	short		addr_ind_a4 	- 	tbl_ea_mode
	short		addr_ind_a5 	- 	tbl_ea_mode
	short		addr_ind_a6 	- 	tbl_ea_mode
	short		addr_ind_a7 	- 	tbl_ea_mode

	short		addr_ind_p_a0	- 	tbl_ea_mode
	short		addr_ind_p_a1 	- 	tbl_ea_mode
	short		addr_ind_p_a2 	- 	tbl_ea_mode
	short		addr_ind_p_a3 	- 	tbl_ea_mode
	short		addr_ind_p_a4 	- 	tbl_ea_mode
	short		addr_ind_p_a5 	- 	tbl_ea_mode
	short		addr_ind_p_a6 	- 	tbl_ea_mode
	short		addr_ind_p_a7 	- 	tbl_ea_mode

	short		addr_ind_m_a0 		- 	tbl_ea_mode
	short		addr_ind_m_a1 		- 	tbl_ea_mode
	short		addr_ind_m_a2 		- 	tbl_ea_mode
	short		addr_ind_m_a3 		- 	tbl_ea_mode
	short		addr_ind_m_a4 		- 	tbl_ea_mode
	short		addr_ind_m_a5 		- 	tbl_ea_mode
	short		addr_ind_m_a6 		- 	tbl_ea_mode
	short		addr_ind_m_a7 		- 	tbl_ea_mode

	short		addr_ind_disp_a0	- 	tbl_ea_mode
	short		addr_ind_disp_a1 	- 	tbl_ea_mode
	short		addr_ind_disp_a2 	- 	tbl_ea_mode
	short		addr_ind_disp_a3 	- 	tbl_ea_mode
	short		addr_ind_disp_a4 	- 	tbl_ea_mode
	short		addr_ind_disp_a5 	- 	tbl_ea_mode
	short		addr_ind_disp_a6 	- 	tbl_ea_mode
	short		addr_ind_disp_a7	-	tbl_ea_mode

	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode

	short		abs_short		- 	tbl_ea_mode
	short		abs_long		- 	tbl_ea_mode
	short		pc_ind			- 	tbl_ea_mode
	short		pc_ind_ext		- 	tbl_ea_mode
	short		immediate		- 	tbl_ea_mode
	short		tbl_ea_mode		- 	tbl_ea_mode
	short		tbl_ea_mode		- 	tbl_ea_mode
	short		tbl_ea_mode		- 	tbl_ea_mode

###################################
# Address register indirect: (An) #
###################################
addr_ind_a0:
	mov.l		EXC_A0(%a6),%a0		# Get current a0
	rts

addr_ind_a1:
	mov.l		EXC_A1(%a6),%a0		# Get current a1
	rts

addr_ind_a2:
	mov.l		EXC_A2(%a6),%a0		# Get current a2
	rts

addr_ind_a3:
	mov.l		EXC_A3(%a6),%a0		# Get current a3
	rts

addr_ind_a4:
	mov.l		EXC_A4(%a6),%a0		# Get current a4
	rts

addr_ind_a5:
	mov.l		EXC_A5(%a6),%a0		# Get current a5
	rts

addr_ind_a6:
	mov.l		EXC_A6(%a6),%a0		# Get current a6
	rts

addr_ind_a7:
	mov.l		EXC_A7(%a6),%a0		# Get current a7
	rts

#####################################################
# Address register indirect w/ postincrement: (An)+ #
#####################################################
addr_ind_p_a0:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A0(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A0(%a6)		# save incremented value
	
	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x0,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a1:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A1(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A1(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x1,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a2:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A2(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A2(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x2,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a3:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A3(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A3(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x3,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a4:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A4(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A4(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x4,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a5:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A5(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A5(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x5,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a6:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A6(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A6(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x6,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a7:
	mov.b		&mia7_flg,SPCOND_FLG(%a6) # set "special case" flag

	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A7(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A7(%a6)		# save incremented value
	rts

####################################################
# Address register indirect w/ predecrement: -(An) #
####################################################
addr_ind_m_a0:
	mov.l		EXC_A0(%a6),%d0		# Get current a0
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A0(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x0,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a1:
	mov.l		EXC_A1(%a6),%d0		# Get current a1
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A1(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x1,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a2:
	mov.l		EXC_A2(%a6),%d0		# Get current a2
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A2(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x2,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a3:
	mov.l		EXC_A3(%a6),%d0		# Get current a3
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A3(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x3,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a4:
	mov.l		EXC_A4(%a6),%d0		# Get current a4
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A4(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x4,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a5:
	mov.l		EXC_A5(%a6),%d0		# Get current a5
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A5(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x5,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a6:
	mov.l		EXC_A6(%a6),%d0		# Get current a6
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A6(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x6,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a7:
	mov.b		&mda7_flg,SPCOND_FLG(%a6) # set "special case" flag

	mov.l		EXC_A7(%a6),%d0		# Get current a7
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A7(%a6)		# Save decr value
	mov.l		%d0,%a0
	rts

########################################################
# Address register indirect w/ displacement: (d16, An) #
########################################################
addr_ind_disp_a0:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A0(%a6),%a0		# a0 + d16
	rts

addr_ind_disp_a1:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A1(%a6),%a0		# a1 + d16
	rts

addr_ind_disp_a2:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A2(%a6),%a0		# a2 + d16
	rts

addr_ind_disp_a3:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A3(%a6),%a0		# a3 + d16
	rts

addr_ind_disp_a4:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A4(%a6),%a0		# a4 + d16
	rts

addr_ind_disp_a5:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A5(%a6),%a0		# a5 + d16
	rts

addr_ind_disp_a6:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A6(%a6),%a0		# a6 + d16
	rts

addr_ind_disp_a7:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A7(%a6),%a0		# a7 + d16
	rts

########################################################################
# Address register indirect w/ index(8-bit displacement): (dn, An, Xn) #
#    "       "         "    w/   "  (base displacement): (bd, An, Xn)  #
# Memory indirect postindexed: ([bd, An], Xn, od)		       #
# Memory indirect preindexed: ([bd, An, Xn], od)		       #
########################################################################
_addr_ind_ext:
	mov.l		%d1,-(%sp)

	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# fetch extword in d0

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		(%sp)+,%d1

	mov.l		(EXC_AREGS,%a6,%d1.w*4),%a0 # put base in a0

	btst		&0x8,%d0
	beq.b		addr_ind_index_8bit	# for ext word or not?

	movm.l		&0x3c00,-(%sp)		# save d2-d5

	mov.l		%d0,%d5			# put extword in d5
	mov.l		%a0,%d3			# put base in d3

	bra.l		calc_mem_ind		# calc memory indirect
	
addr_ind_index_8bit:
	mov.l		%d2,-(%sp)		# save old d2

	mov.l		%d0,%d1
	rol.w		&0x4,%d1
	andi.w		&0xf,%d1		# extract index regno

	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d1 # fetch index reg value

	btst		&0xb,%d0		# is it word or long?
	bne.b		aii8_long
	ext.l		%d1			# sign extend word index
aii8_long:
	mov.l		%d0,%d2
	rol.w		&0x7,%d2
	andi.l		&0x3,%d2		# extract scale value

	lsl.l		%d2,%d1			# shift index by scale

	extb.l		%d0			# sign extend displacement
	add.l		%d1,%d0			# index + disp
	add.l		%d0,%a0			# An + (index + disp)

	mov.l		(%sp)+,%d2		# restore old d2
	rts

######################
# Immediate: #<data> #
#########################################################################
# word, long: <ea> of the data is the current extension word		#
# 	pointer value. new extension word pointer is simply the old	#
# 	plus the number of bytes in the data type(2 or 4).		#
#########################################################################
immediate:
	mov.b		&immed_flg,SPCOND_FLG(%a6) # set immediate flag

	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch extension word ptr
	rts

###########################
# Absolute short: (XXX).W #
###########################
abs_short:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# fetch short address

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# return <ea> in a0
	rts

##########################
# Absolute long: (XXX).L #
##########################
abs_long:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x4,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_long		# fetch long address

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		%d0,%a0			# return <ea> in a0
	rts

#######################################################
# Program counter indirect w/ displacement: (d16, PC) #
#######################################################
pc_ind:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# fetch word displacement

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement

	add.l		EXC_EXTWPTR(%a6),%a0	# pc + d16

# _imem_read_word() increased the extwptr by 2. need to adjust here.
	subq.l		&0x2,%a0		# adjust <ea>

	rts

##########################################################
# PC indirect w/ index(8-bit displacement): (d8, PC, An) #
# "     "     w/   "  (base displacement): (bd, PC, An)  #
# PC memory indirect postindexed: ([bd, PC], Xn, od)     #
# PC memory indirect preindexed: ([bd, PC, Xn], od)      #
##########################################################
pc_ind_ext:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# fetch ext word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		EXC_EXTWPTR(%a6),%a0	# put base in a0
	subq.l		&0x2,%a0		# adjust base

	btst		&0x8,%d0		# is disp only 8 bits?
	beq.b		pc_ind_index_8bit	# yes

# the indexed addressing mode uses a base displacement of size
# word or long
	movm.l		&0x3c00,-(%sp)		# save d2-d5

	mov.l		%d0,%d5			# put extword in d5
	mov.l		%a0,%d3			# put base in d3

	bra.l		calc_mem_ind		# calc memory indirect
	
pc_ind_index_8bit:
 	mov.l		%d2,-(%sp)		# create a temp register

	mov.l		%d0,%d1			# make extword copy
	rol.w		&0x4,%d1		# rotate reg num into place
	andi.w		&0xf,%d1		# extract register number

	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d1 # fetch index reg value

	btst		&0xb,%d0		# is index word or long?
	bne.b		pii8_long		# long
	ext.l		%d1			# sign extend word index
pii8_long:
	mov.l		%d0,%d2			# make extword copy
	rol.w		&0x7,%d2		# rotate scale value into place
	andi.l		&0x3,%d2		# extract scale value

	lsl.l		%d2,%d1			# shift index by scale

	extb.l		%d0			# sign extend displacement
	add.l		%d1,%d0			# index + disp
	add.l		%d0,%a0			# An + (index + disp)

	mov.l		(%sp)+,%d2		# restore temp register

	rts

# a5 = exc_extwptr	(global to uaeh)
# a4 = exc_opword	(global to uaeh)
# a3 = exc_dregs	(global to uaeh)

# d2 = index		(internal "     "    )
# d3 = base		(internal "     "    )
# d4 = od		(internal "     "    )
# d5 = extword		(internal "     "    )
calc_mem_ind:
	btst		&0x6,%d5		# is the index suppressed?
	beq.b		calc_index
	clr.l		%d2			# yes, so index = 0
	bra.b		base_supp_ck
calc_index:
	bfextu		%d5{&16:&4},%d2
	mov.l		(EXC_DREGS,%a6,%d2.w*4),%d2
	btst		&0xb,%d5		# is index word or long?
	bne.b		no_ext
	ext.l		%d2
no_ext:
	bfextu		%d5{&21:&2},%d0
	lsl.l		%d0,%d2
base_supp_ck:
	btst		&0x7,%d5		# is the bd suppressed?
	beq.b		no_base_sup
	clr.l		%d3
no_base_sup:
	bfextu		%d5{&26:&2},%d0	# get bd size
#	beq.l		_error			# if (size == 0) it's reserved
	cmpi.b	 	%d0,&2
	blt.b		no_bd
	beq.b		get_word_bd

	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x4,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_long
	
	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	bra.b		chk_ind
get_word_bd:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	ext.l		%d0			# sign extend bd
	
chk_ind:
	add.l		%d0,%d3			# base += bd
no_bd:
	bfextu		%d5{&30:&2},%d0		# is od suppressed?
	beq.w		aii_bd
	cmpi.b	 	%d0,&0x2
	blt.b		null_od
	beq.b		word_od
	
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x4,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_long

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	bra.b 		add_them

word_od:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	ext.l		%d0			# sign extend od
	bra.b		add_them

null_od:
	clr.l		%d0
add_them:
	mov.l		%d0,%d4
	btst		&0x2,%d5		# pre or post indexing?
	beq.b		pre_indexed

	mov.l		%d3,%a0
	bsr.l		_dmem_read_long

	tst.l		%d1			# dfetch error?
	bne.b		calc_ea_err		# yes

	add.l		%d2,%d0			# <ea> += index
	add.l		%d4,%d0			# <ea> += od
	bra.b		done_ea

pre_indexed:
	add.l		%d2,%d3			# preindexing
	mov.l		%d3,%a0
	bsr.l		_dmem_read_long

	tst.l		%d1			# ifetch error?
	bne.b		calc_ea_err		# yes

	add.l		%d4,%d0			# ea += od
	bra.b		done_ea

aii_bd:
	add.l		%d2,%d3			# ea = (base + bd) + index
	mov.l		%d3,%d0
done_ea:
	mov.l		%d0,%a0

	movm.l		(%sp)+,&0x003c		# restore d2-d5
	rts

# if dmem_read_long() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# FSLW:
# 	read = true
# 	size = longword
#	TM = data
# 	software emulation error = true
calc_ea_err:
	mov.l		%d3,%a0			# pass failing address
	mov.l		&0x01010001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF **************************************************************** #
# 	_moveperipheral(): routine to emulate movep instruction		#
#									#
# XREF **************************************************************** #
#	_dmem_read_byte() - read byte from memory			#
#	_dmem_write_byte() - write byte to memory			#
#	isp_dacc() - handle data access error exception			#
#									#
# INPUT *************************************************************** #
#	none								#
#									#
# OUTPUT ************************************************************** #
#	If exiting through isp_dacc...					#
#		a0 = failing address					#
#		d0 = FSLW						#
#	else								#
#		none							#
#									#
# ALGORITHM ***********************************************************	#
#	Decode the movep instruction words stored at EXC_OPWORD and	#
# either read or write the required bytes from/to memory. Use the	#
# _dmem_{read,write}_byte() routines. If one of the memory routines	#
# returns a failing value, we must pass the failing address and	a FSLW	#
# to the _isp_dacc() routine.						#
#	Since this instruction is used to access peripherals, make sure	#
# to only access the required bytes.					#
#									#
#########################################################################

###########################
# movep.(w,l)	Dx,(d,Ay) #
# movep.(w,l)	(d,Ay),Dx #
###########################
	global 		_moveperipheral
_moveperipheral:
	mov.w		EXC_OPWORD(%a6),%d1	# fetch the opcode word

	mov.b		%d1,%d0
	and.w		&0x7,%d0		# extract Ay from opcode word

	mov.l		(EXC_AREGS,%a6,%d0.w*4),%a0 # fetch ay

	add.w		EXC_EXTWORD(%a6),%a0	# add: an + sgn_ext(disp)

	btst		&0x7,%d1		# (reg 2 mem) or (mem 2 reg)
	beq.w		mem2reg

# reg2mem: fetch dx, then write it to memory
reg2mem:
	mov.w		%d1,%d0
	rol.w		&0x7,%d0
	and.w		&0x7,%d0		# extract Dx from opcode word

	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d0 # fetch dx

	btst		&0x6,%d1		# word or long operation?
	beq.b		r2mwtrans

# a0 = dst addr
# d0 = Dx
r2mltrans:
	mov.l		%d0,%d2			# store data
	mov.l		%a0,%a2			# store addr
	rol.l		&0x8,%d2
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write hi

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	add.w		&0x2,%a2		# incr addr
	mov.l		%a2,%a0
	rol.l		&0x8,%d2
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write lo

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	add.w		&0x2,%a2		# incr addr
	mov.l		%a2,%a0
	rol.l		&0x8,%d2
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write lo

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	add.w		&0x2,%a2		# incr addr
	mov.l		%a2,%a0
	rol.l		&0x8,%d2
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write lo

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	rts

# a0 = dst addr
# d0 = Dx
r2mwtrans:
	mov.l		%d0,%d2			# store data
	mov.l		%a0,%a2			# store addr
	lsr.w		&0x8,%d0

	bsr.l		_dmem_write_byte	# os  : write hi

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	add.w		&0x2,%a2
	mov.l		%a2,%a0
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write lo

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	rts

# mem2reg: read bytes from memory.
# determines the dest register, and then writes the bytes into it.
mem2reg:
	btst		&0x6,%d1		# word or long operation?
	beq.b		m2rwtrans

# a0 = dst addr
m2rltrans:
	mov.l		%a0,%a2			# store addr

	bsr.l		_dmem_read_byte		# read first byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	mov.l		%d0,%d2

	add.w		&0x2,%a2		# incr addr by 2 bytes
	mov.l		%a2,%a0

	bsr.l		_dmem_read_byte		# read second byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	lsl.w		&0x8,%d2
	mov.b		%d0,%d2			# append bytes

	add.w		&0x2,%a2		# incr addr by 2 bytes
	mov.l		%a2,%a0

	bsr.l		_dmem_read_byte		# read second byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	lsl.l		&0x8,%d2
	mov.b		%d0,%d2			# append bytes

	add.w		&0x2,%a2		# incr addr by 2 bytes
	mov.l		%a2,%a0

	bsr.l		_dmem_read_byte		# read second byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	lsl.l		&0x8,%d2
	mov.b		%d0,%d2			# append bytes

	mov.b		EXC_OPWORD(%a6),%d1
	lsr.b		&0x1,%d1
	and.w		&0x7,%d1		# extract Dx from opcode word
	
	mov.l		%d2,(EXC_DREGS,%a6,%d1.w*4) # store dx

	rts
	
# a0 = dst addr
m2rwtrans:
	mov.l		%a0,%a2			# store addr

	bsr.l		_dmem_read_byte		# read first byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	mov.l		%d0,%d2

	add.w		&0x2,%a2		# incr addr by 2 bytes
	mov.l		%a2,%a0

	bsr.l		_dmem_read_byte		# read second byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	lsl.w		&0x8,%d2
	mov.b		%d0,%d2			# append bytes

	mov.b		EXC_OPWORD(%a6),%d1
	lsr.b		&0x1,%d1
	and.w		&0x7,%d1		# extract Dx from opcode word
	
	mov.w		%d2,(EXC_DREGS+2,%a6,%d1.w*4) # store dx

	rts

# if dmem_{read,write}_byte() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# FSLW:
# 	write = true
#	size = byte
#	TM = data
#	software emulation error = true
movp_write_err:
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x00a10001,%d0		# pass fslw
	bra.l		isp_dacc

# FSLW:
# 	read = true
#	size = byte
#	TM = data
#	software emulation error = true
movp_read_err:
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01210001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF ****************************************************************	#
# 	_chk2_cmp2(): routine to emulate chk2/cmp2 instructions		#
#									#
# XREF ****************************************************************	#
#	_calc_ea(): calculate effective address				#
#	_dmem_read_long(): read operands				#
# 	_dmem_read_word(): read operands				#
#	isp_dacc(): handle data access error exception			#
#									#
# INPUT ***************************************************************	#
#	none								#
#									#
# OUTPUT **************************************************************	#
#	If exiting through isp_dacc...					#
#		a0 = failing address					#
#		d0 = FSLW						#
#	else								#
# 		none							#
#									#
# ALGORITHM ***********************************************************	#
#	First, calculate the effective address, then fetch the byte,	#
# word, or longword sized operands. Then, in the interest of 		#
# simplicity, all operands are converted to longword size whether the 	#
# operation is byte, word, or long. The bounds are sign extended 	#
# accordingly. If Rn is a data regsiter, Rn is also sign extended. If 	#
# Rn is an address register, it need not be sign extended since the 	#
# full register is always used.						#
#	The comparisons are made and the condition codes calculated.	#
# If the instruction is chk2 and the Rn value is out-of-bounds, set	#
# the ichk_flg in SPCOND_FLG.						#
#	If the memory fetch returns a failing value, pass the failing 	#
# address and FSLW to the isp_dacc() routine.				#
#									#
#########################################################################

	global 		_chk2_cmp2
_chk2_cmp2:

# passing size parameter doesn't matter since chk2 & cmp2 can't do
# either predecrement, postincrement, or immediate.
	bsr.l		_calc_ea		# calculate <ea>

	mov.b		EXC_EXTWORD(%a6), %d0	# fetch hi extension word
	rol.b		&0x4, %d0		# rotate reg bits into lo
	and.w		&0xf, %d0		# extract reg bits

	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d2 # get regval

	cmpi.b		EXC_OPWORD(%a6), &0x2	# what size is operation?
	blt.b		chk2_cmp2_byte		# size == byte
	beq.b		chk2_cmp2_word		# size == word

# the bounds are longword size. call routine to read the lower
# bound into d0 and the higher bound into d1.
chk2_cmp2_long:
	mov.l		%a0,%a2			# save copy of <ea>
	bsr.l		_dmem_read_long		# fetch long lower bound

	tst.l		%d1			# dfetch error?
	bne.w		chk2_cmp2_err_l		# yes

	mov.l		%d0,%d3			# save long lower bound
	addq.l		&0x4,%a2
	mov.l		%a2,%a0			# pass <ea> of long upper bound
	bsr.l		_dmem_read_long		# fetch long upper bound

	tst.l		%d1			# dfetch error?
	bne.w		chk2_cmp2_err_l		# yes

	mov.l		%d0,%d1			# long upper bound in d1
	mov.l		%d3,%d0			# long lower bound in d0
	bra.w		chk2_cmp2_compare	# go do the compare emulation

# the bounds are word size. fetch them in one subroutine call by
# reading a longword. sign extend both. if it's a data operation,
# sign extend Rn to long, also.
chk2_cmp2_word:
	mov.l		%a0,%a2
	bsr.l		_dmem_read_long		# fetch 2 word bounds

	tst.l		%d1			# dfetch error?
	bne.w		chk2_cmp2_err_l		# yes

	mov.w		%d0, %d1		# place hi in %d1
	swap		%d0			# place lo in %d0

	ext.l		%d0			# sign extend lo bnd
	ext.l		%d1			# sign extend hi bnd

	btst		&0x7, EXC_EXTWORD(%a6)	# address compare?
	bne.w		chk2_cmp2_compare	# yes; don't sign extend

# operation is a data register compare.
# sign extend word to long so we can do simple longword compares.
	ext.l		%d2			# sign extend data word
	bra.w		chk2_cmp2_compare	# go emulate compare

# the bounds are byte size. fetch them in one subroutine call by
# reading a word. sign extend both. if it's a data operation,
# sign extend Rn to long, also.
chk2_cmp2_byte:
	mov.l		%a0,%a2
	bsr.l		_dmem_read_word		# fetch 2 byte bounds

	tst.l		%d1			# dfetch error?
	bne.w		chk2_cmp2_err_w		# yes

	mov.b		%d0, %d1		# place hi in %d1
	lsr.w		&0x8, %d0		# place lo in %d0

	extb.l		%d0			# sign extend lo bnd
	extb.l		%d1			# sign extend hi bnd

	btst		&0x7, EXC_EXTWORD(%a6)	# address compare?
	bne.b		chk2_cmp2_compare	# yes; don't sign extend

# operation is a data register compare.
# sign extend byte to long so we can do simple longword compares.
	extb.l		%d2			# sign extend data byte

#
# To set the ccodes correctly:
# 	(1) save 'Z' bit from (Rn - lo)
#	(2) save 'Z' and 'N' bits from ((hi - lo) - (Rn - hi))
#	(3) keep 'X', 'N', and 'V' from before instruction
#	(4) combine ccodes
#
chk2_cmp2_compare:
	sub.l		%d0, %d2		# (Rn - lo)
	mov.w		%cc, %d3		# fetch resulting ccodes
	andi.b		&0x4, %d3		# keep 'Z' bit
	sub.l		%d0, %d1		# (hi - lo)
	cmp.l	 	%d1,%d2			# ((hi - lo) - (Rn - hi))

	mov.w		%cc, %d4		# fetch resulting ccodes
	or.b		%d4, %d3		# combine w/ earlier ccodes
	andi.b		&0x5, %d3		# keep 'Z' and 'N'

	mov.w		EXC_CC(%a6), %d4	# fetch old ccodes
	andi.b		&0x1a, %d4		# keep 'X','N','V' bits
	or.b		%d3, %d4		# insert new ccodes
	mov.w		%d4, EXC_CC(%a6)	# save new ccodes

	btst		&0x3, EXC_EXTWORD(%a6)	# separate chk2,cmp2
	bne.b		chk2_finish		# it's a chk2

	rts

# this code handles the only difference between chk2 and cmp2. chk2 would
# have trapped out if the value was out of bounds. we check this by seeing
# if the 'N' bit was set by the operation.
chk2_finish:	
	btst		&0x0, %d4		# is 'N' bit set?
	bne.b		chk2_trap		# yes;chk2 should trap
	rts
chk2_trap:
	mov.b		&ichk_flg,SPCOND_FLG(%a6) # set "special case" flag
	rts

# if dmem_read_{long,word}() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# FSLW:
#	read = true
#	size = longword
#	TM = data
# 	software emulation error = true
chk2_cmp2_err_l:
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01010001,%d0		# pass fslw
	bra.l		isp_dacc

# FSLW:
#	read = true
#	size = word
#	TM = data
# 	software emulation error = true
chk2_cmp2_err_w:
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01410001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF ****************************************************************	#
# 	_div64(): routine to emulate div{u,s}.l <ea>,Dr:Dq		#
#							64/32->32r:32q	#
#									#
# XREF ****************************************************************	#
#	_calc_ea() - calculate effective address			#
# 	isp_iacc() - handle instruction access error exception		#
#	isp_dacc() - handle data access error exception			#
#	isp_restore() - restore An on access error w/ -() or ()+	#
#									#
# INPUT ***************************************************************	#
#	none								#
#									#
# OUTPUT **************************************************************	#
# 	If exiting through isp_dacc...					#
#		a0 = failing address					#
# 		d0 = FSLW						#
#	else								#
#		none							#
#									#
# ALGORITHM ***********************************************************	#
# 	First, decode the operand location. If it's in Dn, fetch from	#
# the stack. If it's in memory, use _calc_ea() to calculate the 	#
# effective address. Use _dmem_read_long() to fetch at that address.	#
# Unless the operand is immediate data. Then use _imem_read_long().	#
# Send failures to isp_dacc() or isp_iacc() as appropriate.		#
#	If the operands are signed, make them unsigned and save	the 	#
# sign info for later. Separate out special cases like divide-by-zero	#
# or 32-bit divides if possible. Else, use a special math algorithm	#
# to calculate the result. 						#
#	Restore sign info if signed instruction. Set the condition 	#
# codes. Set idbyz_flg in SPCOND_FLG if divisor was zero. Store the 	#
# quotient and remainder in the appropriate data registers on the stack.#
#									#
#########################################################################

set	NDIVISOR,	EXC_TEMP+0x0
set	NDIVIDEND,	EXC_TEMP+0x1
set	NDRSAVE,	EXC_TEMP+0x2
set	NDQSAVE,	EXC_TEMP+0x4
set	DDSECOND,	EXC_TEMP+0x6
set	DDQUOTIENT,	EXC_TEMP+0x8
set	DDNORMAL,	EXC_TEMP+0xc

	global		_div64
#############
# div(u,s)l #
#############
_div64:
	mov.b		EXC_OPWORD+1(%a6), %d0
	andi.b		&0x38, %d0		# extract src mode

	bne.w		dcontrolmodel_s		# %dn dest or control mode?

	mov.b		EXC_OPWORD+1(%a6), %d0	# extract Dn from opcode
	andi.w		&0x7, %d0
	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d7 # fetch divisor from register

dgotsrcl:
	beq.w		div64eq0		# divisor is = 0!!!

	mov.b		EXC_EXTWORD+1(%a6), %d0	# extract Dr from extword
	mov.b		EXC_EXTWORD(%a6), %d1	# extract Dq from extword
	and.w		&0x7, %d0
	lsr.b		&0x4, %d1
	and.w		&0x7, %d1
	mov.w		%d0, NDRSAVE(%a6)	# save Dr for later
	mov.w		%d1, NDQSAVE(%a6)	# save Dq for later

# fetch %dr and %dq directly off stack since all regs are saved there
	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d5 # get dividend hi
	mov.l		(EXC_DREGS,%a6,%d1.w*4), %d6 # get dividend lo

# separate signed and unsigned divide
	btst		&0x3, EXC_EXTWORD(%a6)	# signed or unsigned?
	beq.b		dspecialcases		# use positive divide

# save the sign of the divisor
# make divisor unsigned if it's negative
	tst.l		%d7			# chk sign of divisor
	slt		NDIVISOR(%a6)		# save sign of divisor
	bpl.b		dsgndividend
	neg.l		%d7			# complement negative divisor

# save the sign of the dividend
# make dividend unsigned if it's negative
dsgndividend:
	tst.l		%d5			# chk sign of hi(dividend)
	slt		NDIVIDEND(%a6)		# save sign of dividend
	bpl.b		dspecialcases

	mov.w		&0x0, %cc		# clear 'X' cc bit
	negx.l		%d6			# complement signed dividend
	negx.l		%d5

# extract some special cases:
# 	- is (dividend == 0) ?
#	- is (hi(dividend) == 0 && (divisor <= lo(dividend))) ? (32-bit div)
dspecialcases:
	tst.l		%d5			# is (hi(dividend) == 0)
	bne.b		dnormaldivide		# no, so try it the long way

	tst.l		%d6			# is (lo(dividend) == 0), too
	beq.w		ddone			# yes, so (dividend == 0)

	cmp.l	 	%d7,%d6			# is (divisor <= lo(dividend))
	bls.b		d32bitdivide		# yes, so use 32 bit divide

	exg		%d5,%d6			# q = 0, r = dividend
	bra.w		divfinish		# can't divide, we're done.

d32bitdivide:
	tdivu.l		%d7, %d5:%d6		# it's only a 32/32 bit div!

	bra.b		divfinish

dnormaldivide:
# last special case:
# 	- is hi(dividend) >= divisor ? if yes, then overflow
	cmp.l		%d7,%d5
	bls.b		ddovf			# answer won't fit in 32 bits

# perform the divide algorithm:
	bsr.l		dclassical		# do int divide

# separate into signed and unsigned finishes.
divfinish:
	btst		&0x3, EXC_EXTWORD(%a6)	# do divs, divu separately
	beq.b		ddone			# divu has no processing!!!

# it was a divs.l, so ccode setting is a little more complicated...
	tst.b		NDIVIDEND(%a6)		# remainder has same sign 
	beq.b		dcc			# as dividend.
	neg.l		%d5			# sgn(rem) = sgn(dividend)
dcc:
	mov.b		NDIVISOR(%a6), %d0
	eor.b		%d0, NDIVIDEND(%a6)	# chk if quotient is negative
	beq.b		dqpos			# branch to quot positive

# 0x80000000 is the largest number representable as a 32-bit negative
# number. the negative of 0x80000000 is 0x80000000.
	cmpi.l		%d6, &0x80000000	# will (-quot) fit in 32 bits?
	bhi.b		ddovf

	neg.l		%d6			# make (-quot) 2's comp

	bra.b		ddone

dqpos:
	btst		&0x1f, %d6		# will (+quot) fit in 32 bits?
	bne.b		ddovf

ddone:
# at this point, result is normal so ccodes are set based on result.
	mov.w		EXC_CC(%a6), %cc
	tst.l		%d6			# set %ccode bits
	mov.w		%cc, EXC_CC(%a6)

	mov.w		NDRSAVE(%a6), %d0	# get Dr off stack
	mov.w		NDQSAVE(%a6), %d1	# get Dq off stack	

# if the register numbers are the same, only the quotient gets saved.
# so, if we always save the quotient second, we save ourselves a cmp&beq
	mov.l		%d5, (EXC_DREGS,%a6,%d0.w*4) # save remainder
	mov.l		%d6, (EXC_DREGS,%a6,%d1.w*4) # save quotient

	rts

ddovf:
	bset		&0x1, EXC_CC+1(%a6)	# 'V' set on overflow
	bclr		&0x0, EXC_CC+1(%a6)	# 'C' cleared on overflow

	rts

div64eq0:
	andi.b		&0x1e, EXC_CC+1(%a6)	# clear 'C' bit on divbyzero
	ori.b		&idbyz_flg,SPCOND_FLG(%a6) # set "special case" flag
	rts

###########################################################################
#########################################################################
# This routine uses the 'classical' Algorithm D from Donald Knuth's	#
# Art of Computer Programming, vol II, Seminumerical Algorithms.	#
# For this implementation b=2**16, and the target is U1U2U3U4/V1V2,	#
# where U,V are words of the quadword dividend and longword divisor,	#
# and U1, V1 are the most significant words.				#
# 									#
# The most sig. longword of the 64 bit dividend must be in %d5, least 	#
# in %d6. The divisor must be in the variable ddivisor, and the		#
# signed/unsigned flag ddusign must be set (0=unsigned,1=signed).	#
# The quotient is returned in %d6, remainder in %d5, unless the		#
# v (overflow) bit is set in the saved %ccr. If overflow, the dividend	#
# is unchanged.								#
#########################################################################
dclassical:
# if the divisor msw is 0, use simpler algorithm then the full blown
# one at ddknuth:

	cmpi.l		%d7, &0xffff
	bhi.b		ddknuth			# go use D. Knuth algorithm

# Since the divisor is only a word (and larger than the mslw of the dividend),
# a simpler algorithm may be used :
# In the general case, four quotient words would be created by
# dividing the divisor word into each dividend word. In this case,
# the first two quotient words must be zero, or overflow would occur.
# Since we already checked this case above, we can treat the most significant
# longword of the dividend as (0) remainder (see Knuth) and merely complete 
# the last two divisions to get a quotient longword and word remainder:

	clr.l		%d1
	swap		%d5			# same as r*b if previous step rqd
	swap		%d6			# get u3 to lsw position
	mov.w		%d6, %d5		# rb + u3

	divu.w		%d7, %d5

	mov.w		%d5, %d1		# first quotient word
	swap		%d6			# get u4
	mov.w		%d6, %d5		# rb + u4

	divu.w		%d7, %d5

	swap		%d1
	mov.w		%d5, %d1		# 2nd quotient 'digit'
	clr.w		%d5
	swap		%d5			# now remainder
	mov.l		%d1, %d6		# and quotient

	rts

ddknuth:
# In this algorithm, the divisor is treated as a 2 digit (word) number
# which is divided into a 3 digit (word) dividend to get one quotient
# digit (word). After subtraction, the dividend is shifted and the
# process repeated. Before beginning, the divisor and quotient are
# 'normalized' so that the process of estimating the quotient digit
# will yield verifiably correct results..

	clr.l		DDNORMAL(%a6)		# count of shifts for normalization
	clr.b		DDSECOND(%a6)		# clear flag for quotient digits
	clr.l		%d1			# %d1 will hold trial quotient
ddnchk:
	btst		&31, %d7		# must we normalize? first word of 
	bne.b		ddnormalized		# divisor (V1) must be >= 65536/2
	addq.l		&0x1, DDNORMAL(%a6)	# count normalization shifts
	lsl.l		&0x1, %d7		# shift the divisor
	lsl.l		&0x1, %d6		# shift u4,u3 with overflow to u2
	roxl.l		&0x1, %d5		# shift u1,u2 
	bra.w		ddnchk
ddnormalized:

# Now calculate an estimate of the quotient words (msw first, then lsw).
# The comments use subscripts for the first quotient digit determination.
	mov.l		%d7, %d3		# divisor
	mov.l		%d5, %d2		# dividend mslw
	swap		%d2
	swap		%d3
	cmp.w	 	%d2, %d3		# V1 = U1 ?
	bne.b		ddqcalc1
	mov.w		&0xffff, %d1		# use max trial quotient word
	bra.b		ddadj0
ddqcalc1:
	mov.l		%d5, %d1		

	divu.w		%d3, %d1		# use quotient of mslw/msw

	andi.l		&0x0000ffff, %d1	# zero any remainder
ddadj0:

# now test the trial quotient and adjust. This step plus the
# normalization assures (according to Knuth) that the trial
# quotient will be at worst 1 too large.
	mov.l		%d6, -(%sp)
	clr.w		%d6			# word u3 left
	swap		%d6			# in lsw position
ddadj1: mov.l		%d7, %d3
	mov.l		%d1, %d2
	mulu.w		%d7, %d2		# V2q
	swap		%d3
	mulu.w		%d1, %d3		# V1q
	mov.l		%d5, %d4		# U1U2
	sub.l		%d3, %d4		# U1U2 - V1q

	swap		%d4

	mov.w		%d4,%d0
	mov.w		%d6,%d4			# insert lower word (U3)

	tst.w		%d0			# is upper word set?
	bne.w		ddadjd1

#	add.l		%d6, %d4		# (U1U2 - V1q) + U3

	cmp.l	 	%d2, %d4
	bls.b		ddadjd1			# is V2q > (U1U2-V1q) + U3 ?
	subq.l		&0x1, %d1		# yes, decrement and recheck
	bra.b		ddadj1
ddadjd1:
# now test the word by multiplying it by the divisor (V1V2) and comparing
# the 3 digit (word) result with the current dividend words
	mov.l		%d5, -(%sp)		# save %d5 (%d6 already saved)
	mov.l		%d1, %d6
	swap		%d6			# shift answer to ms 3 words
	mov.l		%d7, %d5
	bsr.l		dmm2
	mov.l		%d5, %d2		# now %d2,%d3 are trial*divisor
	mov.l		%d6, %d3
	mov.l		(%sp)+, %d5		# restore dividend
	mov.l		(%sp)+, %d6
	sub.l		%d3, %d6
	subx.l		%d2, %d5		# subtract double precision
	bcc		dd2nd			# no carry, do next quotient digit
	subq.l		&0x1, %d1		# q is one too large
# need to add back divisor longword to current ms 3 digits of dividend
# - according to Knuth, this is done only 2 out of 65536 times for random
# divisor, dividend selection.
	clr.l		%d2
	mov.l		%d7, %d3
	swap		%d3
	clr.w		%d3			# %d3 now ls word of divisor
	add.l		%d3, %d6		# aligned with 3rd word of dividend
	addx.l		%d2, %d5
	mov.l		%d7, %d3
	clr.w		%d3			# %d3 now ms word of divisor
	swap		%d3			# aligned with 2nd word of dividend
	add.l		%d3, %d5
dd2nd:
	tst.b		DDSECOND(%a6)		# both q words done?
	bne.b		ddremain
# first quotient digit now correct. store digit and shift the
# (subtracted) dividend 
	mov.w		%d1, DDQUOTIENT(%a6)
	clr.l		%d1
	swap		%d5
	swap		%d6
	mov.w		%d6, %d5
	clr.w		%d6
	st		DDSECOND(%a6)		# second digit
	bra.w		ddnormalized
ddremain:
# add 2nd word to quotient, get the remainder.
	mov.w 		%d1, DDQUOTIENT+2(%a6)
# shift down one word/digit to renormalize remainder.
	mov.w		%d5, %d6
	swap		%d6
	swap		%d5
	mov.l		DDNORMAL(%a6), %d7	# get norm shift count
	beq.b		ddrn
	subq.l		&0x1, %d7		# set for loop count
ddnlp:
	lsr.l		&0x1, %d5		# shift into %d6
	roxr.l		&0x1, %d6
	dbf		%d7, ddnlp
ddrn:
	mov.l		%d6, %d5		# remainder
	mov.l		DDQUOTIENT(%a6), %d6 	# quotient

	rts
dmm2:
# factors for the 32X32->64 multiplication are in %d5 and %d6.
# returns 64 bit result in %d5 (hi) %d6(lo).
# destroys %d2,%d3,%d4.

# multiply hi,lo words of each factor to get 4 intermediate products
	mov.l		%d6, %d2
	mov.l		%d6, %d3
	mov.l		%d5, %d4
	swap		%d3
	swap		%d4
	mulu.w		%d5, %d6		# %d6 <- lsw*lsw
	mulu.w		%d3, %d5		# %d5 <- msw-dest*lsw-source
	mulu.w		%d4, %d2		# %d2 <- msw-source*lsw-dest
	mulu.w		%d4, %d3		# %d3 <- msw*msw
# now use swap and addx to consolidate to two longwords
	clr.l		%d4
	swap		%d6
	add.w		%d5, %d6		# add msw of l*l to lsw of m*l product
	addx.w		%d4, %d3		# add any carry to m*m product
	add.w		%d2, %d6		# add in lsw of other m*l product
	addx.w		%d4, %d3		# add any carry to m*m product
	swap		%d6			# %d6 is low 32 bits of final product
	clr.w		%d5
	clr.w		%d2			# lsw of two mixed products used,
	swap		%d5			# now use msws of longwords
	swap		%d2
	add.l		%d2, %d5				
	add.l		%d3, %d5		# %d5 now ms 32 bits of final product
	rts

##########
dcontrolmodel_s:
	movq.l		&LONG,%d0
	bsr.l		_calc_ea		# calc <ea>

	cmpi.b		SPCOND_FLG(%a6),&immed_flg # immediate addressing mode?
	beq.b		dimmed			# yes

	mov.l		%a0,%a2
	bsr.l		_dmem_read_long		# fetch divisor from <ea>

	tst.l		%d1			# dfetch error?
	bne.b		div64_err		# yes

	mov.l		%d0, %d7
	bra.w		dgotsrcl

# we have to split out immediate data here because it must be read using
# imem_read() instead of dmem_read(). this becomes especially important
# if the fetch runs into some deadly fault.
dimmed:
	addq.l		&0x4,EXC_EXTWPTR(%a6)
	bsr.l		_imem_read_long		# read immediate value

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		%d0,%d7
	bra.w		dgotsrcl

##########

# if dmem_read_long() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# also, we call isp_restore in case the effective addressing mode was
# (an)+ or -(an) in which case the previous "an" value must be restored.
# FSLW:
# 	read = true
# 	size = longword
#	TM = data
# 	software emulation error = true
div64_err:
	bsr.l		isp_restore		# restore addr reg
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01010001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF ****************************************************************	#
#	_mul64(): routine to emulate mul{u,s}.l <ea>,Dh:Dl 32x32->64	#
#									#
# XREF ****************************************************************	#
#	_calc_ea() - calculate effective address			#
#	isp_iacc() - handle instruction access error exception		#
# 	isp_dacc() - handle data access error exception			#
#	isp_restore() - restore An on access error w/ -() or ()+	#
#									#
# INPUT ***************************************************************	#
#	none								#
#									#
# OUTPUT **************************************************************	#
# 	If exiting through isp_dacc...					#
#		a0 = failing address					#
#		d0 = FSLW						#
# 	else								#
#		none							#
#									#
# ALGORITHM ***********************************************************	#
#	First, decode the operand location. If it's in Dn, fetch from	#
# the stack. If it's in memory, use _calc_ea() to calculate the		#
# effective address. Use _dmem_read_long() to fetch at that address.	#
# Unless the operand is immediate data. Then use _imem_read_long().	#
# Send failures to isp_dacc() or isp_iacc() as appropriate.		#
#	If the operands are signed, make them unsigned and save the 	#
# sign info for later. Perform the multiplication using 16x16->32	#
# unsigned multiplies and "add" instructions. Store the high and low 	#
# portions of the result in the appropriate data registers on the	#
# stack. Calculate the condition codes, also.				#
#									#
#########################################################################

#############
# mul(u,s)l #
#############
	global		_mul64
_mul64:
	mov.b		EXC_OPWORD+1(%a6), %d0	# extract src {mode,reg}
	cmpi.b		%d0, &0x7		# is src mode Dn or other?
	bgt.w		mul64_memop		# src is in memory

# multiplier operand in the the data register file.
# must extract the register number and fetch the operand from the stack.
mul64_regop:
	andi.w		&0x7, %d0		# extract Dn
	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d3 # fetch multiplier

# multiplier is in %d3. now, extract Dl and Dh fields and fetch the
# multiplicand from the data register specified by Dl.
mul64_multiplicand:
	mov.w		EXC_EXTWORD(%a6), %d2	# fetch ext word
	clr.w		%d1			# clear Dh reg
	mov.b		%d2, %d1		# grab Dh
	rol.w		&0x4, %d2		# align Dl byte
	andi.w		&0x7, %d2		# extract Dl

	mov.l		(EXC_DREGS,%a6,%d2.w*4), %d4 # get multiplicand

# check for the case of "zero" result early
	tst.l		%d4			# test multiplicand
	beq.w		mul64_zero		# handle zero separately
	tst.l		%d3			# test multiplier
	beq.w		mul64_zero		# handle zero separately

# multiplier is in %d3 and multiplicand is in %d4.
# if the operation is to be signed, then the operands are converted
# to unsigned and the result sign is saved for the end.
	clr.b		EXC_TEMP(%a6)		# clear temp space
	btst		&0x3, EXC_EXTWORD(%a6)	# signed or unsigned?
	beq.b		mul64_alg		# unsigned; skip sgn calc

	tst.l		%d3			# is multiplier negative?
	bge.b		mul64_chk_md_sgn	# no
	neg.l		%d3			# make multiplier positive
	ori.b		&0x1, EXC_TEMP(%a6)	# save multiplier sgn

# the result sign is the exclusive or of the operand sign bits.
mul64_chk_md_sgn:
	tst.l		%d4			# is multiplicand negative?
	bge.b		mul64_alg		# no	
	neg.l		%d4			# make multiplicand positive
	eori.b		&0x1, EXC_TEMP(%a6)	# calculate correct sign

#########################################################################
#	63			   32				0	#
# 	----------------------------					#
# 	| hi(mplier) * hi(mplicand)|					#
# 	----------------------------					#
#		     -----------------------------			#
#		     | hi(mplier) * lo(mplicand) |			#
#		     -----------------------------			#
#		     -----------------------------			#
#		     | lo(mplier) * hi(mplicand) |			#
#		     -----------------------------			#
#	  |			   -----------------------------	#
#	--|--			   | lo(mplier) * lo(mplicand) |	#
#	  |			   -----------------------------	#
#	========================================================	#
#	--------------------------------------------------------	#
#	|	hi(result)	   |	    lo(result)         |	#
#	--------------------------------------------------------	#
#########################################################################
mul64_alg:
# load temp registers with operands
	mov.l		%d3, %d5		# mr in %d5
	mov.l		%d3, %d6		# mr in %d6
	mov.l		%d4, %d7		# md in %d7
	swap		%d6			# hi(mr) in lo %d6
	swap		%d7			# hi(md) in lo %d7

# complete necessary multiplies:
	mulu.w		%d4, %d3		# [1] lo(mr) * lo(md)
	mulu.w		%d6, %d4		# [2] hi(mr) * lo(md)
	mulu.w		%d7, %d5		# [3] lo(mr) * hi(md)
	mulu.w		%d7, %d6		# [4] hi(mr) * hi(md)

# add lo portions of [2],[3] to hi portion of [1].
# add carries produced from these adds to [4].
# lo([1]) is the final lo 16 bits of the result.
	clr.l		%d7			# load %d7 w/ zero value
	swap		%d3			# hi([1]) <==> lo([1])
	add.w		%d4, %d3		# hi([1]) + lo([2])
	addx.l		%d7, %d6		#    [4]  + carry
	add.w		%d5, %d3		# hi([1]) + lo([3])
	addx.l		%d7, %d6		#    [4]  + carry
	swap		%d3			# lo([1]) <==> hi([1])

# lo portions of [2],[3] have been added in to final result.
# now, clear lo, put hi in lo reg, and add to [4]
	clr.w		%d4			# clear lo([2])
	clr.w		%d5			# clear hi([3])
	swap		%d4			# hi([2]) in lo %d4
	swap		%d5			# hi([3]) in lo %d5
	add.l		%d5, %d4		#    [4]  + hi([2])
	add.l		%d6, %d4		#    [4]  + hi([3])

# unsigned result is now in {%d4,%d3}
	tst.b		EXC_TEMP(%a6)		# should result be signed?
	beq.b		mul64_done		# no

# result should be a signed negative number.
# compute 2's complement of the unsigned number:
#   -negate all bits and add 1
mul64_neg:
	not.l		%d3			# negate lo(result) bits
	not.l		%d4			# negate hi(result) bits
	addq.l		&1, %d3			# add 1 to lo(result)
	addx.l		%d7, %d4		# add carry to hi(result)

# the result is saved to the register file.
# for '040 compatability, if Dl == Dh then only the hi(result) is
# saved. so, saving hi after lo accomplishes this without need to
# check Dl,Dh equality.
mul64_done:
	mov.l		%d3, (EXC_DREGS,%a6,%d2.w*4) # save lo(result)
	mov.w		&0x0, %cc
	mov.l		%d4, (EXC_DREGS,%a6,%d1.w*4) # save hi(result)

# now, grab the condition codes. only one that can be set is 'N'.
# 'N' CAN be set if the operation is unsigned if bit 63 is set.
	mov.w		%cc, %d7		# fetch %ccr to see if 'N' set
	andi.b		&0x8, %d7		# extract 'N' bit

mul64_ccode_set:
	mov.b		EXC_CC+1(%a6), %d6 	# fetch previous %ccr
	andi.b		&0x10, %d6		# all but 'X' bit changes

	or.b		%d7, %d6		# group 'X' and 'N'
	mov.b		%d6, EXC_CC+1(%a6)	# save new %ccr

	rts

# one or both of the operands is zero so the result is also zero.
# save the zero result to the register file and set the 'Z' ccode bit.
mul64_zero:
	clr.l		(EXC_DREGS,%a6,%d2.w*4) # save lo(result)
	clr.l		(EXC_DREGS,%a6,%d1.w*4) # save hi(result)

	movq.l		&0x4, %d7		# set 'Z' ccode bit
	bra.b		mul64_ccode_set		# finish ccode set

##########

# multiplier operand is in memory at the effective address.
# must calculate the <ea> and go fetch the 32-bit operand.
mul64_memop:
	movq.l		&LONG, %d0		# pass # of bytes
	bsr.l		_calc_ea		# calculate <ea>

	cmpi.b		SPCOND_FLG(%a6),&immed_flg # immediate addressing mode?
	beq.b		mul64_immed		# yes

	mov.l		%a0,%a2
	bsr.l		_dmem_read_long		# fetch src from addr (%a0)

	tst.l		%d1			# dfetch error?
	bne.w		mul64_err		# yes

	mov.l		%d0, %d3		# store multiplier in %d3

	bra.w		mul64_multiplicand

# we have to split out immediate data here because it must be read using
# imem_read() instead of dmem_read(). this becomes especially important
# if the fetch runs into some deadly fault.
mul64_immed:
	addq.l		&0x4,EXC_EXTWPTR(%a6)
	bsr.l		_imem_read_long		# read immediate value

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		%d0,%d3
	bra.w		mul64_multiplicand

##########

# if dmem_read_long() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# also, we call isp_restore in case the effective addressing mode was
# (an)+ or -(an) in which case the previous "an" value must be restored.
# FSLW:
# 	read = true
# 	size = longword
#	TM = data
# 	software emulation error = true
mul64_err:
	bsr.l		isp_restore		# restore addr reg
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01010001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF ****************************************************************	#
#	_compandset2(): routine to emulate cas2()			#
#			(internal to package)				#
#									#
#	_isp_cas2_finish(): store ccodes, store compare regs		#
#			    (external to package)			#
#									#
# XREF ****************************************************************	#
#	_real_lock_page() - "callout" to lock op's page from page-outs	#
#	_cas_terminate2() - access error exit				#
#	_real_cas2() - "callout" to core cas2 emulation code		#
#	_real_unlock_page() - "callout" to unlock page			#
#									#
# INPUT ***************************************************************	#
# _compandset2():							#
#	d0 = instruction extension word					#
#									#
# _isp_cas2_finish():							#
#	see cas2 core emulation code					#
# 									#
# OUTPUT **************************************************************	#
# _compandset2():							#
#	see cas2 core emulation code					#
#									#
# _isp_cas_finish():							#
#	None (register file or memroy changed as appropriate)		#
#									#
# ALGORITHM ***********************************************************	#
# compandset2():							#
#	Decode the instruction and fetch the appropriate Update and	#
# Compare operands. Then call the "callout" _real_lock_page() for each	#
# memory operand address so that the operating system can keep these	#
# pages from being paged out. If either _real_lock_page() fails, exit	#
# through _cas_terminate2(). Don't forget to unlock the 1st locked page	#
# using _real_unlock_paged() if the 2nd lock-page fails.		#
# Finally, branch to the core cas2 emulation code by calling the 	#
# "callout" _real_cas2().						#
#									#
# _isp_cas2_finish():							#
#	Re-perform the comparison so we can determine the condition	#
# codes which were too much trouble to keep around during the locked	#
# emulation. Then unlock each operands page by calling the "callout"	#
# _real_unlock_page().							#
#									#
#########################################################################

set ADDR1,	EXC_TEMP+0xc
set ADDR2,	EXC_TEMP+0x0
set DC2,	EXC_TEMP+0xa
set DC1,	EXC_TEMP+0x8

	global		_compandset2
_compandset2:
	mov.l		%d0,EXC_TEMP+0x4(%a6)		# store for possible restart
	mov.l		%d0,%d1			# extension word in d0

	rol.w		&0x4,%d0
	andi.w		&0xf,%d0		# extract Rn2
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%a1 # fetch ADDR2
	mov.l		%a1,ADDR2(%a6)

	mov.l		%d1,%d0

	lsr.w		&0x6,%d1
	andi.w		&0x7,%d1		# extract Du2
	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d5 # fetch Update2 Op

	andi.w		&0x7,%d0		# extract Dc2
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%d3 # fetch Compare2 Op
	mov.w		%d0,DC2(%a6)

	mov.w		EXC_EXTWORD(%a6),%d0
	mov.l		%d0,%d1

	rol.w		&0x4,%d0
	andi.w		&0xf,%d0		# extract Rn1
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%a0 # fetch ADDR1
	mov.l		%a0,ADDR1(%a6)

	mov.l		%d1,%d0

	lsr.w		&0x6,%d1
	andi.w		&0x7,%d1		# extract Du1
	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d4 # fetch Update1 Op
	
	andi.w		&0x7,%d0		# extract Dc1
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%d2 # fetch Compare1 Op
	mov.w		%d0,DC1(%a6)

	btst		&0x1,EXC_OPWORD(%a6)	# word or long?
	sne		%d7

	btst		&0x5,EXC_ISR(%a6)	# user or supervisor?
	sne		%d6

	mov.l		%a0,%a2
	mov.l		%a1,%a3

	mov.l		%d7,%d1			# pass size
	mov.l		%d6,%d0			# pass mode
	bsr.l		_real_lock_page		# lock page
	mov.l		%a2,%a0
	tst.l		%d0			# error?
	bne.l		_cas_terminate2		# yes

	mov.l		%d7,%d1			# pass size
	mov.l		%d6,%d0			# pass mode
	mov.l		%a3,%a0			# pass addr
	bsr.l		_real_lock_page		# lock page
	mov.l		%a3,%a0
	tst.l		%d0			# error?
	bne.b		cas_preterm		# yes

	mov.l		%a2,%a0
	mov.l		%a3,%a1

	bra.l		_real_cas2

# if the 2nd lock attempt fails, then we must still unlock the 
# first page(s).
cas_preterm:
	mov.l		%d0,-(%sp)		# save FSLW
	mov.l		%d7,%d1			# pass size
	mov.l		%d6,%d0			# pass mode
	mov.l		%a2,%a0			# pass ADDR1
	bsr.l		_real_unlock_page	# unlock first page(s)
	mov.l		(%sp)+,%d0		# restore FSLW
	mov.l		%a3,%a0			# pass failing addr
	bra.l		_cas_terminate2

#############################################################

	global		_isp_cas2_finish
_isp_cas2_finish:
	btst		&0x1,EXC_OPWORD(%a6)
	bne.b		cas2_finish_l

	mov.w		EXC_CC(%a6),%cc		# load old ccodes
	cmp.w		%d0,%d2
	bne.b		cas2_finish_w_save
	cmp.w		%d1,%d3
cas2_finish_w_save:
	mov.w		%cc,EXC_CC(%a6)		# save new ccodes

	tst.b		%d4			# update compare reg?
	bne.b		cas2_finish_w_done	# no

	mov.w		DC2(%a6),%d3		# fetch Dc2
	mov.w		%d1,(2+EXC_DREGS,%a6,%d3.w*4) # store new Compare2 Op

	mov.w		DC1(%a6),%d2		# fetch Dc1
	mov.w		%d0,(2+EXC_DREGS,%a6,%d2.w*4) # store new Compare1 Op

cas2_finish_w_done:
	btst		&0x5,EXC_ISR(%a6)
	sne		%d2
	mov.l		%d2,%d0			# pass mode
	sf		%d1			# pass size
	mov.l		ADDR1(%a6),%a0		# pass ADDR1
	bsr.l		_real_unlock_page	# unlock page
	
	mov.l		%d2,%d0			# pass mode
	sf		%d1			# pass size
	mov.l		ADDR2(%a6),%a0		# pass ADDR2
	bsr.l		_real_unlock_page	# unlock page
	rts

cas2_finish_l:
	mov.w		EXC_CC(%a6),%cc		# load old ccodes
	cmp.l		%d0,%d2
	bne.b		cas2_finish_l_save
	cmp.l		%d1,%d3
cas2_finish_l_save:
	mov.w		%cc,EXC_CC(%a6)		# save new ccodes

	tst.b		%d4			# update compare reg?
	bne.b		cas2_finish_l_done	# no

	mov.w		DC2(%a6),%d3		# fetch Dc2
	mov.l		%d1,(EXC_DREGS,%a6,%d3.w*4) # store new Compare2 Op

	mov.w		DC1(%a6),%d2		# fetch Dc1
	mov.l		%d0,(EXC_DREGS,%a6,%d2.w*4) # store new Compare1 Op

cas2_finish_l_done:
	btst		&0x5,EXC_ISR(%a6)
	sne		%d2
	mov.l		%d2,%d0			# pass mode
	st		%d1			# pass size
	mov.l		ADDR1(%a6),%a0		# pass ADDR1
	bsr.l		_real_unlock_page	# unlock page
	
	mov.l		%d2,%d0			# pass mode
	st		%d1			# pass size
	mov.l		ADDR2(%a6),%a0		# pass ADDR2
	bsr.l		_real_unlock_page	# unlock page
	rts

########
	global		cr_cas2
cr_cas2:
	mov.l		EXC_TEMP+0x4(%a6),%d0
	bra.w		_compandset2

#########################################################################
# XDEF ****************************************************************	#
#	_compandset(): routine to emulate cas w/ misaligned <ea>	#
#		       (internal to package)				#
#	_isp_cas_finish(): routine called when cas emulation completes	#
#			   (external and internal to package)		#
#	_isp_cas_restart(): restart cas emulation after a fault		#
#			    (external to package)			#
#	_isp_cas_terminate(): create access error stack frame on fault	#
#			      (external and internal to package)	#
#	_isp_cas_inrange(): checks whether instr addess is within range	#
#			    of core cas/cas2emulation code		#
#			    (external to package)			#
#									#
# XREF ****************************************************************	#
# 	_calc_ea(): calculate effective address				#
#									#
# INPUT ***************************************************************	#
# compandset():								#
# 	none								#
# _isp_cas_restart():							#
#	d6 = previous sfc/dfc						#
# _isp_cas_finish():							#
# _isp_cas_terminate():							#
#	a0 = failing address						#
#	d0 = FSLW							#
#	d6 = previous sfc/dfc						#
# _isp_cas_inrange():							#
#	a0 = instruction address to be checked				#
#									#
# OUTPUT **************************************************************	#
# compandset():								#
#		none							#
# _isp_cas_restart():							#
#	a0 = effective address						#
#	d7 = word or longword flag					#
# _isp_cas_finish():							#
#	a0 = effective address						#
# _isp_cas_terminate():							#
#	initial register set before emulation exception			#
# _isp_cas_inrange():							#
#	d0 = 0 => in range; -1 => out of range				#
#									#
# ALGORITHM ***********************************************************	#
#									#
# compandset():								#
#	First, calculate the effective address. Then, decode the 	#
# instruction word and fetch the "compare" (DC) and "update" (Du)	#
# operands.								#
# 	Next, call the external routine _real_lock_page() so that the	#
# operating system can keep this page from being paged out while we're	#
# in this routine. If this call fails, jump to _cas_terminate2().	#
#	The routine then branches to _real_cas(). This external routine	#
# that actually emulates cas can be supplied by the external os or	#
# made to point directly back into the 060ISP which has a routine for	#
# this purpose.								#
#									#
# _isp_cas_finish():							#
# 	Either way, after emulation, the package is re-entered at	#
# _isp_cas_finish(). This routine re-compares the operands in order to	#
# set the condition codes. Finally, these routines will call		#
# _real_unlock_page() in order to unlock the pages that were previously	#
# locked.								#
#									#
# _isp_cas_restart():							#
#	This routine can be entered from an access error handler where	#
# the emulation sequence should be re-started from the beginning.	#
#									#
# _isp_cas_terminate():							#
#	This routine can be entered from an access error handler where	#
# an emulation operand access failed and the operating system would	#
# like an access error stack frame created instead of the current 	#
# unimplemented integer instruction frame.				#
# 	Also, the package enters here if a call to _real_lock_page()	#
# fails.								#
#									#
# _isp_cas_inrange():							#
# 	Checks to see whether the instruction address passed to it in	#
# a0 is within the software package cas/cas2 emulation routines. This	#
# can be helpful for an operating system to determine whether an access	#
# error during emulation was due to a cas/cas2 emulation access.	#
#									#
#########################################################################

set DC,		EXC_TEMP+0x8
set ADDR,	EXC_TEMP+0x4

	global		_compandset
_compandset:
	btst		&0x1,EXC_OPWORD(%a6)	# word or long operation?
	bne.b		compandsetl		# long	

compandsetw:
	movq.l		&0x2,%d0		# size = 2 bytes
	bsr.l		_calc_ea		# a0 = calculated <ea>	
	mov.l		%a0,ADDR(%a6)		# save <ea> for possible restart
	sf		%d7			# clear d7 for word size
	bra.b		compandsetfetch

compandsetl:
	movq.l		&0x4,%d0		# size = 4 bytes
	bsr.l		_calc_ea		# a0 = calculated <ea>	
	mov.l		%a0,ADDR(%a6)		# save <ea> for possible restart
	st		%d7			# set d7 for longword size

compandsetfetch:
	mov.w		EXC_EXTWORD(%a6),%d0	# fetch cas extension word
	mov.l		%d0,%d1			# make a copy

	lsr.w		&0x6,%d0
	andi.w		&0x7,%d0		# extract Du
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%d2 # get update operand

	andi.w		&0x7,%d1		# extract Dc
	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d4 # get compare operand
	mov.w		%d1,DC(%a6)		# save Dc

	btst		&0x5,EXC_ISR(%a6)	# which mode for exception?
	sne		%d6			# set on supervisor mode

	mov.l		%a0,%a2			# save temporarily
	mov.l		%d7,%d1			# pass size
	mov.l		%d6,%d0			# pass mode
	bsr.l		_real_lock_page		# lock page
	tst.l		%d0			# did error occur?
	bne.w		_cas_terminate2		# yes, clean up the mess
	mov.l		%a2,%a0			# pass addr in a0
	
	bra.l		_real_cas

########
	global		_isp_cas_finish
_isp_cas_finish:
	btst		&0x1,EXC_OPWORD(%a6)
	bne.b		cas_finish_l

# just do the compare again since it's faster than saving the ccodes
# from the locked routine...
cas_finish_w:
	mov.w		EXC_CC(%a6),%cc		# restore cc
	cmp.w	 	%d0,%d4			# do word compare
	mov.w		%cc,EXC_CC(%a6)		# save cc

	tst.b		%d1			# update compare reg?
	bne.b		cas_finish_w_done	# no

	mov.w		DC(%a6),%d3
	mov.w		%d0,(EXC_DREGS+2,%a6,%d3.w*4) # Dc = destination

cas_finish_w_done:
	mov.l		ADDR(%a6),%a0		# pass addr
	sf		%d1			# pass size
	btst		&0x5,EXC_ISR(%a6)
	sne		%d0			# pass mode
	bsr.l		_real_unlock_page	# unlock page
	rts

# just do the compare again since it's faster than saving the ccodes
# from the locked routine...
cas_finish_l:
	mov.w		EXC_CC(%a6),%cc		# restore cc
	cmp.l	 	%d0,%d4			# do longword compare
	mov.w		%cc,EXC_CC(%a6)		# save cc

	tst.b		%d1			# update compare reg?
	bne.b		cas_finish_l_done	# no

	mov.w		DC(%a6),%d3
	mov.l		%d0,(EXC_DREGS,%a6,%d3.w*4) # Dc = destination

cas_finish_l_done:
	mov.l		ADDR(%a6),%a0		# pass addr
	st		%d1			# pass size
	btst		&0x5,EXC_ISR(%a6)
	sne		%d0			# pass mode
	bsr.l		_real_unlock_page	# unlock page
	rts

########
	
	global		_isp_cas_restart
_isp_cas_restart:
	mov.l		%d6,%sfc		# restore previous sfc
	mov.l		%d6,%dfc		# restore previous dfc

	cmpi.b		EXC_OPWORD+1(%a6),&0xfc	# cas or cas2?
	beq.l		cr_cas2			# cas2
cr_cas:
	mov.l		ADDR(%a6),%a0		# load <ea>
	btst		&0x1,EXC_OPWORD(%a6)	# word or long operation?
	sne		%d7			# set d7 accordingly
	bra.w		compandsetfetch	

########

# At this stage, it would be nice if d0 held the FSLW.
	global		_isp_cas_terminate
_isp_cas_terminate:
	mov.l		%d6,%sfc		# restore previous sfc
	mov.l		%d6,%dfc		# restore previous dfc

	global		_cas_terminate2
_cas_terminate2:
	mov.l		%a0,%a2			# copy failing addr to a2

	mov.l		%d0,-(%sp)
	bsr.l		isp_restore		# restore An (if ()+ or -())
	mov.l		(%sp)+,%d0

	addq.l		&0x4,%sp		# remove sub return addr
	subq.l		&0x8,%sp		# make room for bigger stack
	subq.l		&0x8,%a6		# shift frame ptr down, too
	mov.l		&26,%d1			# want to move 51 longwords
	lea		0x8(%sp),%a0		# get address of old stack
	lea		0x0(%sp),%a1		# get address of new stack
cas_term_cont:
	mov.l		(%a0)+,(%a1)+		# move a longword
	dbra.w		%d1,cas_term_cont	# keep going

	mov.w		&0x4008,EXC_IVOFF(%a6)	# put new stk fmt, voff
	mov.l		%a2,EXC_IVOFF+0x2(%a6)	# put faulting addr on stack
	mov.l		%d0,EXC_IVOFF+0x6(%a6)	# put FSLW on stack
	movm.l		EXC_DREGS(%a6),&0x3fff	# restore user regs
	unlk		%a6			# unlink stack frame
	bra.l		_real_access

########

	global		_isp_cas_inrange
_isp_cas_inrange:
	clr.l		%d0			# clear return result
	lea		_CASHI(%pc),%a1		# load end of CAS core code
	cmp.l		%a1,%a0			# is PC in range?
	blt.b		cin_no			# no
	lea		_CASLO(%pc),%a1		# load begin of CAS core code
	cmp.l		%a0,%a1			# is PC in range?
	blt.b		cin_no			# no
	rts					# yes; return d0 = 0
cin_no:	
	mov.l		&-0x1,%d0		# out of range; return d0 = -1
	rts

#################################################################
#################################################################
#################################################################
# This is the start of the cas and cas2 "core" emulation code.	#
# This is the section that may need to be replaced by the host	#
# OS if it is too operating system-specific.			#
# Please refer to the package documentation to see how to	#
# "replace" this section, if necessary.				#
#################################################################
#################################################################
#################################################################

#       ######      ##      ######     ####
#       #	   #  #     #         #    #
#	#	  ######    ######        #
#	#	  #    #         #      #
#       ######    #    #    ######    ######

#########################################################################
# XDEF ****************************************************************	#
#	_isp_cas2(): "core" emulation code for the cas2 instruction	#
#									#
# XREF ****************************************************************	#
#	_isp_cas2_finish() - only exit point for this emulation code;	#
#			     do clean-up; calculate ccodes; store 	#
#			     Compare Ops if appropriate.		#
#									#
# INPUT ***************************************************************	#
#	*see chart below*						#
# 									#
# OUTPUT **************************************************************	#
#	*see chart below*						#
#									#
# ALGORITHM ***********************************************************	#
#	(1) Make several copies of the effective address.		#
#	(2) Save current SR; Then mask off all maskable interrupts.	#
#	(3) Save current SFC/DFC (ASSUMED TO BE EQUAL!!!); Then set 	#
#	    according to whether exception occurred in user or 		#
#	    supervisor mode.						#
#	(4) Use "plpaw" instruction to pre-load ATC with effective	#
#	    address pages(s). THIS SHOULD NOT FAULT!!! The relevant	#
#	    page(s) should have already been made resident prior to	#
# 	    entering this routine.					#
#	(5) Push the operand lines from the cache w/ "cpushl". 		#
#	    In the 68040, this was done within the locked region. In	#
# 	    the 68060, it is done outside of the locked region.		#
#	(6) Use "plpar" instruction to do a re-load of ATC entries for	#
#	    ADDR1 since ADDR2 entries may have pushed ADDR1 out of the	#
#	    ATC.							#
#	(7) Pre-fetch the core emulation instructions by executing	#
#	    one branch within each physical line (16 bytes) of the code	#
#	    before actually executing the code.				#
#	(8) Load the BUSCR w/ the bus lock value.			#
#	(9) Fetch the source operands using "moves".			#
#	(10)Do the compares. If both equal, go to step (13).		#
#	(11)Unequal. No update occurs. But, we do write the DST1 op	#
#	    back to itself (as w/ the '040) so we can gracefully unlock	#
#	    the bus (and assert LOCKE*) using BUSCR and the final move.	#
#	(12)Exit.							#
#	(13)Write update operand to the DST locations. Use BUSCR to 	#
#	    assert LOCKE* for the final write operation.		#
#	(14)Exit.							#
#									#
# 	The algorithm is actually implemented slightly differently	#
# depending on the size of the operation and the misalignment of the 	#
# operands. A misaligned operand must be written in aligned chunks or	#
# else the BUSCR register control gets confused.			#
#									#
#########################################################################

#################################################################
# THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON		# 
# ENTERING _isp_cas2().						#
#								#
# D0 = xxxxxxxx							#
# D1 = xxxxxxxx							#
# D2 = cmp operand 1						#
# D3 = cmp operand 2						#
# D4 = update oper 1						#
# D5 = update oper 2						#
# D6 = 'xxxxxxff if supervisor mode; 'xxxxxx00 if user mode	#
# D7 = 'xxxxxxff if longword operation; 'xxxxxx00 if word 	#
# A0 = ADDR1							#
# A1 = ADDR2							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

#	align		0x1000
# beginning label used by _isp_cas_inrange()
	global		_CASLO
_CASLO:

	global		_isp_cas2
_isp_cas2:
	tst.b		%d6			# user or supervisor mode?
	bne.b		cas2_supervisor		# supervisor
cas2_user:
	movq.l		&0x1,%d0		# load user data fc
	bra.b		cas2_cont
cas2_supervisor:
	movq.l		&0x5,%d0		# load supervisor data fc
cas2_cont:
	tst.b		%d7			# word or longword?
	beq.w		cas2w			# word

####
cas2l:
	mov.l		%a0,%a2			# copy ADDR1
	mov.l		%a1,%a3			# copy ADDR2
	mov.l		%a0,%a4			# copy ADDR1
	mov.l		%a1,%a5			# copy ADDR2

	addq.l		&0x3,%a4		# ADDR1+3
	addq.l		&0x3,%a5		# ADDR2+3
	mov.l		%a2,%d1			# ADDR1

# mask interrupts levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# store new SFC
	movc		%d0,%dfc		# store new DFC

# pre-load the operand ATC. no page faults should occur here because
# _real_lock_page() should have taken care of this.
	plpaw		(%a2)			# load atc for ADDR1
	plpaw		(%a4)			# load atc for ADDR1+3
	plpaw		(%a3)			# load atc for ADDR2
	plpaw		(%a5)			# load atc for ADDR2+3

# push the operand lines from the cache if they exist.
	cpushl		%dc,(%a2)		# push line for ADDR1
	cpushl		%dc,(%a4)		# push line for ADDR1+3
	cpushl		%dc,(%a3)		# push line for ADDR2
	cpushl		%dc,(%a5)		# push line for ADDR2+2

	mov.l		%d1,%a2			# ADDR1
	addq.l		&0x3,%d1
	mov.l		%d1,%a4			# ADDR1+3
# if ADDR1 was ATC resident before the above "plpaw" and was executed
# and it was the next entry scheduled for replacement and ADDR2
# shares the same set, then the "plpaw" for ADDR2 can push the ADDR1
# entries from the ATC. so, we do a second set of "plpa"s.
	plpar		(%a2)			# load atc for ADDR1
	plpar		(%a4)			# load atc for ADDR1+3

# load the BUSCR values.
	mov.l		&0x80000000,%a2		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a3		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a4		# buscr unlock value

# there are three possible mis-aligned cases for longword cas. they
# are separated because the final write which asserts LOCKE* must
# be aligned.
	mov.l		%a0,%d0			# is ADDR1 misaligned?
	andi.b		&0x3,%d0
	beq.b		CAS2L_ENTER		# no
	cmpi.b		%d0,&0x2
	beq.w		CAS2L2_ENTER		# yes; word misaligned
	bra.w		CAS2L3_ENTER		# yes; byte misaligned

#
# D0 = dst operand 1 <-
# D1 = dst operand 2 <-
# D2 = cmp operand 1
# D3 = cmp operand 2
# D4 = update oper 1
# D5 = update oper 2
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR1
# A1 = ADDR2
# A2 = bus LOCK*  value
# A3 = bus LOCKE* value
# A4 = bus unlock value
# A5 = xxxxxxxx
#
	align 		0x10
CAS2L_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.l		(%a1),%d1		# fetch Dest2[31:0]
	movs.l		(%a0),%d0		# fetch Dest1[31:0]
	bra.b 		CAS2L_CONT
CAS2L_ENTER:
	bra.b		~+16

CAS2L_CONT:
	cmp.l	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2L_NOUPDATE
	cmp.l	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2L_NOUPDATE
	movs.l		%d5,(%a1)		# Update2[31:0] -> DEST2
	bra.b 		CAS2L_UPDATE
	bra.b		~+16

CAS2L_UPDATE:
	movc		%a3,%buscr		# assert LOCKE*
	movs.l		%d4,(%a0)		# Update1[31:0] -> DEST1
	movc		%a4,%buscr		# unlock the bus
	bra.b		cas2l_update_done
	bra.b		~+16

CAS2L_NOUPDATE:
	movc		%a3,%buscr		# assert LOCKE*
	movs.l		%d0,(%a0)		# Dest1[31:0] -> DEST1
	movc		%a4,%buscr		# unlock the bus
	bra.b		cas2l_noupdate_done
	bra.b		~+16

CAS2L_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CAS2L_START

####

#################################################################
# THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	# 
# ENTERING _isp_cas2().						#
#								#
# D0 = destination[31:0] operand 1				#
# D1 = destination[31:0] operand 2				#
# D2 = cmp[31:0] operand 1					#
# D3 = cmp[31:0] operand 2					#
# D4 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	#
# D5 = xxxxxxxx							#
# D6 = xxxxxxxx							#
# D7 = xxxxxxxx							#
# A0 = xxxxxxxx							#
# A1 = xxxxxxxx							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

cas2l_noupdate_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	sf		%d4			# indicate no update was done
	bra.l		_isp_cas2_finish

cas2l_update_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	st		%d4			# indicate update was done
	bra.l		_isp_cas2_finish
####

	align 		0x10
CAS2L2_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.l		(%a1),%d1		# fetch Dest2[31:0]
	movs.l		(%a0),%d0		# fetch Dest1[31:0]
	bra.b 		CAS2L2_CONT
CAS2L2_ENTER:
	bra.b		~+16

CAS2L2_CONT:
	cmp.l	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2L2_NOUPDATE
	cmp.l	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2L2_NOUPDATE
	movs.l		%d5,(%a1)		# Update2[31:0] -> Dest2
	bra.b 		CAS2L2_UPDATE
	bra.b		~+16

CAS2L2_UPDATE:
	swap		%d4			# get Update1[31:16]
	movs.w		%d4,(%a0)+		# Update1[31:16] -> DEST1
	movc		%a3,%buscr		# assert LOCKE*
	swap		%d4			# get Update1[15:0]
	bra.b		CAS2L2_UPDATE2
	bra.b		~+16

CAS2L2_UPDATE2:
	movs.w		%d4,(%a0)		# Update1[15:0] -> DEST1+0x2
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2l_update_done
	nop
	bra.b		~+16

CAS2L2_NOUPDATE:
	swap		%d0			# get Dest1[31:16]
	movs.w		%d0,(%a0)+		# Dest1[31:16] -> DEST1
	movc		%a3,%buscr		# assert LOCKE*
	swap		%d0			# get Dest1[15:0]
	bra.b		CAS2L2_NOUPDATE2
	bra.b		~+16

CAS2L2_NOUPDATE2:
	movs.w		%d0,(%a0)		# Dest1[15:0] -> DEST1+0x2
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2l_noupdate_done
	nop
	bra.b		~+16

CAS2L2_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CAS2L2_START

#################################

	align 		0x10
CAS2L3_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.l		(%a1),%d1		# fetch Dest2[31:0]
	movs.l		(%a0),%d0		# fetch Dest1[31:0]
	bra.b 		CAS2L3_CONT
CAS2L3_ENTER:
	bra.b		~+16

CAS2L3_CONT:
	cmp.l	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2L3_NOUPDATE
	cmp.l	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2L3_NOUPDATE
	movs.l		%d5,(%a1)		# Update2[31:0] -> DEST2
	bra.b 		CAS2L3_UPDATE
	bra.b		~+16

CAS2L3_UPDATE:
	rol.l		&0x8,%d4		# get Update1[31:24]
	movs.b		%d4,(%a0)+		# Update1[31:24] -> DEST1
	swap		%d4			# get Update1[23:8]
	movs.w		%d4,(%a0)+		# Update1[23:8] -> DEST1+0x1
	bra.b		CAS2L3_UPDATE2
	bra.b		~+16

CAS2L3_UPDATE2:
	rol.l		&0x8,%d4		# get Update1[7:0]
	movc		%a3,%buscr		# assert LOCKE*
	movs.b		%d4,(%a0)		# Update1[7:0] -> DEST1+0x3
	bra.b		CAS2L3_UPDATE3
	nop
	bra.b		~+16

CAS2L3_UPDATE3:
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2l_update_done
	nop
	nop
	nop
	bra.b		~+16
	
CAS2L3_NOUPDATE:
	rol.l		&0x8,%d0		# get Dest1[31:24]
	movs.b		%d0,(%a0)+		# Dest1[31:24] -> DEST1
	swap		%d0			# get Dest1[23:8]
	movs.w		%d0,(%a0)+		# Dest1[23:8] -> DEST1+0x1
	bra.b		CAS2L3_NOUPDATE2
	bra.b		~+16

CAS2L3_NOUPDATE2:
	rol.l		&0x8,%d0		# get Dest1[7:0]
	movc		%a3,%buscr		# assert LOCKE*
	movs.b		%d0,(%a0)		# Update1[7:0] -> DEST1+0x3
	bra.b		CAS2L3_NOUPDATE3
	nop
	bra.b		~+16

CAS2L3_NOUPDATE3:
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2l_noupdate_done
	nop
	nop
	nop
	bra.b		~+14

CAS2L3_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	bra.w		CAS2L3_START

#############################################################
#############################################################

cas2w:
	mov.l		%a0,%a2			# copy ADDR1
	mov.l		%a1,%a3			# copy ADDR2
	mov.l		%a0,%a4			# copy ADDR1
	mov.l		%a1,%a5			# copy ADDR2

	addq.l		&0x1,%a4		# ADDR1+1
	addq.l		&0x1,%a5		# ADDR2+1
	mov.l		%a2,%d1			# ADDR1

# mask interrupt levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# store new SFC
	movc		%d0,%dfc		# store new DFC

# pre-load the operand ATC. no page faults should occur because
# _real_lock_page() should have taken care of this.
	plpaw		(%a2)			# load atc for ADDR1
	plpaw		(%a4)			# load atc for ADDR1+1
	plpaw		(%a3)			# load atc for ADDR2
	plpaw		(%a5)			# load atc for ADDR2+1

# push the operand cache lines from the cache if they exist.
	cpushl		%dc,(%a2)		# push line for ADDR1
	cpushl		%dc,(%a4)		# push line for ADDR1+1
	cpushl		%dc,(%a3)		# push line for ADDR2
	cpushl		%dc,(%a5)		# push line for ADDR2+1

	mov.l		%d1,%a2			# ADDR1
	addq.l		&0x3,%d1
	mov.l		%d1,%a4			# ADDR1+3
# if ADDR1 was ATC resident before the above "plpaw" and was executed
# and it was the next entry scheduled for replacement and ADDR2
# shares the same set, then the "plpaw" for ADDR2 can push the ADDR1
# entries from the ATC. so, we do a second set of "plpa"s.
	plpar		(%a2)			# load atc for ADDR1
	plpar		(%a4)			# load atc for ADDR1+3

# load the BUSCR values.
	mov.l		&0x80000000,%a2		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a3		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a4		# buscr unlock value

# there are two possible mis-aligned cases for word cas. they
# are separated because the final write which asserts LOCKE* must
# be aligned.
	mov.l		%a0,%d0			# is ADDR1 misaligned?
	btst		&0x0,%d0
	bne.w		CAS2W2_ENTER		# yes
	bra.b		CAS2W_ENTER		# no

#
# D0 = dst operand 1 <-
# D1 = dst operand 2 <-
# D2 = cmp operand 1
# D3 = cmp operand 2
# D4 = update oper 1
# D5 = update oper 2
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR1
# A1 = ADDR2
# A2 = bus LOCK*  value
# A3 = bus LOCKE* value
# A4 = bus unlock value
# A5 = xxxxxxxx
#
	align 		0x10
CAS2W_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.w		(%a1),%d1		# fetch Dest2[15:0]
	movs.w		(%a0),%d0		# fetch Dest1[15:0]
	bra.b 		CAS2W_CONT2
CAS2W_ENTER:
	bra.b		~+16

CAS2W_CONT2:
	cmp.w	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2W_NOUPDATE
	cmp.w	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2W_NOUPDATE
	movs.w		%d5,(%a1)		# Update2[15:0] -> DEST2
	bra.b 		CAS2W_UPDATE
	bra.b		~+16

CAS2W_UPDATE:
	movc		%a3,%buscr		# assert LOCKE*
	movs.w		%d4,(%a0)		# Update1[15:0] -> DEST1
	movc		%a4,%buscr		# unlock the bus
	bra.b		cas2w_update_done
	bra.b		~+16

CAS2W_NOUPDATE:
	movc		%a3,%buscr		# assert LOCKE*
	movs.w		%d0,(%a0)		# Dest1[15:0] -> DEST1
	movc		%a4,%buscr		# unlock the bus
	bra.b		cas2w_noupdate_done
	bra.b		~+16

CAS2W_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CAS2W_START

####

#################################################################
# THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	# 
# ENTERING _isp_cas2().						#
#								#
# D0 = destination[15:0] operand 1				#
# D1 = destination[15:0] operand 2				#
# D2 = cmp[15:0] operand 1					#
# D3 = cmp[15:0] operand 2					#
# D4 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	#
# D5 = xxxxxxxx							#
# D6 = xxxxxxxx							#
# D7 = xxxxxxxx							#
# A0 = xxxxxxxx							#
# A1 = xxxxxxxx							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

cas2w_noupdate_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	sf		%d4			# indicate no update was done
	bra.l		_isp_cas2_finish

cas2w_update_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	st		%d4			# indicate update was done
	bra.l		_isp_cas2_finish
####

	align 		0x10
CAS2W2_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.w		(%a1),%d1		# fetch Dest2[15:0]
	movs.w		(%a0),%d0		# fetch Dest1[15:0]
	bra.b 		CAS2W2_CONT2
CAS2W2_ENTER:
	bra.b		~+16

CAS2W2_CONT2:
	cmp.w	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2W2_NOUPDATE
	cmp.w	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2W2_NOUPDATE
	movs.w		%d5,(%a1)		# Update2[15:0] -> DEST2
	bra.b 		CAS2W2_UPDATE
	bra.b		~+16

CAS2W2_UPDATE:
	ror.l		&0x8,%d4		# get Update1[15:8]
	movs.b		%d4,(%a0)+		# Update1[15:8] -> DEST1
	movc		%a3,%buscr		# assert LOCKE*
	rol.l		&0x8,%d4		# get Update1[7:0]
	bra.b		CAS2W2_UPDATE2
	bra.b		~+16

CAS2W2_UPDATE2:
	movs.b		%d4,(%a0)		# Update1[7:0] -> DEST1+0x1
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2w_update_done
	nop
	bra.b		~+16

CAS2W2_NOUPDATE:
	ror.l		&0x8,%d0		# get Dest1[15:8]
	movs.b		%d0,(%a0)+		# Dest1[15:8] -> DEST1
	movc		%a3,%buscr		# assert LOCKE*
	rol.l		&0x8,%d0		# get Dest1[7:0]
	bra.b		CAS2W2_NOUPDATE2
	bra.b		~+16

CAS2W2_NOUPDATE2:
	movs.b		%d0,(%a0)		# Dest1[7:0] -> DEST1+0x1
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2w_noupdate_done
	nop
	bra.b		~+16

CAS2W2_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CAS2W2_START

#       ######      ##      ######
#       #	   #  #     #     
#	#	  ######    ######
#	#	  #    #         #
#       ######    #    #    ######

#########################################################################
# XDEF ****************************************************************	#
# 	_isp_cas(): "core" emulation code for the cas instruction	#
#									#
# XREF ****************************************************************	#
#	_isp_cas_finish() - only exit point for this emulation code;	#
#			    do clean-up					#
#									#
# INPUT ***************************************************************	#
# 	*see entry chart below*						#
#									#
# OUTPUT **************************************************************	#
#	*see exit chart below*						#
#									#
# ALGORITHM ***********************************************************	#
# 	(1) Make several copies of the effective address. 		#
# 	(2) Save current SR; Then mask off all maskable interrupts.	#
#	(3) Save current DFC/SFC (ASSUMED TO BE EQUAL!!!); Then set	#
#	    SFC/DFC according to whether exception occurred in user or	#
#	    supervisor mode.						#
#	(4) Use "plpaw" instruction to pre-load ATC with efective	#
#	    address page(s). THIS SHOULD NOT FAULT!!! The relevant	#
# 	    page(s) should have been made resident prior to entering 	#
#	    this routine.						#
#	(5) Push the operand lines from the cache w/ "cpushl".		#
#	    In the 68040, this was done within the locked region. In	#
#	    the 68060, it is done outside of the locked region.		#
#	(6) Pre-fetch the core emulation instructions by executing one	#
#	    branch within each physical line (16 bytes) of the code	#
#	    before actually executing the code.				#
#	(7) Load the BUSCR with the bus lock value.			#
#	(8) Fetch the source operand.					#
#	(9) Do the compare. If equal, go to step (12).			#
#	(10)Unequal. No update occurs. But, we do write the DST op back	#
#	    to itself (as w/ the '040) so we can gracefully unlock	#
#	    the bus (and assert LOCKE*) using BUSCR and the final move.	#
#	(11)Exit.							#
#	(12)Write update operand to the DST location. Use BUSCR to	#
#	    assert LOCKE* for the final write operation.		#
#	(13)Exit.							#
# 									#
# 	The algorithm is actually implemented slightly diferently	#
# depending on the size of the operation and the misalignment of the	#
# operand. A misaligned operand must be written in aligned chunks or	#
# else the BUSCR register control gets confused.			#
#									#
#########################################################################

#########################################################
# THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON	#
# ENTERING _isp_cas().					#
#							#
# D0 = xxxxxxxx						#
# D1 = xxxxxxxx						#
# D2 = update operand					#
# D3 = xxxxxxxx						#
# D4 = compare operand					#
# D5 = xxxxxxxx						#
# D6 = supervisor ('xxxxxxff) or user mode ('xxxxxx00)	#
# D7 = longword ('xxxxxxff) or word size ('xxxxxx00)	#
# A0 = ADDR						#
# A1 = xxxxxxxx						#
# A2 = xxxxxxxx						#
# A3 = xxxxxxxx						#
# A4 = xxxxxxxx						#
# A5 = xxxxxxxx						#
# A6 = frame pointer					#
# A7 = stack pointer					#
#########################################################

	global		_isp_cas
_isp_cas:
	tst.b		%d6			# user or supervisor mode?
	bne.b		cas_super		# supervisor
cas_user:
	movq.l		&0x1,%d0		# load user data fc
	bra.b		cas_cont
cas_super:
	movq.l		&0x5,%d0		# load supervisor data fc

cas_cont:
	tst.b		%d7			# word or longword?
	bne.w		casl			# longword

####
casw:
	mov.l		%a0,%a1			# make copy for plpaw1
	mov.l		%a0,%a2			# make copy for plpaw2
	addq.l		&0x1,%a2		# plpaw2 points to end of word

	mov.l		%d2,%d3			# d3 = update[7:0]
	lsr.w		&0x8,%d2		# d2 = update[15:8]

# mask interrupt levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# load new sfc
	movc		%d0,%dfc		# load new dfc

# pre-load the operand ATC. no page faults should occur here because
# _real_lock_page() should have taken care of this.
	plpaw		(%a1)			# load atc for ADDR
	plpaw		(%a2)			# load atc for ADDR+1

# push the operand lines from the cache if they exist.
	cpushl		%dc,(%a1)		# push dirty data
	cpushl		%dc,(%a2)		# push dirty data

# load the BUSCR values.
	mov.l		&0x80000000,%a1		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a2		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a3		# buscr unlock value

# pre-load the instruction cache for the following algorithm.
# this will minimize the number of cycles that LOCK* will be asserted.
	bra.b		CASW_ENTER		# start pre-loading icache

#
# D0 = dst operand <-
# D1 = update[15:8] operand
# D2 = update[7:0]  operand
# D3 = xxxxxxxx
# D4 = compare[15:0] operand
# D5 = xxxxxxxx
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR
# A1 = bus LOCK*  value
# A2 = bus LOCKE* value
# A3 = bus unlock value
# A4 = xxxxxxxx
# A5 = xxxxxxxx
#
	align		0x10
CASW_START:
	movc		%a1,%buscr		# assert LOCK*
	movs.w		(%a0),%d0		# fetch Dest[15:0]
	cmp.w	 	%d0,%d4			# Dest - Compare
	bne.b		CASW_NOUPDATE
	bra.b 		CASW_UPDATE
CASW_ENTER:
	bra.b		~+16

CASW_UPDATE:
	movs.b		%d2,(%a0)+		# Update[15:8] -> DEST
	movc		%a2,%buscr		# assert LOCKE*
	movs.b		%d3,(%a0)		# Update[7:0] -> DEST+0x1
	bra.b		CASW_UPDATE2
	bra.b		~+16

CASW_UPDATE2:
	movc		%a3,%buscr		# unlock the bus
	bra.b		casw_update_done
	nop
	nop
	nop
	nop
	bra.b		~+16

CASW_NOUPDATE:
	ror.l		&0x8,%d0		# get Dest[15:8]
	movs.b		%d0,(%a0)+		# Dest[15:8] -> DEST
	movc		%a2,%buscr		# assert LOCKE*
	rol.l		&0x8,%d0		# get Dest[7:0]
	bra.b 		CASW_NOUPDATE2
	bra.b		~+16

CASW_NOUPDATE2:
	movs.b		%d0,(%a0)		# Dest[7:0] -> DEST+0x1
	movc		%a3,%buscr		# unlock the bus
	bra.b		casw_noupdate_done
	nop
	nop
	bra.b		~+16

CASW_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CASW_START

#################################################################
# THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	#
# CALLING _isp_cas_finish().					#
#								#
# D0 = destination[15:0] operand				#
# D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	#
# D2 = xxxxxxxx							#
# D3 = xxxxxxxx							#
# D4 = compare[15:0] operand					#
# D5 = xxxxxxxx							#
# D6 = xxxxxxxx							#
# D7 = xxxxxxxx							#
# A0 = xxxxxxxx							#
# A1 = xxxxxxxx							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

casw_noupdate_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	sf		%d1			# indicate no update was done
	bra.l		_isp_cas_finish

casw_update_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	st		%d1			# indicate update was done
	bra.l		_isp_cas_finish

################

# there are two possible mis-aligned cases for longword cas. they
# are separated because the final write which asserts LOCKE* must
# be an aligned write.
casl:
	mov.l		%a0,%a1			# make copy for plpaw1
	mov.l		%a0,%a2			# make copy for plpaw2
	addq.l		&0x3,%a2		# plpaw2 points to end of longword

	mov.l		%a0,%d1			# byte or word misaligned?
	btst		&0x0,%d1
	bne.w		casl2			# byte misaligned

	mov.l		%d2,%d3			# d3 = update[15:0]
	swap		%d2			# d2 = update[31:16]

# mask interrupts levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# load new sfc
	movc		%d0,%dfc		# load new dfc

# pre-load the operand ATC. no page faults should occur here because
# _real_lock_page() should have taken care of this.
	plpaw		(%a1)			# load atc for ADDR
	plpaw		(%a2)			# load atc for ADDR+3

# push the operand lines from the cache if they exist.
	cpushl		%dc,(%a1)		# push dirty data
	cpushl		%dc,(%a2)		# push dirty data

# load the BUSCR values.
	mov.l		&0x80000000,%a1		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a2		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a3		# buscr unlock value

	bra.b		CASL_ENTER		# start pre-loading icache

#
# D0 = dst operand <-
# D1 = xxxxxxxx
# D2 = update[31:16] operand
# D3 = update[15:0]  operand
# D4 = compare[31:0] operand
# D5 = xxxxxxxx
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR
# A1 = bus LOCK*  value
# A2 = bus LOCKE* value
# A3 = bus unlock value
# A4 = xxxxxxxx
# A5 = xxxxxxxx
#
	align		0x10
CASL_START:
	movc		%a1,%buscr		# assert LOCK*
	movs.l		(%a0),%d0		# fetch Dest[31:0]
	cmp.l	 	%d0,%d4			# Dest - Compare
	bne.b		CASL_NOUPDATE
	bra.b 		CASL_UPDATE
CASL_ENTER:
	bra.b		~+16

CASL_UPDATE:
	movs.w		%d2,(%a0)+		# Update[31:16] -> DEST
	movc		%a2,%buscr		# assert LOCKE*
	movs.w		%d3,(%a0)		# Update[15:0] -> DEST+0x2
	bra.b		CASL_UPDATE2
	bra.b		~+16

CASL_UPDATE2:
	movc		%a3,%buscr		# unlock the bus
	bra.b		casl_update_done
	nop
	nop
	nop
	nop
	bra.b		~+16

CASL_NOUPDATE:
	swap		%d0			# get Dest[31:16]
	movs.w		%d0,(%a0)+		# Dest[31:16] -> DEST
	swap		%d0			# get Dest[15:0]
	movc		%a2,%buscr		# assert LOCKE*
	bra.b 		CASL_NOUPDATE2
	bra.b		~+16

CASL_NOUPDATE2:
	movs.w		%d0,(%a0)		# Dest[15:0] -> DEST+0x2
	movc		%a3,%buscr		# unlock the bus
	bra.b		casl_noupdate_done
	nop
	nop
	bra.b		~+16

CASL_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CASL_START

#################################################################
# THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	#
# CALLING _isp_cas_finish().					#
#								#
# D0 = destination[31:0] operand				#
# D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	#
# D2 = xxxxxxxx							#
# D3 = xxxxxxxx							#
# D4 = compare[31:0] operand					#
# D5 = xxxxxxxx							#
# D6 = xxxxxxxx							#
# D7 = xxxxxxxx							#
# A0 = xxxxxxxx							#
# A1 = xxxxxxxx							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

casl_noupdate_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	sf		%d1			# indicate no update was done
	bra.l		_isp_cas_finish

casl_update_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupts mask level.
	mov.w		%d7,%sr			# restore old SR

	st		%d1			# indicate update was done
	bra.l		_isp_cas_finish

#######################################
casl2:
	mov.l		%d2,%d5			# d5 = Update[7:0]
	lsr.l		&0x8,%d2
	mov.l		%d2,%d3			# d3 = Update[23:8]
	swap		%d2			# d2 = Update[31:24]

# mask interrupts levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# load new sfc
	movc		%d0,%dfc		# load new dfc

# pre-load the operand ATC. no page faults should occur here because
# _real_lock_page() should have taken care of this already.
	plpaw		(%a1)			# load atc for ADDR
	plpaw		(%a2)			# load atc for ADDR+3

# puch the operand lines from the cache if they exist.
	cpushl		%dc,(%a1)		# push dirty data
	cpushl		%dc,(%a2)		# push dirty data

# load the BUSCR values.
	mov.l		&0x80000000,%a1		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a2		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a3		# buscr unlock value

# pre-load the instruction cache for the following algorithm. 
# this will minimize the number of cycles that LOCK* will be asserted.
	bra.b		CASL2_ENTER		# start pre-loading icache

#
# D0 = dst operand <-
# D1 = xxxxxxxx
# D2 = update[31:24] operand
# D3 = update[23:8]  operand
# D4 = compare[31:0] operand
# D5 = update[7:0]  operand
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR
# A1 = bus LOCK*  value
# A2 = bus LOCKE* value
# A3 = bus unlock value
# A4 = xxxxxxxx
# A5 = xxxxxxxx
#
	align		0x10
CASL2_START:
	movc		%a1,%buscr		# assert LOCK*
	movs.l		(%a0),%d0		# fetch Dest[31:0]
	cmp.l	 	%d0,%d4			# Dest - Compare
	bne.b		CASL2_NOUPDATE
	bra.b 		CASL2_UPDATE
CASL2_ENTER:
	bra.b		~+16

CASL2_UPDATE:
	movs.b		%d2,(%a0)+		# Update[31:24] -> DEST
	movs.w		%d3,(%a0)+		# Update[23:8] -> DEST+0x1
	movc		%a2,%buscr		# assert LOCKE*
	bra.b		CASL2_UPDATE2
	bra.b		~+16

CASL2_UPDATE2:
	movs.b		%d5,(%a0)		# Update[7:0] -> DEST+0x3
	movc		%a3,%buscr		# unlock the bus
	bra.w		casl_update_done
	nop
	bra.b		~+16

CASL2_NOUPDATE:
	rol.l		&0x8,%d0		# get Dest[31:24]
	movs.b		%d0,(%a0)+		# Dest[31:24] -> DEST
	swap		%d0			# get Dest[23:8]
	movs.w		%d0,(%a0)+		# Dest[23:8] -> DEST+0x1
	bra.b 		CASL2_NOUPDATE2
	bra.b		~+16

CASL2_NOUPDATE2:
	rol.l		&0x8,%d0		# get Dest[7:0]
	movc		%a2,%buscr		# assert LOCKE*
	movs.b		%d0,(%a0)		# Dest[7:0] -> DEST+0x3
	bra.b 		CASL2_NOUPDATE3
	nop
	bra.b		~+16

CASL2_NOUPDATE3:
	movc		%a3,%buscr		# unlock the bus
	bra.w		casl_noupdate_done
	nop
	nop
	nop
	bra.b		~+16

CASL2_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CASL2_START

####
####
# end label used by _isp_cas_inrange()
	global		_CASHI
_CASHI:
@


1.0.1.1
log
@Changed to ISO latin-1
@
text
@d1 4273
a4273 4283

#
# ireal.s:
#	This file is appended to the top of the 060ISP package
# and contains the entry points into the package. The user, in
# effect, branches to one of the branch table entries located
# after _060ISP_TABLE.
#	Also, subroutine stubs exist in this file (_isp_done for
# example) that are referenced by the ISP package itself in order
# to call a given routine. The stub routine actually performs the
# callout. The ISP code does a "bsr" to the stub routine. This
# extra layer of hierarchy adds a slight performance penalty but
# it makes the ISP code easier to read and more mainatinable.
#
# $Id: isp.asm 1.0.1.0 1996/02/19 22:53:28 schlote Exp schlote $
#
# $Log: isp.asm $
;; Revision 1.0.1.0  1996/02/19  22:53:28  schlote
;; Changed to ISO latin-1
;;
;; Revision 1.0  1996/02/11  19:54:40  motorola
;; Initial revision
;;
#

set	_off_chk,	0x00
set	_off_divbyzero,	0x04
set	_off_trace,	0x08
set	_off_access,	0x0c
set	_off_done,	0x10

set	_off_cas,	0x14
set	_off_cas2,	0x18
set	_off_lock,	0x1c
set	_off_unlock,	0x20

set	_off_imr,	0x40
set	_off_dmr,	0x44
set	_off_dmw,	0x48
set	_off_irw,	0x4c
set	_off_irl,	0x50
set	_off_drb,	0x54
set	_off_drw,	0x58
set	_off_drl,	0x5c
set	_off_dwb,	0x60
set	_off_dww,	0x64
set	_off_dwl,	0x68

_060ISP_TABLE:

# Here's the table of ENTRY POINTS for those linking the package.
	bra.l		_isp_unimp
	short		0x0000

	bra.l		_isp_cas
	short		0x0000

	bra.l		_isp_cas2
	short		0x0000

	bra.l		_isp_cas_finish
	short		0x0000

	bra.l		_isp_cas2_finish
	short		0x0000

	bra.l		_isp_cas_inrange
	short		0x0000

	bra.l		_isp_cas_terminate
	short		0x0000

	bra.l		_isp_cas_restart
	short		0x0000

	space		64

#############################################################

	global		_real_chk
_real_chk:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_chk,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_divbyzero
_real_divbyzero:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_divbyzero,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_trace
_real_trace:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_trace,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_access
_real_access:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_access,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_isp_done
_isp_done:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_done,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

#######################################

	global		_real_cas
_real_cas:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_cas,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_cas2
_real_cas2:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_cas2,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_lock_page
_real_lock_page:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_lock,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_real_unlock_page
_real_unlock_page:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_unlock,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

#######################################

	global		_imem_read
_imem_read:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_imr,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_read
_dmem_read:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dmr,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_write
_dmem_write:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dmw,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_imem_read_word
_imem_read_word:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_irw,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_imem_read_long
_imem_read_long:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_irl,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_read_byte
_dmem_read_byte:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_drb,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_read_word
_dmem_read_word:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_drw,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_read_long
_dmem_read_long:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_drl,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_write_byte
_dmem_write_byte:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dwb,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_write_word
_dmem_write_word:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dww,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

	global		_dmem_write_long
_dmem_write_long:
	mov.l		%d0,-(%sp)
	mov.l		(_060ISP_TABLE-0x80+_off_dwl,%pc),%d0
	pea.l		(_060ISP_TABLE-0x80,%pc,%d0)
	mov.l		0x4(%sp),%d0
	rtd		&0x4

#
# This file contains a set of define statements for constants
# in oreder to promote readability within the core code itself.
#

set LOCAL_SIZE,		96			# stack frame size(bytes)
set LV,			-LOCAL_SIZE		# stack offset

set EXC_ISR,		0x4			# stack status register
set EXC_IPC,		0x6			# stack pc
set EXC_IVOFF,		0xa			# stacked vector offset

set EXC_AREGS,		LV+64			# offset of all address regs
set EXC_DREGS,		LV+32			# offset of all data regs

set EXC_A7,		EXC_AREGS+(7*4)		# offset of a7
set EXC_A6,		EXC_AREGS+(6*4)		# offset of a6
set EXC_A5,		EXC_AREGS+(5*4)		# offset of a5
set EXC_A4,		EXC_AREGS+(4*4)		# offset of a4
set EXC_A3,		EXC_AREGS+(3*4)		# offset of a3
set EXC_A2,		EXC_AREGS+(2*4)		# offset of a2
set EXC_A1,		EXC_AREGS+(1*4)		# offset of a1
set EXC_A0,		EXC_AREGS+(0*4)		# offset of a0
set EXC_D7,		EXC_DREGS+(7*4)		# offset of d7
set EXC_D6,		EXC_DREGS+(6*4)		# offset of d6
set EXC_D5,		EXC_DREGS+(5*4)		# offset of d5
set EXC_D4,		EXC_DREGS+(4*4)		# offset of d4
set EXC_D3,		EXC_DREGS+(3*4)		# offset of d3
set EXC_D2,		EXC_DREGS+(2*4)		# offset of d2
set EXC_D1,		EXC_DREGS+(1*4)		# offset of d1
set EXC_D0,		EXC_DREGS+(0*4)		# offset of d0

set EXC_TEMP,		LV+16			# offset of temp stack space

set EXC_SAVVAL,		LV+12			# offset of old areg value
set EXC_SAVREG,		LV+11			# offset of old areg index

set SPCOND_FLG,		LV+10			# offset of spc condition flg

set EXC_CC,		LV+8			# offset of cc register
set EXC_EXTWPTR,	LV+4			# offset of current PC
set EXC_EXTWORD,	LV+2			# offset of current ext opword
set EXC_OPWORD,		LV+0			# offset of current opword

###########################
# SPecial CONDition FLaGs #
###########################
set mia7_flg,		0x04			# (a7)+ flag
set mda7_flg,		0x08			# -(a7) flag
set ichk_flg,		0x10			# chk exception flag
set idbyz_flg,		0x20			# divbyzero flag
set restore_flg,	0x40			# restore -(an)+ flag
set immed_flg,		0x80			# immediate data flag

set mia7_bit,		0x2			# (a7)+ bit
set mda7_bit,		0x3			# -(a7) bit
set ichk_bit,		0x4			# chk exception bit
set idbyz_bit,		0x5			# divbyzero bit
set restore_bit,	0x6			# restore -(a7)+ bit
set immed_bit,		0x7			# immediate data bit

#########
# Misc. #
#########
set BYTE,		1			# len(byte) == 1 byte
set WORD, 		2			# len(word) == 2 bytes
set LONG, 		4			# len(longword) == 4 bytes

#########################################################################
# XDEF ****************************************************************	#
#	_isp_unimp(): 060ISP entry point for Unimplemented Instruction	#
#									#
#	This handler should be the first code executed upon taking the 	#
# 	"Unimplemented Integer Instruction" exception in an operating	#
#	system.								#
#									#
# XREF ****************************************************************	#
#	_imem_read_{word,long}() - read instruction word/longword	#
#	_mul64() - emulate 64-bit multiply				#
# 	_div64() - emulate 64-bit divide				#
#	_moveperipheral() - emulate "movep"				#
#	_compandset() - emulate misaligned "cas"			#
#	_compandset2() - emulate "cas2"					#
#	_chk2_cmp2() - emulate "cmp2" and "chk2"			#
#	_isp_done() - "callout" for normal final exit			#
#	_real_trace() - "callout" for Trace exception			#
#	_real_chk() - "callout" for Chk exception			#
#	_real_divbyzero() - "callout" for DZ exception			#
#	_real_access() - "callout" for access error exception		#
#									#
# INPUT ***************************************************************	#
#	- The system stack contains the Unimp Int Instr stack frame	#
# 									#
# OUTPUT **************************************************************	#
#	If Trace exception:						#
#	- The system stack changed to contain Trace exc stack frame	#
#	If Chk exception:						#
#	- The system stack changed to contain Chk exc stack frame	#
#	If DZ exception:						#
#	- The system stack changed to contain DZ exc stack frame	#
#	If access error exception:					#
#	- The system stack changed to contain access err exc stk frame	#
#	Else:								#
#	- Results saved as appropriate					#
#									#
# ALGORITHM ***********************************************************	#
#	This handler fetches the first instruction longword from	#
# memory and decodes it to determine which of the unimplemented		#
# integer instructions caused this exception. This handler then calls	#
# one of _mul64(), _div64(), _moveperipheral(), _compandset(), 		#
# _compandset2(), or _chk2_cmp2() as appropriate. 			#
#	Some of these instructions, by their nature, may produce other	#
# types of exceptions. "div" can produce a divide-by-zero exception,	#
# and "chk2" can cause a "Chk" exception. In both cases, the current	#
# exception stack frame must be converted to an exception stack frame	#
# of the correct exception type and an exit must be made through	#
# _real_divbyzero() or _real_chk() as appropriate. In addition, all	#
# instructions may be executing while Trace is enabled. If so, then	#
# a Trace exception stack frame must be created and an exit made 	#
# through _real_trace().						#
#	Meanwhile, if any read or write to memory using the		#
# _mem_{read,write}() "callout"s returns a failing value, then an	#
# access error frame must be created and an exit made through		#
# _real_access().							#
#	If none of these occur, then a normal exit is made through	#
# _isp_done().								#
#									#
#	This handler, upon entry, saves almost all user-visible 	#
# address and data registers to the stack. Although this may seem to	#
# cause excess memory traffic, it was found that due to having to	#
# access these register files for things like data retrieval and <ea>	#
# calculations, it was more efficient to have them on the stack where	#
# they could be accessed by indexing rather than to make subroutine 	#
# calls to retrieve a register of a particular index. 			#
#									#
#########################################################################

	global		_isp_unimp
_isp_unimp:
	link.w 		%a6,&-LOCAL_SIZE	# create room for stack frame

	movm.l		&0x3fff,EXC_DREGS(%a6)	# store d0-d7/a0-a5
	mov.l		(%a6),EXC_A6(%a6)	# store a6

	btst		&0x5,EXC_ISR(%a6)	# from s or u mode?
	bne.b		uieh_s			# supervisor mode
uieh_u:
	mov.l		%usp,%a0		# fetch user stack pointer
	mov.l		%a0,EXC_A7(%a6)		# store a7
	bra.b		uieh_cont
uieh_s:
	lea		0xc(%a6),%a0
	mov.l		%a0,EXC_A7(%a6)		# store corrected sp

###############################################################################

uieh_cont:
	clr.b		SPCOND_FLG(%a6)		# clear "special case" flag

	mov.w		EXC_ISR(%a6),EXC_CC(%a6) # store cc copy on stack
	mov.l		EXC_IPC(%a6),EXC_EXTWPTR(%a6) # store extwptr on stack

#
# fetch the opword and first extension word pointed to by the stacked pc
# and store them to the stack for now
#
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x4,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_long		# fetch opword & extword
	mov.l		%d0,EXC_OPWORD(%a6)	# store extword on stack

	
#########################################################################
# muls.l	0100 1100 00 |<ea>|	0*** 1100 0000 0*** 		#
# mulu.l	0100 1100 00 |<ea>|	0*** 0100 0000 0***		#
#									#
# divs.l	0100 1100 01 |<ea>|	0*** 1100 0000 0***		#
# divu.l	0100 1100 01 |<ea>|	0*** 0100 0000 0***		#
#									#
# movep.w m2r	0000 ***1 00 001***	| <displacement>  |		#
# movep.l m2r	0000 ***1 01 001***	| <displacement>  |		#
# movep.w r2m	0000 ***1 10 001***	| <displacement>  |		#
# movep.l r2m	0000 ***1 11 001***	| <displacement>  |		#
#									#
# cas.w		0000 1100 11 |<ea>|	0000 000* **00 0***		#
# cas.l		0000 1110 11 |<ea>|	0000 000* **00 0***		#
#									#
# cas2.w	0000 1100 11 111100	**** 000* **00 0***		#
#					**** 000* **00 0***		#
# cas2.l	0000 1110 11 111100	**** 000* **00 0***		#
#					**** 000* **00 0***		#
#									#
# chk2.b	0000 0000 11 |<ea>|	**** 1000 0000 0000		#
# chk2.w	0000 0010 11 |<ea>|	**** 1000 0000 0000		#
# chk2.l	0000 0100 11 |<ea>|	**** 1000 0000 0000		#
#									#
# cmp2.b	0000 0000 11 |<ea>|	**** 0000 0000 0000		#
# cmp2.w	0000 0010 11 |<ea>|	**** 0000 0000 0000		#
# cmp2.l	0000 0100 11 |<ea>|	**** 0000 0000 0000		#
#########################################################################

#
# using bit 14 of the operation word, separate into 2 groups:
# (group1) mul64, div64
# (group2) movep, chk2, cmp2, cas2, cas
#
	btst		&0x1e,%d0		# group1 or group2
	beq.b		uieh_group2		# go handle group2

#
# now, w/ group1, make mul64's decode the fastest since it will
# most likely be used the most.
#
uieh_group1:
	btst		&0x16,%d0		# test for div64
	bne.b		uieh_div64		# go handle div64

uieh_mul64:
# mul64() may use ()+ addressing and may, therefore, alter a7

	bsr.l		_mul64			# _mul64()

	btst		&0x5,EXC_ISR(%a6)	# supervisor mode?
	beq.w		uieh_done
	btst		&mia7_bit,SPCOND_FLG(%a6) # was a7 changed?
	beq.w		uieh_done		# no
	btst		&0x7,EXC_ISR(%a6)	# is trace enabled?
	bne.w		uieh_trace_a7		# yes
	bra.w		uieh_a7			# no

uieh_div64:
# div64() may use ()+ addressing and may, therefore, alter a7.
# div64() may take a divide by zero exception.

	bsr.l		_div64			# _div64()

# here, we sort out all of the special cases that may have happened.
	btst		&mia7_bit,SPCOND_FLG(%a6) # was a7 changed?
	bne.b		uieh_div64_a7		# yes
uieh_div64_dbyz:
	btst		&idbyz_bit,SPCOND_FLG(%a6) # did divide-by-zero occur?
	bne.w		uieh_divbyzero		# yes
	bra.w		uieh_done		# no
uieh_div64_a7:
	btst		&0x5,EXC_ISR(%a6)	# supervisor mode?
	beq.b		uieh_div64_dbyz		# no
# here, a7 has been incremented by 4 bytes in supervisor mode. we still
# may have the following 3 cases:
#	(i)	(a7)+
#	(ii)	(a7)+; trace
#	(iii)	(a7)+; divide-by-zero
#
	btst		&idbyz_bit,SPCOND_FLG(%a6) # did divide-by-zero occur?
	bne.w		uieh_divbyzero_a7	# yes
	tst.b		EXC_ISR(%a6)		# no; is trace enabled?
	bmi.w		uieh_trace_a7		# yes
	bra.w		uieh_a7			# no
	
#
# now, w/ group2, make movep's decode the fastest since it will
# most likely be used the most.
#
uieh_group2:
	btst		&0x18,%d0		# test for not movep
	beq.b		uieh_not_movep


	bsr.l		_moveperipheral		# _movep()
	bra.w		uieh_done

uieh_not_movep:
	btst		&0x1b,%d0		# test for chk2,cmp2
	beq.b		uieh_chk2cmp2		# go handle chk2,cmp2

	swap		%d0			# put opword in lo word
	cmpi.b	 	%d0,&0xfc		# test for cas2
	beq.b		uieh_cas2		# go handle cas2

uieh_cas:

	bsr.l		_compandset		# _cas()

# the cases of "cas Dc,Du,(a7)+" and "cas Dc,Du,-(a7)" used from supervisor
# mode are simply not considered valid and therefore are not handled.

	bra.w		uieh_done

uieh_cas2:

	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# read extension word

	tst.l		%d1			# ifetch error?
	bne.w		isp_iacc		# yes

	bsr.l		_compandset2		# _cas2()
	bra.w		uieh_done

uieh_chk2cmp2:
# chk2 may take a chk exception

	bsr.l		_chk2_cmp2		# _chk2_cmp2()

# here we check to see if a chk trap should be taken
	cmpi.b		SPCOND_FLG(%a6),&ichk_flg
	bne.w		uieh_done
	bra.b		uieh_chk_trap

###########################################################################

#
# the required emulation has been completed. now, clean up the necessary stack
# info and prepare for rte
#
uieh_done:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes

# if exception occurred in user mode, then we have to restore a7 in case it
# changed. we don't have to update a7  for supervisor mose because that case
# doesn't flow through here
	btst		&0x5,EXC_ISR(%a6)	# user or supervisor?
	bne.b		uieh_finish		# supervisor

	mov.l		EXC_A7(%a6),%a0		# fetch user stack pointer
	mov.l		%a0,%usp		# restore it

uieh_finish:
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	btst		&0x7,EXC_ISR(%a6)	# is trace mode on?
	bne.b		uieh_trace		# yes;go handle trace mode

	mov.l		EXC_EXTWPTR(%a6),EXC_IPC(%a6) # new pc on stack frame
	mov.l		EXC_A6(%a6),(%a6)	# prepare new a6 for unlink
	unlk		%a6			# unlink stack frame
	bra.l		_isp_done

#
# The instruction that was just emulated was also being traced. The trace 
# trap for this instruction will be lost unless we jump to the trace handler.
# So, here we create a Trace Exception format number two exception stack
# frame from the Unimplemented Integer Intruction Exception stack frame
# format number zero and jump to the user supplied hook "_real_trace()".
#
#		   UIEH FRAME		   TRACE FRAME
#		*****************	*****************
#		* 0x0 *  0x0f4	*	*    Current	*
#		*****************	*      PC	*
#		*    Current	*	*****************
#		*      PC 	*	* 0x2 *  0x024	*
#		*****************	*****************
#		*      SR	*	*     Next	*
#		*****************	*      PC	*
#	      ->*     Old   	*	*****************
#  from link -->*      A6	*	*      SR	*
#	        *****************	*****************
#	       /*      A7	*	*      New	* <-- for final unlink
#	      / *		*	*      A6	*
# link frame <  *****************	*****************
#	      \ ~		~	~		~
#	       \*****************	*****************
#
uieh_trace:
	mov.l		EXC_A6(%a6),-0x4(%a6)
	mov.w		EXC_ISR(%a6),0x0(%a6)
	mov.l		EXC_IPC(%a6),0x8(%a6)
	mov.l		EXC_EXTWPTR(%a6),0x2(%a6)
	mov.w		&0x2024,0x6(%a6)
	sub.l		&0x4,%a6
	unlk		%a6
	bra.l		_real_trace

#
#	   UIEH FRAME		    CHK FRAME
#	*****************	*****************
#	* 0x0 *  0x0f4	*	*    Current	*
#	*****************	*      PC	*
#	*    Current	*	*****************
#	*      PC	*	* 0x2 *  0x018	*
#	*****************	*****************
#	*      SR	*	*     Next	*
#	*****************	*      PC	*
#	    (4 words)		*****************
#				*      SR	*
#				*****************
#				    (6 words)
#
# the chk2 instruction should take a chk trap. so, here we must create a
# chk stack frame from an unimplemented integer instruction exception frame
# and jump to the user supplied entry point "_real_chk()".
#
uieh_chk_trap:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.w		EXC_ISR(%a6),(%a6)	# put new SR on stack
	mov.l		EXC_IPC(%a6),0x8(%a6)	# put "Current PC" on stack
	mov.l		EXC_EXTWPTR(%a6),0x2(%a6) # put "Next PC" on stack
	mov.w		&0x2018,0x6(%a6)	# put Vector Offset on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&LOCAL_SIZE,%sp		# clear stack frame

	bra.l		_real_chk

#
#	   UIEH FRAME		 DIVBYZERO FRAME
#	*****************	*****************
#	* 0x0 *  0x0f4	*	*    Current	*
#	*****************	*      PC	*
#	*    Current	*	*****************
#	*      PC	*	* 0x2 *  0x014	*
#	*****************	*****************
#	*      SR	*	*     Next	*
#	*****************	*      PC	*
#	    (4 words)		*****************
#				*      SR	*
#				*****************
#				    (6 words)
#
# the divide instruction should take an integer divide by zero trap. so, here 
# we must create a divbyzero stack frame from an unimplemented integer 
# instruction exception frame and jump to the user supplied entry point 
# "_real_divbyzero()".
#
uieh_divbyzero:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.w		EXC_ISR(%a6),(%a6)	# put new SR on stack
	mov.l		EXC_IPC(%a6),0x8(%a6)	# put "Current PC" on stack
	mov.l		EXC_EXTWPTR(%a6),0x2(%a6) # put "Next PC" on stack
	mov.w		&0x2014,0x6(%a6)	# put Vector Offset on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&LOCAL_SIZE,%sp		# clear stack frame

	bra.l		_real_divbyzero

#
#				 DIVBYZERO FRAME
#				*****************
#				*    Current	*
#	   UIEH FRAME		*      PC	*
#	*****************	*****************
#	* 0x0 *  0x0f4	*	* 0x2 * 0x014	*
#	*****************	*****************
#	*    Current	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#	    (4 words)		    (6 words)
#
# the divide instruction should take an integer divide by zero trap. so, here 
# we must create a divbyzero stack frame from an unimplemented integer 
# instruction exception frame and jump to the user supplied entry point 
# "_real_divbyzero()".
#
# However, we must also deal with the fact that (a7)+ was used from supervisor
# mode, thereby shifting the stack frame up 4 bytes.
#
uieh_divbyzero_a7:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.l		EXC_IPC(%a6),0xc(%a6)	# put "Current PC" on stack
	mov.w		&0x2014,0xa(%a6)	# put Vector Offset on stack
	mov.l		EXC_EXTWPTR(%a6),0x6(%a6) # put "Next PC" on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&4+LOCAL_SIZE,%sp	# clear stack frame

	bra.l		_real_divbyzero

#
#				   TRACE FRAME
#				*****************
#				*    Current	*
#	   UIEH FRAME		*      PC	*
#	*****************	*****************
#	* 0x0 *  0x0f4	*	* 0x2 * 0x024	*
#	*****************	*****************
#	*    Current	*	*     Next	*
#	*      PC	*	*      PC	*
#	*****************	*****************
#	*      SR	*	*      SR	*
#	*****************	*****************
#	    (4 words)		    (6 words)
#
# 
# The instruction that was just emulated was also being traced. The trace 
# trap for this instruction will be lost unless we jump to the trace handler.
# So, here we create a Trace Exception format number two exception stack
# frame from the Unimplemented Integer Intruction Exception stack frame
# format number zero and jump to the user supplied hook "_real_trace()".
#
# However, we must also deal with the fact that (a7)+ was used from supervisor
# mode, thereby shifting the stack frame up 4 bytes.
#
uieh_trace_a7:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.l		EXC_IPC(%a6),0xc(%a6)	# put "Current PC" on stack
	mov.w		&0x2024,0xa(%a6)	# put Vector Offset on stack
	mov.l		EXC_EXTWPTR(%a6),0x6(%a6) # put "Next PC" on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&4+LOCAL_SIZE,%sp	# clear stack frame

	bra.l		_real_trace

#
#				   UIEH FRAME	
#				*****************
#				* 0x0 * 0x0f4	*
#	   UIEH FRAME		*****************
#	*****************	*     Next	*
#	* 0x0 *  0x0f4	*	*      PC	*	
#	*****************	*****************
#	*    Current	*	*      SR	*
#	*      PC	*	*****************
#	*****************	    (4 words)
#	*      SR	*
#	*****************
#	    (4 words)
uieh_a7:
	mov.b		EXC_CC+1(%a6),EXC_ISR+1(%a6) # insert new ccodes
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5

	mov.w		&0x00f4,0xe(%a6)	# put Vector Offset on stack
	mov.l		EXC_EXTWPTR(%a6),0xa(%a6) # put "Next PC" on stack
	mov.w		EXC_ISR(%a6),0x8(%a6)	# put SR on stack

	mov.l		EXC_A6(%a6),%a6		# restore a6
	add.l		&8+LOCAL_SIZE,%sp	# clear stack frame
	bra.l		_isp_done

##########

# this is the exit point if a data read or write fails.
# a0 = failing address
# d0 = fslw
isp_dacc:
	mov.l		%a0,(%a6)		# save address	
	mov.l		%d0,-0x4(%a6)		# save partial fslw

	lea		-64(%a6),%sp
	movm.l		(%sp)+,&0x7fff 		# restore d0-d7/a0-a6

	mov.l		0xc(%sp),-(%sp)		# move voff,hi(pc)
	mov.l		0x4(%sp),0x10(%sp)	# store fslw
	mov.l		0xc(%sp),0x4(%sp)	# store sr,lo(pc)
	mov.l		0x8(%sp),0xc(%sp)	# store address
	mov.l		(%sp)+,0x4(%sp)		# store voff,hi(pc)
	mov.w		&0x4008,0x6(%sp)	# store new voff

	bra.b		isp_acc_exit

# this is the exit point if an instruction word read fails.
# FSLW:
#	misaligned = true
#	read = true
# 	size = word
# 	instruction = true
# 	software emulation error = true
isp_iacc:
	movm.l		EXC_DREGS(%a6),&0x3fff 	# restore d0-d7/a0-a5
	unlk		%a6			# unlink frame
	sub.w		&0x8,%sp		# make room for acc frame
	mov.l		0x8(%sp),(%sp)		# store sr,lo(pc)
	mov.w		0xc(%sp),0x4(%sp)	# store hi(pc)
	mov.w		&0x4008,0x6(%sp)	# store new voff
	mov.l		0x2(%sp),0x8(%sp)	# store address (=pc)
	mov.l		&0x09428001,0xc(%sp)	# store fslw

isp_acc_exit:
	btst		&0x5,(%sp)		# user or supervisor?
	beq.b		isp_acc_exit2		# user
	bset		&0x2,0xd(%sp)		# set supervisor TM bit
isp_acc_exit2:
	bra.l		_real_access		

# if the addressing mode was (an)+ or -(an), the address register must
# be restored to it's pre-exception value before entering _real_access.
isp_restore:
	cmpi.b		SPCOND_FLG(%a6),&restore_flg # do we need a restore?
	bne.b		isp_restore_done	# no
	clr.l		%d0
	mov.b		EXC_SAVREG(%a6),%d0	# regno to restore
	mov.l		EXC_SAVVAL(%a6),(EXC_AREGS,%a6,%d0.l*4) # restore value
isp_restore_done:
	rts

#########################################################################
# XDEF ****************************************************************	#
#	_calc_ea(): routine to calculate effective address		#
#									#
# XREF ****************************************************************	#
# 	_imem_read_word() - read instruction word			#
# 	_imem_read_long() - read instruction longword			#
# 	_dmem_read_long() - read data longword (for memory indirect)	#
# 	isp_iacc() - handle instruction access error exception		#
#	isp_dacc() - handle data access error exception			#
#									#
# INPUT ***************************************************************	#
# 	d0 = number of bytes related to effective address (w,l)		#
#									#
# OUTPUT **************************************************************	#
#	If exiting through isp_dacc...					#
#		a0 = failing address					#
#		d0 = FSLW						#
#	elsif exiting though isp_iacc...				#
#		none							#
#	else								#
#		a0 = effective address					#
#									#
# ALGORITHM ***********************************************************	#
# 	The effective address type is decoded from the opword residing	#
# on the stack. A jump table is used to vector to a routine for the 	#
# appropriate mode. Since none of the emulated integer instructions	#
# uses byte-sized operands, only handle word and long operations.	#
#									#
# 	Dn,An	- shouldn't enter here					#
#	(An)	- fetch An value from stack				#
# 	-(An)	- fetch An value from stack; return decr value;		#
#		  place decr value on stack; store old value in case of	#
#		  future access error; if -(a7), set mda7_flg in 	#
#		  SPCOND_FLG						#
#	(An)+	- fetch An value from stack; return value;		#
#		  place incr value on stack; store old value in case of	#
#		  future access error; if (a7)+, set mia7_flg in	#
#		  SPCOND_FLG						#
#	(d16,An) - fetch An value from stack; read d16 using 		#
#		  _imem_read_word(); fetch may fail -> branch to	#
#		  isp_iacc()						#
#	(xxx).w,(xxx).l - use _imem_read_{word,long}() to fetch		#
#		  address; fetch may fail				#
#	#<data> - return address of immediate value; set immed_flg	#
#		  in SPCOND_FLG						#
#	(d16,PC) - fetch stacked PC value; read d16 using		#
#		  _imem_read_word(); fetch may fail -> branch to	#
#		  isp_iacc()						#
#	everything else - read needed displacements as appropriate w/	#
#		  _imem_read_{word,long}(); read may fail; if memory	#
# 		  indirect, read indirect address using			#
#		  _dmem_read_long() which may also fail			#
#									#
#########################################################################

	global		_calc_ea
_calc_ea:
	mov.l		%d0,%a0			# move # bytes to a0

# MODE and REG are taken from the EXC_OPWORD.
	mov.w		EXC_OPWORD(%a6),%d0	# fetch opcode word
	mov.w		%d0,%d1			# make a copy

	andi.w		&0x3f,%d0		# extract mode field
	andi.l		&0x7,%d1		# extract reg  field

# jump to the corresponding function for each {MODE,REG} pair.
	mov.w		(tbl_ea_mode.b,%pc,%d0.w*2), %d0 # fetch jmp distance
	jmp		(tbl_ea_mode.b,%pc,%d0.w*1) # jmp to correct ea mode

	swbeg		&64
tbl_ea_mode:
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode

	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode
	short		tbl_ea_mode	-	tbl_ea_mode

	short		addr_ind_a0	- 	tbl_ea_mode
	short		addr_ind_a1	- 	tbl_ea_mode
	short		addr_ind_a2	- 	tbl_ea_mode
	short		addr_ind_a3 	- 	tbl_ea_mode
	short		addr_ind_a4 	- 	tbl_ea_mode
	short		addr_ind_a5 	- 	tbl_ea_mode
	short		addr_ind_a6 	- 	tbl_ea_mode
	short		addr_ind_a7 	- 	tbl_ea_mode

	short		addr_ind_p_a0	- 	tbl_ea_mode
	short		addr_ind_p_a1 	- 	tbl_ea_mode
	short		addr_ind_p_a2 	- 	tbl_ea_mode
	short		addr_ind_p_a3 	- 	tbl_ea_mode
	short		addr_ind_p_a4 	- 	tbl_ea_mode
	short		addr_ind_p_a5 	- 	tbl_ea_mode
	short		addr_ind_p_a6 	- 	tbl_ea_mode
	short		addr_ind_p_a7 	- 	tbl_ea_mode

	short		addr_ind_m_a0 		- 	tbl_ea_mode
	short		addr_ind_m_a1 		- 	tbl_ea_mode
	short		addr_ind_m_a2 		- 	tbl_ea_mode
	short		addr_ind_m_a3 		- 	tbl_ea_mode
	short		addr_ind_m_a4 		- 	tbl_ea_mode
	short		addr_ind_m_a5 		- 	tbl_ea_mode
	short		addr_ind_m_a6 		- 	tbl_ea_mode
	short		addr_ind_m_a7 		- 	tbl_ea_mode

	short		addr_ind_disp_a0	- 	tbl_ea_mode
	short		addr_ind_disp_a1 	- 	tbl_ea_mode
	short		addr_ind_disp_a2 	- 	tbl_ea_mode
	short		addr_ind_disp_a3 	- 	tbl_ea_mode
	short		addr_ind_disp_a4 	- 	tbl_ea_mode
	short		addr_ind_disp_a5 	- 	tbl_ea_mode
	short		addr_ind_disp_a6 	- 	tbl_ea_mode
	short		addr_ind_disp_a7	-	tbl_ea_mode

	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode
	short		_addr_ind_ext 		- 	tbl_ea_mode

	short		abs_short		- 	tbl_ea_mode
	short		abs_long		- 	tbl_ea_mode
	short		pc_ind			- 	tbl_ea_mode
	short		pc_ind_ext		- 	tbl_ea_mode
	short		immediate		- 	tbl_ea_mode
	short		tbl_ea_mode		- 	tbl_ea_mode
	short		tbl_ea_mode		- 	tbl_ea_mode
	short		tbl_ea_mode		- 	tbl_ea_mode

###################################
# Address register indirect: (An) #
###################################
addr_ind_a0:
	mov.l		EXC_A0(%a6),%a0		# Get current a0
	rts

addr_ind_a1:
	mov.l		EXC_A1(%a6),%a0		# Get current a1
	rts

addr_ind_a2:
	mov.l		EXC_A2(%a6),%a0		# Get current a2
	rts

addr_ind_a3:
	mov.l		EXC_A3(%a6),%a0		# Get current a3
	rts

addr_ind_a4:
	mov.l		EXC_A4(%a6),%a0		# Get current a4
	rts

addr_ind_a5:
	mov.l		EXC_A5(%a6),%a0		# Get current a5
	rts

addr_ind_a6:
	mov.l		EXC_A6(%a6),%a0		# Get current a6
	rts

addr_ind_a7:
	mov.l		EXC_A7(%a6),%a0		# Get current a7
	rts

#####################################################
# Address register indirect w/ postincrement: (An)+ #
#####################################################
addr_ind_p_a0:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A0(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A0(%a6)		# save incremented value
	
	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x0,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a1:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A1(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A1(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x1,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a2:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A2(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A2(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x2,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a3:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A3(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A3(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x3,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a4:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A4(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A4(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x4,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a5:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A5(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A5(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x5,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a6:
	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A6(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A6(%a6)		# save incremented value

	mov.l		%a0,EXC_SAVVAL(%a6)	# save in case of access error
	mov.b		&0x6,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_p_a7:
	mov.b		&mia7_flg,SPCOND_FLG(%a6) # set "special case" flag

	mov.l		%a0,%d0			# copy no. bytes
	mov.l		EXC_A7(%a6),%a0		# load current value
	add.l		%a0,%d0			# increment
	mov.l		%d0,EXC_A7(%a6)		# save incremented value
	rts

####################################################
# Address register indirect w/ predecrement: -(An) #
####################################################
addr_ind_m_a0:
	mov.l		EXC_A0(%a6),%d0		# Get current a0
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A0(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x0,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a1:
	mov.l		EXC_A1(%a6),%d0		# Get current a1
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A1(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x1,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a2:
	mov.l		EXC_A2(%a6),%d0		# Get current a2
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A2(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x2,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a3:
	mov.l		EXC_A3(%a6),%d0		# Get current a3
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A3(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x3,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a4:
	mov.l		EXC_A4(%a6),%d0		# Get current a4
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A4(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x4,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a5:
	mov.l		EXC_A5(%a6),%d0		# Get current a5
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A5(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x5,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a6:
	mov.l		EXC_A6(%a6),%d0		# Get current a6
	mov.l		%d0,EXC_SAVVAL(%a6)	# save in case of access error
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A6(%a6)		# Save decr value
	mov.l		%d0,%a0

	mov.b		&0x6,EXC_SAVREG(%a6)	# save regno, too
	mov.b		&restore_flg,SPCOND_FLG(%a6) # set flag
	rts

addr_ind_m_a7:
	mov.b		&mda7_flg,SPCOND_FLG(%a6) # set "special case" flag

	mov.l		EXC_A7(%a6),%d0		# Get current a7
	sub.l		%a0,%d0			# Decrement
	mov.l		%d0,EXC_A7(%a6)		# Save decr value
	mov.l		%d0,%a0
	rts

########################################################
# Address register indirect w/ displacement: (d16, An) #
########################################################
addr_ind_disp_a0:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A0(%a6),%a0		# a0 + d16
	rts

addr_ind_disp_a1:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A1(%a6),%a0		# a1 + d16
	rts

addr_ind_disp_a2:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A2(%a6),%a0		# a2 + d16
	rts

addr_ind_disp_a3:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A3(%a6),%a0		# a3 + d16
	rts

addr_ind_disp_a4:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A4(%a6),%a0		# a4 + d16
	rts

addr_ind_disp_a5:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A5(%a6),%a0		# a5 + d16
	rts

addr_ind_disp_a6:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A6(%a6),%a0		# a6 + d16
	rts

addr_ind_disp_a7:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement
	add.l		EXC_A7(%a6),%a0		# a7 + d16
	rts

########################################################################
# Address register indirect w/ index(8-bit displacement): (dn, An, Xn) #
#    "       "         "    w/   "  (base displacement): (bd, An, Xn)  #
# Memory indirect postindexed: ([bd, An], Xn, od)		       #
# Memory indirect preindexed: ([bd, An, Xn], od)		       #
########################################################################
_addr_ind_ext:
	mov.l		%d1,-(%sp)

	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# fetch extword in d0

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		(%sp)+,%d1

	mov.l		(EXC_AREGS,%a6,%d1.w*4),%a0 # put base in a0

	btst		&0x8,%d0
	beq.b		addr_ind_index_8bit	# for ext word or not?

	movm.l		&0x3c00,-(%sp)		# save d2-d5

	mov.l		%d0,%d5			# put extword in d5
	mov.l		%a0,%d3			# put base in d3

	bra.l		calc_mem_ind		# calc memory indirect
	
addr_ind_index_8bit:
	mov.l		%d2,-(%sp)		# save old d2

	mov.l		%d0,%d1
	rol.w		&0x4,%d1
	andi.w		&0xf,%d1		# extract index regno

	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d1 # fetch index reg value

	btst		&0xb,%d0		# is it word or long?
	bne.b		aii8_long
	ext.l		%d1			# sign extend word index
aii8_long:
	mov.l		%d0,%d2
	rol.w		&0x7,%d2
	andi.l		&0x3,%d2		# extract scale value

	lsl.l		%d2,%d1			# shift index by scale

	extb.l		%d0			# sign extend displacement
	add.l		%d1,%d0			# index + disp
	add.l		%d0,%a0			# An + (index + disp)

	mov.l		(%sp)+,%d2		# restore old d2
	rts

######################
# Immediate: #<data> #
#########################################################################
# word, long: <ea> of the data is the current extension word		#
# 	pointer value. new extension word pointer is simply the old	#
# 	plus the number of bytes in the data type(2 or 4).		#
#########################################################################
immediate:
	mov.b		&immed_flg,SPCOND_FLG(%a6) # set immediate flag

	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch extension word ptr
	rts

###########################
# Absolute short: (XXX).W #
###########################
abs_short:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# fetch short address

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# return <ea> in a0
	rts

##########################
# Absolute long: (XXX).L #
##########################
abs_long:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x4,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_long		# fetch long address

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		%d0,%a0			# return <ea> in a0
	rts

#######################################################
# Program counter indirect w/ displacement: (d16, PC) #
#######################################################
pc_ind:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# fetch word displacement

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.w		%d0,%a0			# sign extend displacement

	add.l		EXC_EXTWPTR(%a6),%a0	# pc + d16

# _imem_read_word() increased the extwptr by 2. need to adjust here.
	subq.l		&0x2,%a0		# adjust <ea>

	rts

##########################################################
# PC indirect w/ index(8-bit displacement): (d8, PC, An) #
# "     "     w/   "  (base displacement): (bd, PC, An)  #
# PC memory indirect postindexed: ([bd, PC], Xn, od)     #
# PC memory indirect preindexed: ([bd, PC, Xn], od)      #
##########################################################
pc_ind_ext:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word		# fetch ext word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		EXC_EXTWPTR(%a6),%a0	# put base in a0
	subq.l		&0x2,%a0		# adjust base

	btst		&0x8,%d0		# is disp only 8 bits?
	beq.b		pc_ind_index_8bit	# yes

# the indexed addressing mode uses a base displacement of size
# word or long
	movm.l		&0x3c00,-(%sp)		# save d2-d5

	mov.l		%d0,%d5			# put extword in d5
	mov.l		%a0,%d3			# put base in d3

	bra.l		calc_mem_ind		# calc memory indirect
	
pc_ind_index_8bit:
 	mov.l		%d2,-(%sp)		# create a temp register

	mov.l		%d0,%d1			# make extword copy
	rol.w		&0x4,%d1		# rotate reg num into place
	andi.w		&0xf,%d1		# extract register number

	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d1 # fetch index reg value

	btst		&0xb,%d0		# is index word or long?
	bne.b		pii8_long		# long
	ext.l		%d1			# sign extend word index
pii8_long:
	mov.l		%d0,%d2			# make extword copy
	rol.w		&0x7,%d2		# rotate scale value into place
	andi.l		&0x3,%d2		# extract scale value

	lsl.l		%d2,%d1			# shift index by scale

	extb.l		%d0			# sign extend displacement
	add.l		%d1,%d0			# index + disp
	add.l		%d0,%a0			# An + (index + disp)

	mov.l		(%sp)+,%d2		# restore temp register

	rts

# a5 = exc_extwptr	(global to uaeh)
# a4 = exc_opword	(global to uaeh)
# a3 = exc_dregs	(global to uaeh)

# d2 = index		(internal "     "    )
# d3 = base		(internal "     "    )
# d4 = od		(internal "     "    )
# d5 = extword		(internal "     "    )
calc_mem_ind:
	btst		&0x6,%d5		# is the index suppressed?
	beq.b		calc_index
	clr.l		%d2			# yes, so index = 0
	bra.b		base_supp_ck
calc_index:
	bfextu		%d5{&16:&4},%d2
	mov.l		(EXC_DREGS,%a6,%d2.w*4),%d2
	btst		&0xb,%d5		# is index word or long?
	bne.b		no_ext
	ext.l		%d2
no_ext:
	bfextu		%d5{&21:&2},%d0
	lsl.l		%d0,%d2
base_supp_ck:
	btst		&0x7,%d5		# is the bd suppressed?
	beq.b		no_base_sup
	clr.l		%d3
no_base_sup:
	bfextu		%d5{&26:&2},%d0	# get bd size
#	beq.l		_error			# if (size == 0) it's reserved
	cmpi.b	 	%d0,&2
	blt.b		no_bd
	beq.b		get_word_bd

	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x4,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_long
	
	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	bra.b		chk_ind
get_word_bd:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	ext.l		%d0			# sign extend bd
	
chk_ind:
	add.l		%d0,%d3			# base += bd
no_bd:
	bfextu		%d5{&30:&2},%d0		# is od suppressed?
	beq.w		aii_bd
	cmpi.b	 	%d0,&0x2
	blt.b		null_od
	beq.b		word_od
	
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x4,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_long

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	bra.b 		add_them

word_od:
	mov.l		EXC_EXTWPTR(%a6),%a0	# fetch instruction addr
	addq.l		&0x2,EXC_EXTWPTR(%a6)	# incr instruction ptr
	bsr.l		_imem_read_word

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	ext.l		%d0			# sign extend od
	bra.b		add_them

null_od:
	clr.l		%d0
add_them:
	mov.l		%d0,%d4
	btst		&0x2,%d5		# pre or post indexing?
	beq.b		pre_indexed

	mov.l		%d3,%a0
	bsr.l		_dmem_read_long

	tst.l		%d1			# dfetch error?
	bne.b		calc_ea_err		# yes

	add.l		%d2,%d0			# <ea> += index
	add.l		%d4,%d0			# <ea> += od
	bra.b		done_ea

pre_indexed:
	add.l		%d2,%d3			# preindexing
	mov.l		%d3,%a0
	bsr.l		_dmem_read_long

	tst.l		%d1			# ifetch error?
	bne.b		calc_ea_err		# yes

	add.l		%d4,%d0			# ea += od
	bra.b		done_ea

aii_bd:
	add.l		%d2,%d3			# ea = (base + bd) + index
	mov.l		%d3,%d0
done_ea:
	mov.l		%d0,%a0

	movm.l		(%sp)+,&0x003c		# restore d2-d5
	rts

# if dmem_read_long() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# FSLW:
# 	read = true
# 	size = longword
#	TM = data
# 	software emulation error = true
calc_ea_err:
	mov.l		%d3,%a0			# pass failing address
	mov.l		&0x01010001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF **************************************************************** #
# 	_moveperipheral(): routine to emulate movep instruction		#
#									#
# XREF **************************************************************** #
#	_dmem_read_byte() - read byte from memory			#
#	_dmem_write_byte() - write byte to memory			#
#	isp_dacc() - handle data access error exception			#
#									#
# INPUT *************************************************************** #
#	none								#
#									#
# OUTPUT ************************************************************** #
#	If exiting through isp_dacc...					#
#		a0 = failing address					#
#		d0 = FSLW						#
#	else								#
#		none							#
#									#
# ALGORITHM ***********************************************************	#
#	Decode the movep instruction words stored at EXC_OPWORD and	#
# either read or write the required bytes from/to memory. Use the	#
# _dmem_{read,write}_byte() routines. If one of the memory routines	#
# returns a failing value, we must pass the failing address and	a FSLW	#
# to the _isp_dacc() routine.						#
#	Since this instruction is used to access peripherals, make sure	#
# to only access the required bytes.					#
#									#
#########################################################################

###########################
# movep.(w,l)	Dx,(d,Ay) #
# movep.(w,l)	(d,Ay),Dx #
###########################
	global 		_moveperipheral
_moveperipheral:
	mov.w		EXC_OPWORD(%a6),%d1	# fetch the opcode word

	mov.b		%d1,%d0
	and.w		&0x7,%d0		# extract Ay from opcode word

	mov.l		(EXC_AREGS,%a6,%d0.w*4),%a0 # fetch ay

	add.w		EXC_EXTWORD(%a6),%a0	# add: an + sgn_ext(disp)

	btst		&0x7,%d1		# (reg 2 mem) or (mem 2 reg)
	beq.w		mem2reg

# reg2mem: fetch dx, then write it to memory
reg2mem:
	mov.w		%d1,%d0
	rol.w		&0x7,%d0
	and.w		&0x7,%d0		# extract Dx from opcode word

	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d0 # fetch dx

	btst		&0x6,%d1		# word or long operation?
	beq.b		r2mwtrans

# a0 = dst addr
# d0 = Dx
r2mltrans:
	mov.l		%d0,%d2			# store data
	mov.l		%a0,%a2			# store addr
	rol.l		&0x8,%d2
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write hi

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	add.w		&0x2,%a2		# incr addr
	mov.l		%a2,%a0
	rol.l		&0x8,%d2
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write lo

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	add.w		&0x2,%a2		# incr addr
	mov.l		%a2,%a0
	rol.l		&0x8,%d2
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write lo

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	add.w		&0x2,%a2		# incr addr
	mov.l		%a2,%a0
	rol.l		&0x8,%d2
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write lo

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	rts

# a0 = dst addr
# d0 = Dx
r2mwtrans:
	mov.l		%d0,%d2			# store data
	mov.l		%a0,%a2			# store addr
	lsr.w		&0x8,%d0

	bsr.l		_dmem_write_byte	# os  : write hi

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	add.w		&0x2,%a2
	mov.l		%a2,%a0
	mov.l		%d2,%d0

	bsr.l		_dmem_write_byte	# os  : write lo

	tst.l		%d1			# dfetch error?
	bne.w		movp_write_err		# yes

	rts

# mem2reg: read bytes from memory.
# determines the dest register, and then writes the bytes into it.
mem2reg:
	btst		&0x6,%d1		# word or long operation?
	beq.b		m2rwtrans

# a0 = dst addr
m2rltrans:
	mov.l		%a0,%a2			# store addr

	bsr.l		_dmem_read_byte		# read first byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	mov.l		%d0,%d2

	add.w		&0x2,%a2		# incr addr by 2 bytes
	mov.l		%a2,%a0

	bsr.l		_dmem_read_byte		# read second byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	lsl.w		&0x8,%d2
	mov.b		%d0,%d2			# append bytes

	add.w		&0x2,%a2		# incr addr by 2 bytes
	mov.l		%a2,%a0

	bsr.l		_dmem_read_byte		# read second byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	lsl.l		&0x8,%d2
	mov.b		%d0,%d2			# append bytes

	add.w		&0x2,%a2		# incr addr by 2 bytes
	mov.l		%a2,%a0

	bsr.l		_dmem_read_byte		# read second byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	lsl.l		&0x8,%d2
	mov.b		%d0,%d2			# append bytes

	mov.b		EXC_OPWORD(%a6),%d1
	lsr.b		&0x1,%d1
	and.w		&0x7,%d1		# extract Dx from opcode word
	
	mov.l		%d2,(EXC_DREGS,%a6,%d1.w*4) # store dx

	rts
	
# a0 = dst addr
m2rwtrans:
	mov.l		%a0,%a2			# store addr

	bsr.l		_dmem_read_byte		# read first byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	mov.l		%d0,%d2

	add.w		&0x2,%a2		# incr addr by 2 bytes
	mov.l		%a2,%a0

	bsr.l		_dmem_read_byte		# read second byte

	tst.l		%d1			# dfetch error?
	bne.w		movp_read_err		# yes

	lsl.w		&0x8,%d2
	mov.b		%d0,%d2			# append bytes

	mov.b		EXC_OPWORD(%a6),%d1
	lsr.b		&0x1,%d1
	and.w		&0x7,%d1		# extract Dx from opcode word
	
	mov.w		%d2,(EXC_DREGS+2,%a6,%d1.w*4) # store dx

	rts

# if dmem_{read,write}_byte() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# FSLW:
# 	write = true
#	size = byte
#	TM = data
#	software emulation error = true
movp_write_err:
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x00a10001,%d0		# pass fslw
	bra.l		isp_dacc

# FSLW:
# 	read = true
#	size = byte
#	TM = data
#	software emulation error = true
movp_read_err:
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01210001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF ****************************************************************	#
# 	_chk2_cmp2(): routine to emulate chk2/cmp2 instructions		#
#									#
# XREF ****************************************************************	#
#	_calc_ea(): calculate effective address				#
#	_dmem_read_long(): read operands				#
# 	_dmem_read_word(): read operands				#
#	isp_dacc(): handle data access error exception			#
#									#
# INPUT ***************************************************************	#
#	none								#
#									#
# OUTPUT **************************************************************	#
#	If exiting through isp_dacc...					#
#		a0 = failing address					#
#		d0 = FSLW						#
#	else								#
# 		none							#
#									#
# ALGORITHM ***********************************************************	#
#	First, calculate the effective address, then fetch the byte,	#
# word, or longword sized operands. Then, in the interest of 		#
# simplicity, all operands are converted to longword size whether the 	#
# operation is byte, word, or long. The bounds are sign extended 	#
# accordingly. If Rn is a data regsiter, Rn is also sign extended. If 	#
# Rn is an address register, it need not be sign extended since the 	#
# full register is always used.						#
#	The comparisons are made and the condition codes calculated.	#
# If the instruction is chk2 and the Rn value is out-of-bounds, set	#
# the ichk_flg in SPCOND_FLG.						#
#	If the memory fetch returns a failing value, pass the failing 	#
# address and FSLW to the isp_dacc() routine.				#
#									#
#########################################################################

	global 		_chk2_cmp2
_chk2_cmp2:

# passing size parameter doesn't matter since chk2 & cmp2 can't do
# either predecrement, postincrement, or immediate.
	bsr.l		_calc_ea		# calculate <ea>

	mov.b		EXC_EXTWORD(%a6), %d0	# fetch hi extension word
	rol.b		&0x4, %d0		# rotate reg bits into lo
	and.w		&0xf, %d0		# extract reg bits

	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d2 # get regval

	cmpi.b		EXC_OPWORD(%a6), &0x2	# what size is operation?
	blt.b		chk2_cmp2_byte		# size == byte
	beq.b		chk2_cmp2_word		# size == word

# the bounds are longword size. call routine to read the lower
# bound into d0 and the higher bound into d1.
chk2_cmp2_long:
	mov.l		%a0,%a2			# save copy of <ea>
	bsr.l		_dmem_read_long		# fetch long lower bound

	tst.l		%d1			# dfetch error?
	bne.w		chk2_cmp2_err_l		# yes

	mov.l		%d0,%d3			# save long lower bound
	addq.l		&0x4,%a2
	mov.l		%a2,%a0			# pass <ea> of long upper bound
	bsr.l		_dmem_read_long		# fetch long upper bound

	tst.l		%d1			# dfetch error?
	bne.w		chk2_cmp2_err_l		# yes

	mov.l		%d0,%d1			# long upper bound in d1
	mov.l		%d3,%d0			# long lower bound in d0
	bra.w		chk2_cmp2_compare	# go do the compare emulation

# the bounds are word size. fetch them in one subroutine call by
# reading a longword. sign extend both. if it's a data operation,
# sign extend Rn to long, also.
chk2_cmp2_word:
	mov.l		%a0,%a2
	bsr.l		_dmem_read_long		# fetch 2 word bounds

	tst.l		%d1			# dfetch error?
	bne.w		chk2_cmp2_err_l		# yes

	mov.w		%d0, %d1		# place hi in %d1
	swap		%d0			# place lo in %d0

	ext.l		%d0			# sign extend lo bnd
	ext.l		%d1			# sign extend hi bnd

	btst		&0x7, EXC_EXTWORD(%a6)	# address compare?
	bne.w		chk2_cmp2_compare	# yes; don't sign extend

# operation is a data register compare.
# sign extend word to long so we can do simple longword compares.
	ext.l		%d2			# sign extend data word
	bra.w		chk2_cmp2_compare	# go emulate compare

# the bounds are byte size. fetch them in one subroutine call by
# reading a word. sign extend both. if it's a data operation,
# sign extend Rn to long, also.
chk2_cmp2_byte:
	mov.l		%a0,%a2
	bsr.l		_dmem_read_word		# fetch 2 byte bounds

	tst.l		%d1			# dfetch error?
	bne.w		chk2_cmp2_err_w		# yes

	mov.b		%d0, %d1		# place hi in %d1
	lsr.w		&0x8, %d0		# place lo in %d0

	extb.l		%d0			# sign extend lo bnd
	extb.l		%d1			# sign extend hi bnd

	btst		&0x7, EXC_EXTWORD(%a6)	# address compare?
	bne.b		chk2_cmp2_compare	# yes; don't sign extend

# operation is a data register compare.
# sign extend byte to long so we can do simple longword compares.
	extb.l		%d2			# sign extend data byte

#
# To set the ccodes correctly:
# 	(1) save 'Z' bit from (Rn - lo)
#	(2) save 'Z' and 'N' bits from ((hi - lo) - (Rn - hi))
#	(3) keep 'X', 'N', and 'V' from before instruction
#	(4) combine ccodes
#
chk2_cmp2_compare:
	sub.l		%d0, %d2		# (Rn - lo)
	mov.w		%cc, %d3		# fetch resulting ccodes
	andi.b		&0x4, %d3		# keep 'Z' bit
	sub.l		%d0, %d1		# (hi - lo)
	cmp.l	 	%d1,%d2			# ((hi - lo) - (Rn - hi))

	mov.w		%cc, %d4		# fetch resulting ccodes
	or.b		%d4, %d3		# combine w/ earlier ccodes
	andi.b		&0x5, %d3		# keep 'Z' and 'N'

	mov.w		EXC_CC(%a6), %d4	# fetch old ccodes
	andi.b		&0x1a, %d4		# keep 'X','N','V' bits
	or.b		%d3, %d4		# insert new ccodes
	mov.w		%d4, EXC_CC(%a6)	# save new ccodes

	btst		&0x3, EXC_EXTWORD(%a6)	# separate chk2,cmp2
	bne.b		chk2_finish		# it's a chk2

	rts

# this code handles the only difference between chk2 and cmp2. chk2 would
# have trapped out if the value was out of bounds. we check this by seeing
# if the 'N' bit was set by the operation.
chk2_finish:	
	btst		&0x0, %d4		# is 'N' bit set?
	bne.b		chk2_trap		# yes;chk2 should trap
	rts
chk2_trap:
	mov.b		&ichk_flg,SPCOND_FLG(%a6) # set "special case" flag
	rts

# if dmem_read_{long,word}() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# FSLW:
#	read = true
#	size = longword
#	TM = data
# 	software emulation error = true
chk2_cmp2_err_l:
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01010001,%d0		# pass fslw
	bra.l		isp_dacc

# FSLW:
#	read = true
#	size = word
#	TM = data
# 	software emulation error = true
chk2_cmp2_err_w:
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01410001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF ****************************************************************	#
# 	_div64(): routine to emulate div{u,s}.l <ea>,Dr:Dq		#
#							64/32->32r:32q	#
#									#
# XREF ****************************************************************	#
#	_calc_ea() - calculate effective address			#
# 	isp_iacc() - handle instruction access error exception		#
#	isp_dacc() - handle data access error exception			#
#	isp_restore() - restore An on access error w/ -() or ()+	#
#									#
# INPUT ***************************************************************	#
#	none								#
#									#
# OUTPUT **************************************************************	#
# 	If exiting through isp_dacc...					#
#		a0 = failing address					#
# 		d0 = FSLW						#
#	else								#
#		none							#
#									#
# ALGORITHM ***********************************************************	#
# 	First, decode the operand location. If it's in Dn, fetch from	#
# the stack. If it's in memory, use _calc_ea() to calculate the 	#
# effective address. Use _dmem_read_long() to fetch at that address.	#
# Unless the operand is immediate data. Then use _imem_read_long().	#
# Send failures to isp_dacc() or isp_iacc() as appropriate.		#
#	If the operands are signed, make them unsigned and save	the 	#
# sign info for later. Separate out special cases like divide-by-zero	#
# or 32-bit divides if possible. Else, use a special math algorithm	#
# to calculate the result. 						#
#	Restore sign info if signed instruction. Set the condition 	#
# codes. Set idbyz_flg in SPCOND_FLG if divisor was zero. Store the 	#
# quotient and remainder in the appropriate data registers on the stack.#
#									#
#########################################################################

set	NDIVISOR,	EXC_TEMP+0x0
set	NDIVIDEND,	EXC_TEMP+0x1
set	NDRSAVE,	EXC_TEMP+0x2
set	NDQSAVE,	EXC_TEMP+0x4
set	DDSECOND,	EXC_TEMP+0x6
set	DDQUOTIENT,	EXC_TEMP+0x8
set	DDNORMAL,	EXC_TEMP+0xc

	global		_div64
#############
# div(u,s)l #
#############
_div64:
	mov.b		EXC_OPWORD+1(%a6), %d0
	andi.b		&0x38, %d0		# extract src mode

	bne.w		dcontrolmodel_s		# %dn dest or control mode?

	mov.b		EXC_OPWORD+1(%a6), %d0	# extract Dn from opcode
	andi.w		&0x7, %d0
	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d7 # fetch divisor from register

dgotsrcl:
	beq.w		div64eq0		# divisor is = 0!!!

	mov.b		EXC_EXTWORD+1(%a6), %d0	# extract Dr from extword
	mov.b		EXC_EXTWORD(%a6), %d1	# extract Dq from extword
	and.w		&0x7, %d0
	lsr.b		&0x4, %d1
	and.w		&0x7, %d1
	mov.w		%d0, NDRSAVE(%a6)	# save Dr for later
	mov.w		%d1, NDQSAVE(%a6)	# save Dq for later

# fetch %dr and %dq directly off stack since all regs are saved there
	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d5 # get dividend hi
	mov.l		(EXC_DREGS,%a6,%d1.w*4), %d6 # get dividend lo

# separate signed and unsigned divide
	btst		&0x3, EXC_EXTWORD(%a6)	# signed or unsigned?
	beq.b		dspecialcases		# use positive divide

# save the sign of the divisor
# make divisor unsigned if it's negative
	tst.l		%d7			# chk sign of divisor
	slt		NDIVISOR(%a6)		# save sign of divisor
	bpl.b		dsgndividend
	neg.l		%d7			# complement negative divisor

# save the sign of the dividend
# make dividend unsigned if it's negative
dsgndividend:
	tst.l		%d5			# chk sign of hi(dividend)
	slt		NDIVIDEND(%a6)		# save sign of dividend
	bpl.b		dspecialcases

	mov.w		&0x0, %cc		# clear 'X' cc bit
	negx.l		%d6			# complement signed dividend
	negx.l		%d5

# extract some special cases:
# 	- is (dividend == 0) ?
#	- is (hi(dividend) == 0 && (divisor <= lo(dividend))) ? (32-bit div)
dspecialcases:
	tst.l		%d5			# is (hi(dividend) == 0)
	bne.b		dnormaldivide		# no, so try it the long way

	tst.l		%d6			# is (lo(dividend) == 0), too
	beq.w		ddone			# yes, so (dividend == 0)

	cmp.l	 	%d7,%d6			# is (divisor <= lo(dividend))
	bls.b		d32bitdivide		# yes, so use 32 bit divide

	exg		%d5,%d6			# q = 0, r = dividend
	bra.w		divfinish		# can't divide, we're done.

d32bitdivide:
	tdivu.l		%d7, %d5:%d6		# it's only a 32/32 bit div!

	bra.b		divfinish

dnormaldivide:
# last special case:
# 	- is hi(dividend) >= divisor ? if yes, then overflow
	cmp.l		%d7,%d5
	bls.b		ddovf			# answer won't fit in 32 bits

# perform the divide algorithm:
	bsr.l		dclassical		# do int divide

# separate into signed and unsigned finishes.
divfinish:
	btst		&0x3, EXC_EXTWORD(%a6)	# do divs, divu separately
	beq.b		ddone			# divu has no processing!!!

# it was a divs.l, so ccode setting is a little more complicated...
	tst.b		NDIVIDEND(%a6)		# remainder has same sign 
	beq.b		dcc			# as dividend.
	neg.l		%d5			# sgn(rem) = sgn(dividend)
dcc:
	mov.b		NDIVISOR(%a6), %d0
	eor.b		%d0, NDIVIDEND(%a6)	# chk if quotient is negative
	beq.b		dqpos			# branch to quot positive

# 0x80000000 is the largest number representable as a 32-bit negative
# number. the negative of 0x80000000 is 0x80000000.
	cmpi.l		%d6, &0x80000000	# will (-quot) fit in 32 bits?
	bhi.b		ddovf

	neg.l		%d6			# make (-quot) 2's comp

	bra.b		ddone

dqpos:
	btst		&0x1f, %d6		# will (+quot) fit in 32 bits?
	bne.b		ddovf

ddone:
# at this point, result is normal so ccodes are set based on result.
	mov.w		EXC_CC(%a6), %cc
	tst.l		%d6			# set %ccode bits
	mov.w		%cc, EXC_CC(%a6)

	mov.w		NDRSAVE(%a6), %d0	# get Dr off stack
	mov.w		NDQSAVE(%a6), %d1	# get Dq off stack	

# if the register numbers are the same, only the quotient gets saved.
# so, if we always save the quotient second, we save ourselves a cmp&beq
	mov.l		%d5, (EXC_DREGS,%a6,%d0.w*4) # save remainder
	mov.l		%d6, (EXC_DREGS,%a6,%d1.w*4) # save quotient

	rts

ddovf:
	bset		&0x1, EXC_CC+1(%a6)	# 'V' set on overflow
	bclr		&0x0, EXC_CC+1(%a6)	# 'C' cleared on overflow

	rts

div64eq0:
	andi.b		&0x1e, EXC_CC+1(%a6)	# clear 'C' bit on divbyzero
	ori.b		&idbyz_flg,SPCOND_FLG(%a6) # set "special case" flag
	rts

###########################################################################
#########################################################################
# This routine uses the 'classical' Algorithm D from Donald Knuth's	#
# Art of Computer Programming, vol II, Seminumerical Algorithms.	#
# For this implementation b=2**16, and the target is U1U2U3U4/V1V2,	#
# where U,V are words of the quadword dividend and longword divisor,	#
# and U1, V1 are the most significant words.				#
# 									#
# The most sig. longword of the 64 bit dividend must be in %d5, least 	#
# in %d6. The divisor must be in the variable ddivisor, and the		#
# signed/unsigned flag ddusign must be set (0=unsigned,1=signed).	#
# The quotient is returned in %d6, remainder in %d5, unless the		#
# v (overflow) bit is set in the saved %ccr. If overflow, the dividend	#
# is unchanged.								#
#########################################################################
dclassical:
# if the divisor msw is 0, use simpler algorithm then the full blown
# one at ddknuth:

	cmpi.l		%d7, &0xffff
	bhi.b		ddknuth			# go use D. Knuth algorithm

# Since the divisor is only a word (and larger than the mslw of the dividend),
# a simpler algorithm may be used :
# In the general case, four quotient words would be created by
# dividing the divisor word into each dividend word. In this case,
# the first two quotient words must be zero, or overflow would occur.
# Since we already checked this case above, we can treat the most significant
# longword of the dividend as (0) remainder (see Knuth) and merely complete 
# the last two divisions to get a quotient longword and word remainder:

	clr.l		%d1
	swap		%d5			# same as r*b if previous step rqd
	swap		%d6			# get u3 to lsw position
	mov.w		%d6, %d5		# rb + u3

	divu.w		%d7, %d5

	mov.w		%d5, %d1		# first quotient word
	swap		%d6			# get u4
	mov.w		%d6, %d5		# rb + u4

	divu.w		%d7, %d5

	swap		%d1
	mov.w		%d5, %d1		# 2nd quotient 'digit'
	clr.w		%d5
	swap		%d5			# now remainder
	mov.l		%d1, %d6		# and quotient

	rts

ddknuth:
# In this algorithm, the divisor is treated as a 2 digit (word) number
# which is divided into a 3 digit (word) dividend to get one quotient
# digit (word). After subtraction, the dividend is shifted and the
# process repeated. Before beginning, the divisor and quotient are
# 'normalized' so that the process of estimating the quotient digit
# will yield verifiably correct results..

	clr.l		DDNORMAL(%a6)		# count of shifts for normalization
	clr.b		DDSECOND(%a6)		# clear flag for quotient digits
	clr.l		%d1			# %d1 will hold trial quotient
ddnchk:
	btst		&31, %d7		# must we normalize? first word of 
	bne.b		ddnormalized		# divisor (V1) must be >= 65536/2
	addq.l		&0x1, DDNORMAL(%a6)	# count normalization shifts
	lsl.l		&0x1, %d7		# shift the divisor
	lsl.l		&0x1, %d6		# shift u4,u3 with overflow to u2
	roxl.l		&0x1, %d5		# shift u1,u2 
	bra.w		ddnchk
ddnormalized:

# Now calculate an estimate of the quotient words (msw first, then lsw).
# The comments use subscripts for the first quotient digit determination.
	mov.l		%d7, %d3		# divisor
	mov.l		%d5, %d2		# dividend mslw
	swap		%d2
	swap		%d3
	cmp.w	 	%d2, %d3		# V1 = U1 ?
	bne.b		ddqcalc1
	mov.w		&0xffff, %d1		# use max trial quotient word
	bra.b		ddadj0
ddqcalc1:
	mov.l		%d5, %d1		

	divu.w		%d3, %d1		# use quotient of mslw/msw

	andi.l		&0x0000ffff, %d1	# zero any remainder
ddadj0:

# now test the trial quotient and adjust. This step plus the
# normalization assures (according to Knuth) that the trial
# quotient will be at worst 1 too large.
	mov.l		%d6, -(%sp)
	clr.w		%d6			# word u3 left
	swap		%d6			# in lsw position
ddadj1: mov.l		%d7, %d3
	mov.l		%d1, %d2
	mulu.w		%d7, %d2		# V2q
	swap		%d3
	mulu.w		%d1, %d3		# V1q
	mov.l		%d5, %d4		# U1U2
	sub.l		%d3, %d4		# U1U2 - V1q

	swap		%d4

	mov.w		%d4,%d0
	mov.w		%d6,%d4			# insert lower word (U3)

	tst.w		%d0			# is upper word set?
	bne.w		ddadjd1

#	add.l		%d6, %d4		# (U1U2 - V1q) + U3

	cmp.l	 	%d2, %d4
	bls.b		ddadjd1			# is V2q > (U1U2-V1q) + U3 ?
	subq.l		&0x1, %d1		# yes, decrement and recheck
	bra.b		ddadj1
ddadjd1:
# now test the word by multiplying it by the divisor (V1V2) and comparing
# the 3 digit (word) result with the current dividend words
	mov.l		%d5, -(%sp)		# save %d5 (%d6 already saved)
	mov.l		%d1, %d6
	swap		%d6			# shift answer to ms 3 words
	mov.l		%d7, %d5
	bsr.l		dmm2
	mov.l		%d5, %d2		# now %d2,%d3 are trial*divisor
	mov.l		%d6, %d3
	mov.l		(%sp)+, %d5		# restore dividend
	mov.l		(%sp)+, %d6
	sub.l		%d3, %d6
	subx.l		%d2, %d5		# subtract double precision
	bcc		dd2nd			# no carry, do next quotient digit
	subq.l		&0x1, %d1		# q is one too large
# need to add back divisor longword to current ms 3 digits of dividend
# - according to Knuth, this is done only 2 out of 65536 times for random
# divisor, dividend selection.
	clr.l		%d2
	mov.l		%d7, %d3
	swap		%d3
	clr.w		%d3			# %d3 now ls word of divisor
	add.l		%d3, %d6		# aligned with 3rd word of dividend
	addx.l		%d2, %d5
	mov.l		%d7, %d3
	clr.w		%d3			# %d3 now ms word of divisor
	swap		%d3			# aligned with 2nd word of dividend
	add.l		%d3, %d5
dd2nd:
	tst.b		DDSECOND(%a6)		# both q words done?
	bne.b		ddremain
# first quotient digit now correct. store digit and shift the
# (subtracted) dividend 
	mov.w		%d1, DDQUOTIENT(%a6)
	clr.l		%d1
	swap		%d5
	swap		%d6
	mov.w		%d6, %d5
	clr.w		%d6
	st		DDSECOND(%a6)		# second digit
	bra.w		ddnormalized
ddremain:
# add 2nd word to quotient, get the remainder.
	mov.w 		%d1, DDQUOTIENT+2(%a6)
# shift down one word/digit to renormalize remainder.
	mov.w		%d5, %d6
	swap		%d6
	swap		%d5
	mov.l		DDNORMAL(%a6), %d7	# get norm shift count
	beq.b		ddrn
	subq.l		&0x1, %d7		# set for loop count
ddnlp:
	lsr.l		&0x1, %d5		# shift into %d6
	roxr.l		&0x1, %d6
	dbf		%d7, ddnlp
ddrn:
	mov.l		%d6, %d5		# remainder
	mov.l		DDQUOTIENT(%a6), %d6 	# quotient

	rts
dmm2:
# factors for the 32X32->64 multiplication are in %d5 and %d6.
# returns 64 bit result in %d5 (hi) %d6(lo).
# destroys %d2,%d3,%d4.

# multiply hi,lo words of each factor to get 4 intermediate products
	mov.l		%d6, %d2
	mov.l		%d6, %d3
	mov.l		%d5, %d4
	swap		%d3
	swap		%d4
	mulu.w		%d5, %d6		# %d6 <- lsw*lsw
	mulu.w		%d3, %d5		# %d5 <- msw-dest*lsw-source
	mulu.w		%d4, %d2		# %d2 <- msw-source*lsw-dest
	mulu.w		%d4, %d3		# %d3 <- msw*msw
# now use swap and addx to consolidate to two longwords
	clr.l		%d4
	swap		%d6
	add.w		%d5, %d6		# add msw of l*l to lsw of m*l product
	addx.w		%d4, %d3		# add any carry to m*m product
	add.w		%d2, %d6		# add in lsw of other m*l product
	addx.w		%d4, %d3		# add any carry to m*m product
	swap		%d6			# %d6 is low 32 bits of final product
	clr.w		%d5
	clr.w		%d2			# lsw of two mixed products used,
	swap		%d5			# now use msws of longwords
	swap		%d2
	add.l		%d2, %d5				
	add.l		%d3, %d5		# %d5 now ms 32 bits of final product
	rts

##########
dcontrolmodel_s:
	movq.l		&LONG,%d0
	bsr.l		_calc_ea		# calc <ea>

	cmpi.b		SPCOND_FLG(%a6),&immed_flg # immediate addressing mode?
	beq.b		dimmed			# yes

	mov.l		%a0,%a2
	bsr.l		_dmem_read_long		# fetch divisor from <ea>

	tst.l		%d1			# dfetch error?
	bne.b		div64_err		# yes

	mov.l		%d0, %d7
	bra.w		dgotsrcl

# we have to split out immediate data here because it must be read using
# imem_read() instead of dmem_read(). this becomes especially important
# if the fetch runs into some deadly fault.
dimmed:
	addq.l		&0x4,EXC_EXTWPTR(%a6)
	bsr.l		_imem_read_long		# read immediate value

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		%d0,%d7
	bra.w		dgotsrcl

##########

# if dmem_read_long() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# also, we call isp_restore in case the effective addressing mode was
# (an)+ or -(an) in which case the previous "an" value must be restored.
# FSLW:
# 	read = true
# 	size = longword
#	TM = data
# 	software emulation error = true
div64_err:
	bsr.l		isp_restore		# restore addr reg
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01010001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF ****************************************************************	#
#	_mul64(): routine to emulate mul{u,s}.l <ea>,Dh:Dl 32x32->64	#
#									#
# XREF ****************************************************************	#
#	_calc_ea() - calculate effective address			#
#	isp_iacc() - handle instruction access error exception		#
# 	isp_dacc() - handle data access error exception			#
#	isp_restore() - restore An on access error w/ -() or ()+	#
#									#
# INPUT ***************************************************************	#
#	none								#
#									#
# OUTPUT **************************************************************	#
# 	If exiting through isp_dacc...					#
#		a0 = failing address					#
#		d0 = FSLW						#
# 	else								#
#		none							#
#									#
# ALGORITHM ***********************************************************	#
#	First, decode the operand location. If it's in Dn, fetch from	#
# the stack. If it's in memory, use _calc_ea() to calculate the		#
# effective address. Use _dmem_read_long() to fetch at that address.	#
# Unless the operand is immediate data. Then use _imem_read_long().	#
# Send failures to isp_dacc() or isp_iacc() as appropriate.		#
#	If the operands are signed, make them unsigned and save the 	#
# sign info for later. Perform the multiplication using 16x16->32	#
# unsigned multiplies and "add" instructions. Store the high and low 	#
# portions of the result in the appropriate data registers on the	#
# stack. Calculate the condition codes, also.				#
#									#
#########################################################################

#############
# mul(u,s)l #
#############
	global		_mul64
_mul64:
	mov.b		EXC_OPWORD+1(%a6), %d0	# extract src {mode,reg}
	cmpi.b		%d0, &0x7		# is src mode Dn or other?
	bgt.w		mul64_memop		# src is in memory

# multiplier operand in the the data register file.
# must extract the register number and fetch the operand from the stack.
mul64_regop:
	andi.w		&0x7, %d0		# extract Dn
	mov.l		(EXC_DREGS,%a6,%d0.w*4), %d3 # fetch multiplier

# multiplier is in %d3. now, extract Dl and Dh fields and fetch the
# multiplicand from the data register specified by Dl.
mul64_multiplicand:
	mov.w		EXC_EXTWORD(%a6), %d2	# fetch ext word
	clr.w		%d1			# clear Dh reg
	mov.b		%d2, %d1		# grab Dh
	rol.w		&0x4, %d2		# align Dl byte
	andi.w		&0x7, %d2		# extract Dl

	mov.l		(EXC_DREGS,%a6,%d2.w*4), %d4 # get multiplicand

# check for the case of "zero" result early
	tst.l		%d4			# test multiplicand
	beq.w		mul64_zero		# handle zero separately
	tst.l		%d3			# test multiplier
	beq.w		mul64_zero		# handle zero separately

# multiplier is in %d3 and multiplicand is in %d4.
# if the operation is to be signed, then the operands are converted
# to unsigned and the result sign is saved for the end.
	clr.b		EXC_TEMP(%a6)		# clear temp space
	btst		&0x3, EXC_EXTWORD(%a6)	# signed or unsigned?
	beq.b		mul64_alg		# unsigned; skip sgn calc

	tst.l		%d3			# is multiplier negative?
	bge.b		mul64_chk_md_sgn	# no
	neg.l		%d3			# make multiplier positive
	ori.b		&0x1, EXC_TEMP(%a6)	# save multiplier sgn

# the result sign is the exclusive or of the operand sign bits.
mul64_chk_md_sgn:
	tst.l		%d4			# is multiplicand negative?
	bge.b		mul64_alg		# no	
	neg.l		%d4			# make multiplicand positive
	eori.b		&0x1, EXC_TEMP(%a6)	# calculate correct sign

#########################################################################
#	63			   32				0	#
# 	----------------------------					#
# 	| hi(mplier) * hi(mplicand)|					#
# 	----------------------------					#
#		     -----------------------------			#
#		     | hi(mplier) * lo(mplicand) |			#
#		     -----------------------------			#
#		     -----------------------------			#
#		     | lo(mplier) * hi(mplicand) |			#
#		     -----------------------------			#
#	  |			   -----------------------------	#
#	--|--			   | lo(mplier) * lo(mplicand) |	#
#	  |			   -----------------------------	#
#	========================================================	#
#	--------------------------------------------------------	#
#	|	hi(result)	   |	    lo(result)         |	#
#	--------------------------------------------------------	#
#########################################################################
mul64_alg:
# load temp registers with operands
	mov.l		%d3, %d5		# mr in %d5
	mov.l		%d3, %d6		# mr in %d6
	mov.l		%d4, %d7		# md in %d7
	swap		%d6			# hi(mr) in lo %d6
	swap		%d7			# hi(md) in lo %d7

# complete necessary multiplies:
	mulu.w		%d4, %d3		# [1] lo(mr) * lo(md)
	mulu.w		%d6, %d4		# [2] hi(mr) * lo(md)
	mulu.w		%d7, %d5		# [3] lo(mr) * hi(md)
	mulu.w		%d7, %d6		# [4] hi(mr) * hi(md)

# add lo portions of [2],[3] to hi portion of [1].
# add carries produced from these adds to [4].
# lo([1]) is the final lo 16 bits of the result.
	clr.l		%d7			# load %d7 w/ zero value
	swap		%d3			# hi([1]) <==> lo([1])
	add.w		%d4, %d3		# hi([1]) + lo([2])
	addx.l		%d7, %d6		#    [4]  + carry
	add.w		%d5, %d3		# hi([1]) + lo([3])
	addx.l		%d7, %d6		#    [4]  + carry
	swap		%d3			# lo([1]) <==> hi([1])

# lo portions of [2],[3] have been added in to final result.
# now, clear lo, put hi in lo reg, and add to [4]
	clr.w		%d4			# clear lo([2])
	clr.w		%d5			# clear hi([3])
	swap		%d4			# hi([2]) in lo %d4
	swap		%d5			# hi([3]) in lo %d5
	add.l		%d5, %d4		#    [4]  + hi([2])
	add.l		%d6, %d4		#    [4]  + hi([3])

# unsigned result is now in {%d4,%d3}
	tst.b		EXC_TEMP(%a6)		# should result be signed?
	beq.b		mul64_done		# no

# result should be a signed negative number.
# compute 2's complement of the unsigned number:
#   -negate all bits and add 1
mul64_neg:
	not.l		%d3			# negate lo(result) bits
	not.l		%d4			# negate hi(result) bits
	addq.l		&1, %d3			# add 1 to lo(result)
	addx.l		%d7, %d4		# add carry to hi(result)

# the result is saved to the register file.
# for '040 compatability, if Dl == Dh then only the hi(result) is
# saved. so, saving hi after lo accomplishes this without need to
# check Dl,Dh equality.
mul64_done:
	mov.l		%d3, (EXC_DREGS,%a6,%d2.w*4) # save lo(result)
	mov.w		&0x0, %cc
	mov.l		%d4, (EXC_DREGS,%a6,%d1.w*4) # save hi(result)

# now, grab the condition codes. only one that can be set is 'N'.
# 'N' CAN be set if the operation is unsigned if bit 63 is set.
	mov.w		%cc, %d7		# fetch %ccr to see if 'N' set
	andi.b		&0x8, %d7		# extract 'N' bit

mul64_ccode_set:
	mov.b		EXC_CC+1(%a6), %d6 	# fetch previous %ccr
	andi.b		&0x10, %d6		# all but 'X' bit changes

	or.b		%d7, %d6		# group 'X' and 'N'
	mov.b		%d6, EXC_CC+1(%a6)	# save new %ccr

	rts

# one or both of the operands is zero so the result is also zero.
# save the zero result to the register file and set the 'Z' ccode bit.
mul64_zero:
	clr.l		(EXC_DREGS,%a6,%d2.w*4) # save lo(result)
	clr.l		(EXC_DREGS,%a6,%d1.w*4) # save hi(result)

	movq.l		&0x4, %d7		# set 'Z' ccode bit
	bra.b		mul64_ccode_set		# finish ccode set

##########

# multiplier operand is in memory at the effective address.
# must calculate the <ea> and go fetch the 32-bit operand.
mul64_memop:
	movq.l		&LONG, %d0		# pass # of bytes
	bsr.l		_calc_ea		# calculate <ea>

	cmpi.b		SPCOND_FLG(%a6),&immed_flg # immediate addressing mode?
	beq.b		mul64_immed		# yes

	mov.l		%a0,%a2
	bsr.l		_dmem_read_long		# fetch src from addr (%a0)

	tst.l		%d1			# dfetch error?
	bne.w		mul64_err		# yes

	mov.l		%d0, %d3		# store multiplier in %d3

	bra.w		mul64_multiplicand

# we have to split out immediate data here because it must be read using
# imem_read() instead of dmem_read(). this becomes especially important
# if the fetch runs into some deadly fault.
mul64_immed:
	addq.l		&0x4,EXC_EXTWPTR(%a6)
	bsr.l		_imem_read_long		# read immediate value

	tst.l		%d1			# ifetch error?
	bne.l		isp_iacc		# yes

	mov.l		%d0,%d3
	bra.w		mul64_multiplicand

##########

# if dmem_read_long() returns a fail message in d1, the package
# must create an access error frame. here, we pass a skeleton fslw
# and the failing address to the routine that creates the new frame.
# also, we call isp_restore in case the effective addressing mode was
# (an)+ or -(an) in which case the previous "an" value must be restored.
# FSLW:
# 	read = true
# 	size = longword
#	TM = data
# 	software emulation error = true
mul64_err:
	bsr.l		isp_restore		# restore addr reg
	mov.l		%a2,%a0			# pass failing address
	mov.l		&0x01010001,%d0		# pass fslw
	bra.l		isp_dacc

#########################################################################
# XDEF ****************************************************************	#
#	_compandset2(): routine to emulate cas2()			#
#			(internal to package)				#
#									#
#	_isp_cas2_finish(): store ccodes, store compare regs		#
#			    (external to package)			#
#									#
# XREF ****************************************************************	#
#	_real_lock_page() - "callout" to lock op's page from page-outs	#
#	_cas_terminate2() - access error exit				#
#	_real_cas2() - "callout" to core cas2 emulation code		#
#	_real_unlock_page() - "callout" to unlock page			#
#									#
# INPUT ***************************************************************	#
# _compandset2():							#
#	d0 = instruction extension word					#
#									#
# _isp_cas2_finish():							#
#	see cas2 core emulation code					#
# 									#
# OUTPUT **************************************************************	#
# _compandset2():							#
#	see cas2 core emulation code					#
#									#
# _isp_cas_finish():							#
#	None (register file or memroy changed as appropriate)		#
#									#
# ALGORITHM ***********************************************************	#
# compandset2():							#
#	Decode the instruction and fetch the appropriate Update and	#
# Compare operands. Then call the "callout" _real_lock_page() for each	#
# memory operand address so that the operating system can keep these	#
# pages from being paged out. If either _real_lock_page() fails, exit	#
# through _cas_terminate2(). Don't forget to unlock the 1st locked page	#
# using _real_unlock_paged() if the 2nd lock-page fails.		#
# Finally, branch to the core cas2 emulation code by calling the 	#
# "callout" _real_cas2().						#
#									#
# _isp_cas2_finish():							#
#	Re-perform the comparison so we can determine the condition	#
# codes which were too much trouble to keep around during the locked	#
# emulation. Then unlock each operands page by calling the "callout"	#
# _real_unlock_page().							#
#									#
#########################################################################

set ADDR1,	EXC_TEMP+0xc
set ADDR2,	EXC_TEMP+0x0
set DC2,	EXC_TEMP+0xa
set DC1,	EXC_TEMP+0x8

	global		_compandset2
_compandset2:
	mov.l		%d0,EXC_TEMP+0x4(%a6)		# store for possible restart
	mov.l		%d0,%d1			# extension word in d0

	rol.w		&0x4,%d0
	andi.w		&0xf,%d0		# extract Rn2
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%a1 # fetch ADDR2
	mov.l		%a1,ADDR2(%a6)

	mov.l		%d1,%d0

	lsr.w		&0x6,%d1
	andi.w		&0x7,%d1		# extract Du2
	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d5 # fetch Update2 Op

	andi.w		&0x7,%d0		# extract Dc2
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%d3 # fetch Compare2 Op
	mov.w		%d0,DC2(%a6)

	mov.w		EXC_EXTWORD(%a6),%d0
	mov.l		%d0,%d1

	rol.w		&0x4,%d0
	andi.w		&0xf,%d0		# extract Rn1
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%a0 # fetch ADDR1
	mov.l		%a0,ADDR1(%a6)

	mov.l		%d1,%d0

	lsr.w		&0x6,%d1
	andi.w		&0x7,%d1		# extract Du1
	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d4 # fetch Update1 Op
	
	andi.w		&0x7,%d0		# extract Dc1
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%d2 # fetch Compare1 Op
	mov.w		%d0,DC1(%a6)

	btst		&0x1,EXC_OPWORD(%a6)	# word or long?
	sne		%d7

	btst		&0x5,EXC_ISR(%a6)	# user or supervisor?
	sne		%d6

	mov.l		%a0,%a2
	mov.l		%a1,%a3

	mov.l		%d7,%d1			# pass size
	mov.l		%d6,%d0			# pass mode
	bsr.l		_real_lock_page		# lock page
	mov.l		%a2,%a0
	tst.l		%d0			# error?
	bne.l		_cas_terminate2		# yes

	mov.l		%d7,%d1			# pass size
	mov.l		%d6,%d0			# pass mode
	mov.l		%a3,%a0			# pass addr
	bsr.l		_real_lock_page		# lock page
	mov.l		%a3,%a0
	tst.l		%d0			# error?
	bne.b		cas_preterm		# yes

	mov.l		%a2,%a0
	mov.l		%a3,%a1

	bra.l		_real_cas2

# if the 2nd lock attempt fails, then we must still unlock the 
# first page(s).
cas_preterm:
	mov.l		%d0,-(%sp)		# save FSLW
	mov.l		%d7,%d1			# pass size
	mov.l		%d6,%d0			# pass mode
	mov.l		%a2,%a0			# pass ADDR1
	bsr.l		_real_unlock_page	# unlock first page(s)
	mov.l		(%sp)+,%d0		# restore FSLW
	mov.l		%a3,%a0			# pass failing addr
	bra.l		_cas_terminate2

#############################################################

	global		_isp_cas2_finish
_isp_cas2_finish:
	btst		&0x1,EXC_OPWORD(%a6)
	bne.b		cas2_finish_l

	mov.w		EXC_CC(%a6),%cc		# load old ccodes
	cmp.w		%d0,%d2
	bne.b		cas2_finish_w_save
	cmp.w		%d1,%d3
cas2_finish_w_save:
	mov.w		%cc,EXC_CC(%a6)		# save new ccodes

	tst.b		%d4			# update compare reg?
	bne.b		cas2_finish_w_done	# no

	mov.w		DC2(%a6),%d3		# fetch Dc2
	mov.w		%d1,(2+EXC_DREGS,%a6,%d3.w*4) # store new Compare2 Op

	mov.w		DC1(%a6),%d2		# fetch Dc1
	mov.w		%d0,(2+EXC_DREGS,%a6,%d2.w*4) # store new Compare1 Op

cas2_finish_w_done:
	btst		&0x5,EXC_ISR(%a6)
	sne		%d2
	mov.l		%d2,%d0			# pass mode
	sf		%d1			# pass size
	mov.l		ADDR1(%a6),%a0		# pass ADDR1
	bsr.l		_real_unlock_page	# unlock page
	
	mov.l		%d2,%d0			# pass mode
	sf		%d1			# pass size
	mov.l		ADDR2(%a6),%a0		# pass ADDR2
	bsr.l		_real_unlock_page	# unlock page
	rts

cas2_finish_l:
	mov.w		EXC_CC(%a6),%cc		# load old ccodes
	cmp.l		%d0,%d2
	bne.b		cas2_finish_l_save
	cmp.l		%d1,%d3
cas2_finish_l_save:
	mov.w		%cc,EXC_CC(%a6)		# save new ccodes

	tst.b		%d4			# update compare reg?
	bne.b		cas2_finish_l_done	# no

	mov.w		DC2(%a6),%d3		# fetch Dc2
	mov.l		%d1,(EXC_DREGS,%a6,%d3.w*4) # store new Compare2 Op

	mov.w		DC1(%a6),%d2		# fetch Dc1
	mov.l		%d0,(EXC_DREGS,%a6,%d2.w*4) # store new Compare1 Op

cas2_finish_l_done:
	btst		&0x5,EXC_ISR(%a6)
	sne		%d2
	mov.l		%d2,%d0			# pass mode
	st		%d1			# pass size
	mov.l		ADDR1(%a6),%a0		# pass ADDR1
	bsr.l		_real_unlock_page	# unlock page
	
	mov.l		%d2,%d0			# pass mode
	st		%d1			# pass size
	mov.l		ADDR2(%a6),%a0		# pass ADDR2
	bsr.l		_real_unlock_page	# unlock page
	rts

########
	global		cr_cas2
cr_cas2:
	mov.l		EXC_TEMP+0x4(%a6),%d0
	bra.w		_compandset2

#########################################################################
# XDEF ****************************************************************	#
#	_compandset(): routine to emulate cas w/ misaligned <ea>	#
#		       (internal to package)				#
#	_isp_cas_finish(): routine called when cas emulation completes	#
#			   (external and internal to package)		#
#	_isp_cas_restart(): restart cas emulation after a fault		#
#			    (external to package)			#
#	_isp_cas_terminate(): create access error stack frame on fault	#
#			      (external and internal to package)	#
#	_isp_cas_inrange(): checks whether instr addess is within range	#
#			    of core cas/cas2emulation code		#
#			    (external to package)			#
#									#
# XREF ****************************************************************	#
# 	_calc_ea(): calculate effective address				#
#									#
# INPUT ***************************************************************	#
# compandset():								#
# 	none								#
# _isp_cas_restart():							#
#	d6 = previous sfc/dfc						#
# _isp_cas_finish():							#
# _isp_cas_terminate():							#
#	a0 = failing address						#
#	d0 = FSLW							#
#	d6 = previous sfc/dfc						#
# _isp_cas_inrange():							#
#	a0 = instruction address to be checked				#
#									#
# OUTPUT **************************************************************	#
# compandset():								#
#		none							#
# _isp_cas_restart():							#
#	a0 = effective address						#
#	d7 = word or longword flag					#
# _isp_cas_finish():							#
#	a0 = effective address						#
# _isp_cas_terminate():							#
#	initial register set before emulation exception			#
# _isp_cas_inrange():							#
#	d0 = 0 => in range; -1 => out of range				#
#									#
# ALGORITHM ***********************************************************	#
#									#
# compandset():								#
#	First, calculate the effective address. Then, decode the 	#
# instruction word and fetch the "compare" (DC) and "update" (Du)	#
# operands.								#
# 	Next, call the external routine _real_lock_page() so that the	#
# operating system can keep this page from being paged out while we're	#
# in this routine. If this call fails, jump to _cas_terminate2().	#
#	The routine then branches to _real_cas(). This external routine	#
# that actually emulates cas can be supplied by the external os or	#
# made to point directly back into the 060ISP which has a routine for	#
# this purpose.								#
#									#
# _isp_cas_finish():							#
# 	Either way, after emulation, the package is re-entered at	#
# _isp_cas_finish(). This routine re-compares the operands in order to	#
# set the condition codes. Finally, these routines will call		#
# _real_unlock_page() in order to unlock the pages that were previously	#
# locked.								#
#									#
# _isp_cas_restart():							#
#	This routine can be entered from an access error handler where	#
# the emulation sequence should be re-started from the beginning.	#
#									#
# _isp_cas_terminate():							#
#	This routine can be entered from an access error handler where	#
# an emulation operand access failed and the operating system would	#
# like an access error stack frame created instead of the current 	#
# unimplemented integer instruction frame.				#
# 	Also, the package enters here if a call to _real_lock_page()	#
# fails.								#
#									#
# _isp_cas_inrange():							#
# 	Checks to see whether the instruction address passed to it in	#
# a0 is within the software package cas/cas2 emulation routines. This	#
# can be helpful for an operating system to determine whether an access	#
# error during emulation was due to a cas/cas2 emulation access.	#
#									#
#########################################################################

set DC,		EXC_TEMP+0x8
set ADDR,	EXC_TEMP+0x4

	global		_compandset
_compandset:
	btst		&0x1,EXC_OPWORD(%a6)	# word or long operation?
	bne.b		compandsetl		# long	

compandsetw:
	movq.l		&0x2,%d0		# size = 2 bytes
	bsr.l		_calc_ea		# a0 = calculated <ea>	
	mov.l		%a0,ADDR(%a6)		# save <ea> for possible restart
	sf		%d7			# clear d7 for word size
	bra.b		compandsetfetch

compandsetl:
	movq.l		&0x4,%d0		# size = 4 bytes
	bsr.l		_calc_ea		# a0 = calculated <ea>	
	mov.l		%a0,ADDR(%a6)		# save <ea> for possible restart
	st		%d7			# set d7 for longword size

compandsetfetch:
	mov.w		EXC_EXTWORD(%a6),%d0	# fetch cas extension word
	mov.l		%d0,%d1			# make a copy

	lsr.w		&0x6,%d0
	andi.w		&0x7,%d0		# extract Du
	mov.l		(EXC_DREGS,%a6,%d0.w*4),%d2 # get update operand

	andi.w		&0x7,%d1		# extract Dc
	mov.l		(EXC_DREGS,%a6,%d1.w*4),%d4 # get compare operand
	mov.w		%d1,DC(%a6)		# save Dc

	btst		&0x5,EXC_ISR(%a6)	# which mode for exception?
	sne		%d6			# set on supervisor mode

	mov.l		%a0,%a2			# save temporarily
	mov.l		%d7,%d1			# pass size
	mov.l		%d6,%d0			# pass mode
	bsr.l		_real_lock_page		# lock page
	tst.l		%d0			# did error occur?
	bne.w		_cas_terminate2		# yes, clean up the mess
	mov.l		%a2,%a0			# pass addr in a0
	
	bra.l		_real_cas

########
	global		_isp_cas_finish
_isp_cas_finish:
	btst		&0x1,EXC_OPWORD(%a6)
	bne.b		cas_finish_l

# just do the compare again since it's faster than saving the ccodes
# from the locked routine...
cas_finish_w:
	mov.w		EXC_CC(%a6),%cc		# restore cc
	cmp.w	 	%d0,%d4			# do word compare
	mov.w		%cc,EXC_CC(%a6)		# save cc

	tst.b		%d1			# update compare reg?
	bne.b		cas_finish_w_done	# no

	mov.w		DC(%a6),%d3
	mov.w		%d0,(EXC_DREGS+2,%a6,%d3.w*4) # Dc = destination

cas_finish_w_done:
	mov.l		ADDR(%a6),%a0		# pass addr
	sf		%d1			# pass size
	btst		&0x5,EXC_ISR(%a6)
	sne		%d0			# pass mode
	bsr.l		_real_unlock_page	# unlock page
	rts

# just do the compare again since it's faster than saving the ccodes
# from the locked routine...
cas_finish_l:
	mov.w		EXC_CC(%a6),%cc		# restore cc
	cmp.l	 	%d0,%d4			# do longword compare
	mov.w		%cc,EXC_CC(%a6)		# save cc

	tst.b		%d1			# update compare reg?
	bne.b		cas_finish_l_done	# no

	mov.w		DC(%a6),%d3
	mov.l		%d0,(EXC_DREGS,%a6,%d3.w*4) # Dc = destination

cas_finish_l_done:
	mov.l		ADDR(%a6),%a0		# pass addr
	st		%d1			# pass size
	btst		&0x5,EXC_ISR(%a6)
	sne		%d0			# pass mode
	bsr.l		_real_unlock_page	# unlock page
	rts

########
	
	global		_isp_cas_restart
_isp_cas_restart:
	mov.l		%d6,%sfc		# restore previous sfc
	mov.l		%d6,%dfc		# restore previous dfc

	cmpi.b		EXC_OPWORD+1(%a6),&0xfc	# cas or cas2?
	beq.l		cr_cas2			# cas2
cr_cas:
	mov.l		ADDR(%a6),%a0		# load <ea>
	btst		&0x1,EXC_OPWORD(%a6)	# word or long operation?
	sne		%d7			# set d7 accordingly
	bra.w		compandsetfetch	

########

# At this stage, it would be nice if d0 held the FSLW.
	global		_isp_cas_terminate
_isp_cas_terminate:
	mov.l		%d6,%sfc		# restore previous sfc
	mov.l		%d6,%dfc		# restore previous dfc

	global		_cas_terminate2
_cas_terminate2:
	mov.l		%a0,%a2			# copy failing addr to a2

	mov.l		%d0,-(%sp)
	bsr.l		isp_restore		# restore An (if ()+ or -())
	mov.l		(%sp)+,%d0

	addq.l		&0x4,%sp		# remove sub return addr
	subq.l		&0x8,%sp		# make room for bigger stack
	subq.l		&0x8,%a6		# shift frame ptr down, too
	mov.l		&26,%d1			# want to move 51 longwords
	lea		0x8(%sp),%a0		# get address of old stack
	lea		0x0(%sp),%a1		# get address of new stack
cas_term_cont:
	mov.l		(%a0)+,(%a1)+		# move a longword
	dbra.w		%d1,cas_term_cont	# keep going

	mov.w		&0x4008,EXC_IVOFF(%a6)	# put new stk fmt, voff
	mov.l		%a2,EXC_IVOFF+0x2(%a6)	# put faulting addr on stack
	mov.l		%d0,EXC_IVOFF+0x6(%a6)	# put FSLW on stack
	movm.l		EXC_DREGS(%a6),&0x3fff	# restore user regs
	unlk		%a6			# unlink stack frame
	bra.l		_real_access

########

	global		_isp_cas_inrange
_isp_cas_inrange:
	clr.l		%d0			# clear return result
	lea		_CASHI(%pc),%a1		# load end of CAS core code
	cmp.l		%a1,%a0			# is PC in range?
	blt.b		cin_no			# no
	lea		_CASLO(%pc),%a1		# load begin of CAS core code
	cmp.l		%a0,%a1			# is PC in range?
	blt.b		cin_no			# no
	rts					# yes; return d0 = 0
cin_no:	
	mov.l		&-0x1,%d0		# out of range; return d0 = -1
	rts

#################################################################
#################################################################
#################################################################
# This is the start of the cas and cas2 "core" emulation code.	#
# This is the section that may need to be replaced by the host	#
# OS if it is too operating system-specific.			#
# Please refer to the package documentation to see how to	#
# "replace" this section, if necessary.				#
#################################################################
#################################################################
#################################################################

#       ######      ##      ######     ####
#       #	   #  #     #         #    #
#	#	  ######    ######        #
#	#	  #    #         #      #
#       ######    #    #    ######    ######

#########################################################################
# XDEF ****************************************************************	#
#	_isp_cas2(): "core" emulation code for the cas2 instruction	#
#									#
# XREF ****************************************************************	#
#	_isp_cas2_finish() - only exit point for this emulation code;	#
#			     do clean-up; calculate ccodes; store 	#
#			     Compare Ops if appropriate.		#
#									#
# INPUT ***************************************************************	#
#	*see chart below*						#
# 									#
# OUTPUT **************************************************************	#
#	*see chart below*						#
#									#
# ALGORITHM ***********************************************************	#
#	(1) Make several copies of the effective address.		#
#	(2) Save current SR; Then mask off all maskable interrupts.	#
#	(3) Save current SFC/DFC (ASSUMED TO BE EQUAL!!!); Then set 	#
#	    according to whether exception occurred in user or 		#
#	    supervisor mode.						#
#	(4) Use "plpaw" instruction to pre-load ATC with effective	#
#	    address pages(s). THIS SHOULD NOT FAULT!!! The relevant	#
#	    page(s) should have already been made resident prior to	#
# 	    entering this routine.					#
#	(5) Push the operand lines from the cache w/ "cpushl". 		#
#	    In the 68040, this was done within the locked region. In	#
# 	    the 68060, it is done outside of the locked region.		#
#	(6) Use "plpar" instruction to do a re-load of ATC entries for	#
#	    ADDR1 since ADDR2 entries may have pushed ADDR1 out of the	#
#	    ATC.							#
#	(7) Pre-fetch the core emulation instructions by executing	#
#	    one branch within each physical line (16 bytes) of the code	#
#	    before actually executing the code.				#
#	(8) Load the BUSCR w/ the bus lock value.			#
#	(9) Fetch the source operands using "moves".			#
#	(10)Do the compares. If both equal, go to step (13).		#
#	(11)Unequal. No update occurs. But, we do write the DST1 op	#
#	    back to itself (as w/ the '040) so we can gracefully unlock	#
#	    the bus (and assert LOCKE*) using BUSCR and the final move.	#
#	(12)Exit.							#
#	(13)Write update operand to the DST locations. Use BUSCR to 	#
#	    assert LOCKE* for the final write operation.		#
#	(14)Exit.							#
#									#
# 	The algorithm is actually implemented slightly differently	#
# depending on the size of the operation and the misalignment of the 	#
# operands. A misaligned operand must be written in aligned chunks or	#
# else the BUSCR register control gets confused.			#
#									#
#########################################################################

#################################################################
# THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON		# 
# ENTERING _isp_cas2().						#
#								#
# D0 = xxxxxxxx							#
# D1 = xxxxxxxx							#
# D2 = cmp operand 1						#
# D3 = cmp operand 2						#
# D4 = update oper 1						#
# D5 = update oper 2						#
# D6 = 'xxxxxxff if supervisor mode; 'xxxxxx00 if user mode	#
# D7 = 'xxxxxxff if longword operation; 'xxxxxx00 if word 	#
# A0 = ADDR1							#
# A1 = ADDR2							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

#	align		0x1000
# beginning label used by _isp_cas_inrange()
	global		_CASLO
_CASLO:

	global		_isp_cas2
_isp_cas2:
	tst.b		%d6			# user or supervisor mode?
	bne.b		cas2_supervisor		# supervisor
cas2_user:
	movq.l		&0x1,%d0		# load user data fc
	bra.b		cas2_cont
cas2_supervisor:
	movq.l		&0x5,%d0		# load supervisor data fc
cas2_cont:
	tst.b		%d7			# word or longword?
	beq.w		cas2w			# word

####
cas2l:
	mov.l		%a0,%a2			# copy ADDR1
	mov.l		%a1,%a3			# copy ADDR2
	mov.l		%a0,%a4			# copy ADDR1
	mov.l		%a1,%a5			# copy ADDR2

	addq.l		&0x3,%a4		# ADDR1+3
	addq.l		&0x3,%a5		# ADDR2+3
	mov.l		%a2,%d1			# ADDR1

# mask interrupts levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# store new SFC
	movc		%d0,%dfc		# store new DFC

# pre-load the operand ATC. no page faults should occur here because
# _real_lock_page() should have taken care of this.
	plpaw		(%a2)			# load atc for ADDR1
	plpaw		(%a4)			# load atc for ADDR1+3
	plpaw		(%a3)			# load atc for ADDR2
	plpaw		(%a5)			# load atc for ADDR2+3

# push the operand lines from the cache if they exist.
	cpushl		%dc,(%a2)		# push line for ADDR1
	cpushl		%dc,(%a4)		# push line for ADDR1+3
	cpushl		%dc,(%a3)		# push line for ADDR2
	cpushl		%dc,(%a5)		# push line for ADDR2+2

	mov.l		%d1,%a2			# ADDR1
	addq.l		&0x3,%d1
	mov.l		%d1,%a4			# ADDR1+3
# if ADDR1 was ATC resident before the above "plpaw" and was executed
# and it was the next entry scheduled for replacement and ADDR2
# shares the same set, then the "plpaw" for ADDR2 can push the ADDR1
# entries from the ATC. so, we do a second set of "plpa"s.
	plpar		(%a2)			# load atc for ADDR1
	plpar		(%a4)			# load atc for ADDR1+3

# load the BUSCR values.
	mov.l		&0x80000000,%a2		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a3		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a4		# buscr unlock value

# there are three possible mis-aligned cases for longword cas. they
# are separated because the final write which asserts LOCKE* must
# be aligned.
	mov.l		%a0,%d0			# is ADDR1 misaligned?
	andi.b		&0x3,%d0
	beq.b		CAS2L_ENTER		# no
	cmpi.b		%d0,&0x2
	beq.w		CAS2L2_ENTER		# yes; word misaligned
	bra.w		CAS2L3_ENTER		# yes; byte misaligned

#
# D0 = dst operand 1 <-
# D1 = dst operand 2 <-
# D2 = cmp operand 1
# D3 = cmp operand 2
# D4 = update oper 1
# D5 = update oper 2
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR1
# A1 = ADDR2
# A2 = bus LOCK*  value
# A3 = bus LOCKE* value
# A4 = bus unlock value
# A5 = xxxxxxxx
#
	align 		0x10
CAS2L_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.l		(%a1),%d1		# fetch Dest2[31:0]
	movs.l		(%a0),%d0		# fetch Dest1[31:0]
	bra.b 		CAS2L_CONT
CAS2L_ENTER:
	bra.b		~+16

CAS2L_CONT:
	cmp.l	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2L_NOUPDATE
	cmp.l	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2L_NOUPDATE
	movs.l		%d5,(%a1)		# Update2[31:0] -> DEST2
	bra.b 		CAS2L_UPDATE
	bra.b		~+16

CAS2L_UPDATE:
	movc		%a3,%buscr		# assert LOCKE*
	movs.l		%d4,(%a0)		# Update1[31:0] -> DEST1
	movc		%a4,%buscr		# unlock the bus
	bra.b		cas2l_update_done
	bra.b		~+16

CAS2L_NOUPDATE:
	movc		%a3,%buscr		# assert LOCKE*
	movs.l		%d0,(%a0)		# Dest1[31:0] -> DEST1
	movc		%a4,%buscr		# unlock the bus
	bra.b		cas2l_noupdate_done
	bra.b		~+16

CAS2L_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CAS2L_START

####

#################################################################
# THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	# 
# ENTERING _isp_cas2().						#
#								#
# D0 = destination[31:0] operand 1				#
# D1 = destination[31:0] operand 2				#
# D2 = cmp[31:0] operand 1					#
# D3 = cmp[31:0] operand 2					#
# D4 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	#
# D5 = xxxxxxxx							#
# D6 = xxxxxxxx							#
# D7 = xxxxxxxx							#
# A0 = xxxxxxxx							#
# A1 = xxxxxxxx							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

cas2l_noupdate_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	sf		%d4			# indicate no update was done
	bra.l		_isp_cas2_finish

cas2l_update_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	st		%d4			# indicate update was done
	bra.l		_isp_cas2_finish
####

	align 		0x10
CAS2L2_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.l		(%a1),%d1		# fetch Dest2[31:0]
	movs.l		(%a0),%d0		# fetch Dest1[31:0]
	bra.b 		CAS2L2_CONT
CAS2L2_ENTER:
	bra.b		~+16

CAS2L2_CONT:
	cmp.l	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2L2_NOUPDATE
	cmp.l	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2L2_NOUPDATE
	movs.l		%d5,(%a1)		# Update2[31:0] -> Dest2
	bra.b 		CAS2L2_UPDATE
	bra.b		~+16

CAS2L2_UPDATE:
	swap		%d4			# get Update1[31:16]
	movs.w		%d4,(%a0)+		# Update1[31:16] -> DEST1
	movc		%a3,%buscr		# assert LOCKE*
	swap		%d4			# get Update1[15:0]
	bra.b		CAS2L2_UPDATE2
	bra.b		~+16

CAS2L2_UPDATE2:
	movs.w		%d4,(%a0)		# Update1[15:0] -> DEST1+0x2
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2l_update_done
	nop
	bra.b		~+16

CAS2L2_NOUPDATE:
	swap		%d0			# get Dest1[31:16]
	movs.w		%d0,(%a0)+		# Dest1[31:16] -> DEST1
	movc		%a3,%buscr		# assert LOCKE*
	swap		%d0			# get Dest1[15:0]
	bra.b		CAS2L2_NOUPDATE2
	bra.b		~+16

CAS2L2_NOUPDATE2:
	movs.w		%d0,(%a0)		# Dest1[15:0] -> DEST1+0x2
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2l_noupdate_done
	nop
	bra.b		~+16

CAS2L2_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CAS2L2_START

#################################

	align 		0x10
CAS2L3_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.l		(%a1),%d1		# fetch Dest2[31:0]
	movs.l		(%a0),%d0		# fetch Dest1[31:0]
	bra.b 		CAS2L3_CONT
CAS2L3_ENTER:
	bra.b		~+16

CAS2L3_CONT:
	cmp.l	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2L3_NOUPDATE
	cmp.l	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2L3_NOUPDATE
	movs.l		%d5,(%a1)		# Update2[31:0] -> DEST2
	bra.b 		CAS2L3_UPDATE
	bra.b		~+16

CAS2L3_UPDATE:
	rol.l		&0x8,%d4		# get Update1[31:24]
	movs.b		%d4,(%a0)+		# Update1[31:24] -> DEST1
	swap		%d4			# get Update1[23:8]
	movs.w		%d4,(%a0)+		# Update1[23:8] -> DEST1+0x1
	bra.b		CAS2L3_UPDATE2
	bra.b		~+16

CAS2L3_UPDATE2:
	rol.l		&0x8,%d4		# get Update1[7:0]
	movc		%a3,%buscr		# assert LOCKE*
	movs.b		%d4,(%a0)		# Update1[7:0] -> DEST1+0x3
	bra.b		CAS2L3_UPDATE3
	nop
	bra.b		~+16

CAS2L3_UPDATE3:
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2l_update_done
	nop
	nop
	nop
	bra.b		~+16
	
CAS2L3_NOUPDATE:
	rol.l		&0x8,%d0		# get Dest1[31:24]
	movs.b		%d0,(%a0)+		# Dest1[31:24] -> DEST1
	swap		%d0			# get Dest1[23:8]
	movs.w		%d0,(%a0)+		# Dest1[23:8] -> DEST1+0x1
	bra.b		CAS2L3_NOUPDATE2
	bra.b		~+16

CAS2L3_NOUPDATE2:
	rol.l		&0x8,%d0		# get Dest1[7:0]
	movc		%a3,%buscr		# assert LOCKE*
	movs.b		%d0,(%a0)		# Update1[7:0] -> DEST1+0x3
	bra.b		CAS2L3_NOUPDATE3
	nop
	bra.b		~+16

CAS2L3_NOUPDATE3:
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2l_noupdate_done
	nop
	nop
	nop
	bra.b		~+14

CAS2L3_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	bra.w		CAS2L3_START

#############################################################
#############################################################

cas2w:
	mov.l		%a0,%a2			# copy ADDR1
	mov.l		%a1,%a3			# copy ADDR2
	mov.l		%a0,%a4			# copy ADDR1
	mov.l		%a1,%a5			# copy ADDR2

	addq.l		&0x1,%a4		# ADDR1+1
	addq.l		&0x1,%a5		# ADDR2+1
	mov.l		%a2,%d1			# ADDR1

# mask interrupt levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# store new SFC
	movc		%d0,%dfc		# store new DFC

# pre-load the operand ATC. no page faults should occur because
# _real_lock_page() should have taken care of this.
	plpaw		(%a2)			# load atc for ADDR1
	plpaw		(%a4)			# load atc for ADDR1+1
	plpaw		(%a3)			# load atc for ADDR2
	plpaw		(%a5)			# load atc for ADDR2+1

# push the operand cache lines from the cache if they exist.
	cpushl		%dc,(%a2)		# push line for ADDR1
	cpushl		%dc,(%a4)		# push line for ADDR1+1
	cpushl		%dc,(%a3)		# push line for ADDR2
	cpushl		%dc,(%a5)		# push line for ADDR2+1

	mov.l		%d1,%a2			# ADDR1
	addq.l		&0x3,%d1
	mov.l		%d1,%a4			# ADDR1+3
# if ADDR1 was ATC resident before the above "plpaw" and was executed
# and it was the next entry scheduled for replacement and ADDR2
# shares the same set, then the "plpaw" for ADDR2 can push the ADDR1
# entries from the ATC. so, we do a second set of "plpa"s.
	plpar		(%a2)			# load atc for ADDR1
	plpar		(%a4)			# load atc for ADDR1+3

# load the BUSCR values.
	mov.l		&0x80000000,%a2		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a3		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a4		# buscr unlock value

# there are two possible mis-aligned cases for word cas. they
# are separated because the final write which asserts LOCKE* must
# be aligned.
	mov.l		%a0,%d0			# is ADDR1 misaligned?
	btst		&0x0,%d0
	bne.w		CAS2W2_ENTER		# yes
	bra.b		CAS2W_ENTER		# no

#
# D0 = dst operand 1 <-
# D1 = dst operand 2 <-
# D2 = cmp operand 1
# D3 = cmp operand 2
# D4 = update oper 1
# D5 = update oper 2
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR1
# A1 = ADDR2
# A2 = bus LOCK*  value
# A3 = bus LOCKE* value
# A4 = bus unlock value
# A5 = xxxxxxxx
#
	align 		0x10
CAS2W_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.w		(%a1),%d1		# fetch Dest2[15:0]
	movs.w		(%a0),%d0		# fetch Dest1[15:0]
	bra.b 		CAS2W_CONT2
CAS2W_ENTER:
	bra.b		~+16

CAS2W_CONT2:
	cmp.w	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2W_NOUPDATE
	cmp.w	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2W_NOUPDATE
	movs.w		%d5,(%a1)		# Update2[15:0] -> DEST2
	bra.b 		CAS2W_UPDATE
	bra.b		~+16

CAS2W_UPDATE:
	movc		%a3,%buscr		# assert LOCKE*
	movs.w		%d4,(%a0)		# Update1[15:0] -> DEST1
	movc		%a4,%buscr		# unlock the bus
	bra.b		cas2w_update_done
	bra.b		~+16

CAS2W_NOUPDATE:
	movc		%a3,%buscr		# assert LOCKE*
	movs.w		%d0,(%a0)		# Dest1[15:0] -> DEST1
	movc		%a4,%buscr		# unlock the bus
	bra.b		cas2w_noupdate_done
	bra.b		~+16

CAS2W_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CAS2W_START

####

#################################################################
# THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	# 
# ENTERING _isp_cas2().						#
#								#
# D0 = destination[15:0] operand 1				#
# D1 = destination[15:0] operand 2				#
# D2 = cmp[15:0] operand 1					#
# D3 = cmp[15:0] operand 2					#
# D4 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	#
# D5 = xxxxxxxx							#
# D6 = xxxxxxxx							#
# D7 = xxxxxxxx							#
# A0 = xxxxxxxx							#
# A1 = xxxxxxxx							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

cas2w_noupdate_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	sf		%d4			# indicate no update was done
	bra.l		_isp_cas2_finish

cas2w_update_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	st		%d4			# indicate update was done
	bra.l		_isp_cas2_finish
####

	align 		0x10
CAS2W2_START:
	movc		%a2,%buscr		# assert LOCK*
	movs.w		(%a1),%d1		# fetch Dest2[15:0]
	movs.w		(%a0),%d0		# fetch Dest1[15:0]
	bra.b 		CAS2W2_CONT2
CAS2W2_ENTER:
	bra.b		~+16

CAS2W2_CONT2:
	cmp.w	 	%d0,%d2			# Dest1 - Compare1
	bne.b		CAS2W2_NOUPDATE
	cmp.w	 	%d1,%d3			# Dest2 - Compare2
	bne.b		CAS2W2_NOUPDATE
	movs.w		%d5,(%a1)		# Update2[15:0] -> DEST2
	bra.b 		CAS2W2_UPDATE
	bra.b		~+16

CAS2W2_UPDATE:
	ror.l		&0x8,%d4		# get Update1[15:8]
	movs.b		%d4,(%a0)+		# Update1[15:8] -> DEST1
	movc		%a3,%buscr		# assert LOCKE*
	rol.l		&0x8,%d4		# get Update1[7:0]
	bra.b		CAS2W2_UPDATE2
	bra.b		~+16

CAS2W2_UPDATE2:
	movs.b		%d4,(%a0)		# Update1[7:0] -> DEST1+0x1
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2w_update_done
	nop
	bra.b		~+16

CAS2W2_NOUPDATE:
	ror.l		&0x8,%d0		# get Dest1[15:8]
	movs.b		%d0,(%a0)+		# Dest1[15:8] -> DEST1
	movc		%a3,%buscr		# assert LOCKE*
	rol.l		&0x8,%d0		# get Dest1[7:0]
	bra.b		CAS2W2_NOUPDATE2
	bra.b		~+16

CAS2W2_NOUPDATE2:
	movs.b		%d0,(%a0)		# Dest1[7:0] -> DEST1+0x1
	movc		%a4,%buscr		# unlock the bus
	bra.w		cas2w_noupdate_done
	nop
	bra.b		~+16

CAS2W2_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CAS2W2_START

#       ######      ##      ######
#       #	   #  #     #     
#	#	  ######    ######
#	#	  #    #         #
#       ######    #    #    ######

#########################################################################
# XDEF ****************************************************************	#
# 	_isp_cas(): "core" emulation code for the cas instruction	#
#									#
# XREF ****************************************************************	#
#	_isp_cas_finish() - only exit point for this emulation code;	#
#			    do clean-up					#
#									#
# INPUT ***************************************************************	#
# 	*see entry chart below*						#
#									#
# OUTPUT **************************************************************	#
#	*see exit chart below*						#
#									#
# ALGORITHM ***********************************************************	#
# 	(1) Make several copies of the effective address. 		#
# 	(2) Save current SR; Then mask off all maskable interrupts.	#
#	(3) Save current DFC/SFC (ASSUMED TO BE EQUAL!!!); Then set	#
#	    SFC/DFC according to whether exception occurred in user or	#
#	    supervisor mode.						#
#	(4) Use "plpaw" instruction to pre-load ATC with efective	#
#	    address page(s). THIS SHOULD NOT FAULT!!! The relevant	#
# 	    page(s) should have been made resident prior to entering 	#
#	    this routine.						#
#	(5) Push the operand lines from the cache w/ "cpushl".		#
#	    In the 68040, this was done within the locked region. In	#
#	    the 68060, it is done outside of the locked region.		#
#	(6) Pre-fetch the core emulation instructions by executing one	#
#	    branch within each physical line (16 bytes) of the code	#
#	    before actually executing the code.				#
#	(7) Load the BUSCR with the bus lock value.			#
#	(8) Fetch the source operand.					#
#	(9) Do the compare. If equal, go to step (12).			#
#	(10)Unequal. No update occurs. But, we do write the DST op back	#
#	    to itself (as w/ the '040) so we can gracefully unlock	#
#	    the bus (and assert LOCKE*) using BUSCR and the final move.	#
#	(11)Exit.							#
#	(12)Write update operand to the DST location. Use BUSCR to	#
#	    assert LOCKE* for the final write operation.		#
#	(13)Exit.							#
# 									#
# 	The algorithm is actually implemented slightly diferently	#
# depending on the size of the operation and the misalignment of the	#
# operand. A misaligned operand must be written in aligned chunks or	#
# else the BUSCR register control gets confused.			#
#									#
#########################################################################

#########################################################
# THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON	#
# ENTERING _isp_cas().					#
#							#
# D0 = xxxxxxxx						#
# D1 = xxxxxxxx						#
# D2 = update operand					#
# D3 = xxxxxxxx						#
# D4 = compare operand					#
# D5 = xxxxxxxx						#
# D6 = supervisor ('xxxxxxff) or user mode ('xxxxxx00)	#
# D7 = longword ('xxxxxxff) or word size ('xxxxxx00)	#
# A0 = ADDR						#
# A1 = xxxxxxxx						#
# A2 = xxxxxxxx						#
# A3 = xxxxxxxx						#
# A4 = xxxxxxxx						#
# A5 = xxxxxxxx						#
# A6 = frame pointer					#
# A7 = stack pointer					#
#########################################################

	global		_isp_cas
_isp_cas:
	tst.b		%d6			# user or supervisor mode?
	bne.b		cas_super		# supervisor
cas_user:
	movq.l		&0x1,%d0		# load user data fc
	bra.b		cas_cont
cas_super:
	movq.l		&0x5,%d0		# load supervisor data fc

cas_cont:
	tst.b		%d7			# word or longword?
	bne.w		casl			# longword

####
casw:
	mov.l		%a0,%a1			# make copy for plpaw1
	mov.l		%a0,%a2			# make copy for plpaw2
	addq.l		&0x1,%a2		# plpaw2 points to end of word

	mov.l		%d2,%d3			# d3 = update[7:0]
	lsr.w		&0x8,%d2		# d2 = update[15:8]

# mask interrupt levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# load new sfc
	movc		%d0,%dfc		# load new dfc

# pre-load the operand ATC. no page faults should occur here because
# _real_lock_page() should have taken care of this.
	plpaw		(%a1)			# load atc for ADDR
	plpaw		(%a2)			# load atc for ADDR+1

# push the operand lines from the cache if they exist.
	cpushl		%dc,(%a1)		# push dirty data
	cpushl		%dc,(%a2)		# push dirty data

# load the BUSCR values.
	mov.l		&0x80000000,%a1		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a2		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a3		# buscr unlock value

# pre-load the instruction cache for the following algorithm.
# this will minimize the number of cycles that LOCK* will be asserted.
	bra.b		CASW_ENTER		# start pre-loading icache

#
# D0 = dst operand <-
# D1 = update[15:8] operand
# D2 = update[7:0]  operand
# D3 = xxxxxxxx
# D4 = compare[15:0] operand
# D5 = xxxxxxxx
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR
# A1 = bus LOCK*  value
# A2 = bus LOCKE* value
# A3 = bus unlock value
# A4 = xxxxxxxx
# A5 = xxxxxxxx
#
	align		0x10
CASW_START:
	movc		%a1,%buscr		# assert LOCK*
	movs.w		(%a0),%d0		# fetch Dest[15:0]
	cmp.w	 	%d0,%d4			# Dest - Compare
	bne.b		CASW_NOUPDATE
	bra.b 		CASW_UPDATE
CASW_ENTER:
	bra.b		~+16

CASW_UPDATE:
	movs.b		%d2,(%a0)+		# Update[15:8] -> DEST
	movc		%a2,%buscr		# assert LOCKE*
	movs.b		%d3,(%a0)		# Update[7:0] -> DEST+0x1
	bra.b		CASW_UPDATE2
	bra.b		~+16

CASW_UPDATE2:
	movc		%a3,%buscr		# unlock the bus
	bra.b		casw_update_done
	nop
	nop
	nop
	nop
	bra.b		~+16

CASW_NOUPDATE:
	ror.l		&0x8,%d0		# get Dest[15:8]
	movs.b		%d0,(%a0)+		# Dest[15:8] -> DEST
	movc		%a2,%buscr		# assert LOCKE*
	rol.l		&0x8,%d0		# get Dest[7:0]
	bra.b 		CASW_NOUPDATE2
	bra.b		~+16

CASW_NOUPDATE2:
	movs.b		%d0,(%a0)		# Dest[7:0] -> DEST+0x1
	movc		%a3,%buscr		# unlock the bus
	bra.b		casw_noupdate_done
	nop
	nop
	bra.b		~+16

CASW_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CASW_START

#################################################################
# THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	#
# CALLING _isp_cas_finish().					#
#								#
# D0 = destination[15:0] operand				#
# D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	#
# D2 = xxxxxxxx							#
# D3 = xxxxxxxx							#
# D4 = compare[15:0] operand					#
# D5 = xxxxxxxx							#
# D6 = xxxxxxxx							#
# D7 = xxxxxxxx							#
# A0 = xxxxxxxx							#
# A1 = xxxxxxxx							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

casw_noupdate_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	sf		%d1			# indicate no update was done
	bra.l		_isp_cas_finish

casw_update_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	st		%d1			# indicate update was done
	bra.l		_isp_cas_finish

################

# there are two possible mis-aligned cases for longword cas. they
# are separated because the final write which asserts LOCKE* must
# be an aligned write.
casl:
	mov.l		%a0,%a1			# make copy for plpaw1
	mov.l		%a0,%a2			# make copy for plpaw2
	addq.l		&0x3,%a2		# plpaw2 points to end of longword

	mov.l		%a0,%d1			# byte or word misaligned?
	btst		&0x0,%d1
	bne.w		casl2			# byte misaligned

	mov.l		%d2,%d3			# d3 = update[15:0]
	swap		%d2			# d2 = update[31:16]

# mask interrupts levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# load new sfc
	movc		%d0,%dfc		# load new dfc

# pre-load the operand ATC. no page faults should occur here because
# _real_lock_page() should have taken care of this.
	plpaw		(%a1)			# load atc for ADDR
	plpaw		(%a2)			# load atc for ADDR+3

# push the operand lines from the cache if they exist.
	cpushl		%dc,(%a1)		# push dirty data
	cpushl		%dc,(%a2)		# push dirty data

# load the BUSCR values.
	mov.l		&0x80000000,%a1		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a2		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a3		# buscr unlock value

	bra.b		CASL_ENTER		# start pre-loading icache

#
# D0 = dst operand <-
# D1 = xxxxxxxx
# D2 = update[31:16] operand
# D3 = update[15:0]  operand
# D4 = compare[31:0] operand
# D5 = xxxxxxxx
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR
# A1 = bus LOCK*  value
# A2 = bus LOCKE* value
# A3 = bus unlock value
# A4 = xxxxxxxx
# A5 = xxxxxxxx
#
	align		0x10
CASL_START:
	movc		%a1,%buscr		# assert LOCK*
	movs.l		(%a0),%d0		# fetch Dest[31:0]
	cmp.l	 	%d0,%d4			# Dest - Compare
	bne.b		CASL_NOUPDATE
	bra.b 		CASL_UPDATE
CASL_ENTER:
	bra.b		~+16

CASL_UPDATE:
	movs.w		%d2,(%a0)+		# Update[31:16] -> DEST
	movc		%a2,%buscr		# assert LOCKE*
	movs.w		%d3,(%a0)		# Update[15:0] -> DEST+0x2
	bra.b		CASL_UPDATE2
	bra.b		~+16

CASL_UPDATE2:
	movc		%a3,%buscr		# unlock the bus
	bra.b		casl_update_done
	nop
	nop
	nop
	nop
	bra.b		~+16

CASL_NOUPDATE:
	swap		%d0			# get Dest[31:16]
	movs.w		%d0,(%a0)+		# Dest[31:16] -> DEST
	swap		%d0			# get Dest[15:0]
	movc		%a2,%buscr		# assert LOCKE*
	bra.b 		CASL_NOUPDATE2
	bra.b		~+16

CASL_NOUPDATE2:
	movs.w		%d0,(%a0)		# Dest[15:0] -> DEST+0x2
	movc		%a3,%buscr		# unlock the bus
	bra.b		casl_noupdate_done
	nop
	nop
	bra.b		~+16

CASL_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CASL_START

#################################################################
# THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	#
# CALLING _isp_cas_finish().					#
#								#
# D0 = destination[31:0] operand				#
# D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	#
# D2 = xxxxxxxx							#
# D3 = xxxxxxxx							#
# D4 = compare[31:0] operand					#
# D5 = xxxxxxxx							#
# D6 = xxxxxxxx							#
# D7 = xxxxxxxx							#
# A0 = xxxxxxxx							#
# A1 = xxxxxxxx							#
# A2 = xxxxxxxx							#
# A3 = xxxxxxxx							#
# A4 = xxxxxxxx							#
# A5 = xxxxxxxx							#
# A6 = frame pointer						#
# A7 = stack pointer						#
#################################################################

casl_noupdate_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupt mask level.
	mov.w		%d7,%sr			# restore old SR

	sf		%d1			# indicate no update was done
	bra.l		_isp_cas_finish

casl_update_done:

# restore previous SFC/DFC value.
	movc		%d6,%sfc		# restore old SFC
	movc		%d6,%dfc		# restore old DFC

# restore previous interrupts mask level.
	mov.w		%d7,%sr			# restore old SR

	st		%d1			# indicate update was done
	bra.l		_isp_cas_finish

#######################################
casl2:
	mov.l		%d2,%d5			# d5 = Update[7:0]
	lsr.l		&0x8,%d2
	mov.l		%d2,%d3			# d3 = Update[23:8]
	swap		%d2			# d2 = Update[31:24]

# mask interrupts levels 0-6. save old mask value.
	mov.w		%sr,%d7			# save current SR
	ori.w		&0x0700,%sr		# inhibit interrupts

# load the SFC and DFC with the appropriate mode.
	movc		%sfc,%d6		# save old SFC/DFC
	movc		%d0,%sfc		# load new sfc
	movc		%d0,%dfc		# load new dfc

# pre-load the operand ATC. no page faults should occur here because
# _real_lock_page() should have taken care of this already.
	plpaw		(%a1)			# load atc for ADDR
	plpaw		(%a2)			# load atc for ADDR+3

# puch the operand lines from the cache if they exist.
	cpushl		%dc,(%a1)		# push dirty data
	cpushl		%dc,(%a2)		# push dirty data

# load the BUSCR values.
	mov.l		&0x80000000,%a1		# assert LOCK* buscr value
	mov.l		&0xa0000000,%a2		# assert LOCKE* buscr value
	mov.l		&0x00000000,%a3		# buscr unlock value

# pre-load the instruction cache for the following algorithm. 
# this will minimize the number of cycles that LOCK* will be asserted.
	bra.b		CASL2_ENTER		# start pre-loading icache

#
# D0 = dst operand <-
# D1 = xxxxxxxx
# D2 = update[31:24] operand
# D3 = update[23:8]  operand
# D4 = compare[31:0] operand
# D5 = update[7:0]  operand
# D6 = old SFC/DFC
# D7 = old SR
# A0 = ADDR
# A1 = bus LOCK*  value
# A2 = bus LOCKE* value
# A3 = bus unlock value
# A4 = xxxxxxxx
# A5 = xxxxxxxx
#
	align		0x10
CASL2_START:
	movc		%a1,%buscr		# assert LOCK*
	movs.l		(%a0),%d0		# fetch Dest[31:0]
	cmp.l	 	%d0,%d4			# Dest - Compare
	bne.b		CASL2_NOUPDATE
	bra.b 		CASL2_UPDATE
CASL2_ENTER:
	bra.b		~+16

CASL2_UPDATE:
	movs.b		%d2,(%a0)+		# Update[31:24] -> DEST
	movs.w		%d3,(%a0)+		# Update[23:8] -> DEST+0x1
	movc		%a2,%buscr		# assert LOCKE*
	bra.b		CASL2_UPDATE2
	bra.b		~+16

CASL2_UPDATE2:
	movs.b		%d5,(%a0)		# Update[7:0] -> DEST+0x3
	movc		%a3,%buscr		# unlock the bus
	bra.w		casl_update_done
	nop
	bra.b		~+16

CASL2_NOUPDATE:
	rol.l		&0x8,%d0		# get Dest[31:24]
	movs.b		%d0,(%a0)+		# Dest[31:24] -> DEST
	swap		%d0			# get Dest[23:8]
	movs.w		%d0,(%a0)+		# Dest[23:8] -> DEST+0x1
	bra.b 		CASL2_NOUPDATE2
	bra.b		~+16

CASL2_NOUPDATE2:
	rol.l		&0x8,%d0		# get Dest[7:0]
	movc		%a2,%buscr		# assert LOCKE*
	movs.b		%d0,(%a0)		# Dest[7:0] -> DEST+0x3
	bra.b 		CASL2_NOUPDATE3
	nop
	bra.b		~+16

CASL2_NOUPDATE3:
	movc		%a3,%buscr		# unlock the bus
	bra.w		casl_noupdate_done
	nop
	nop
	nop
	bra.b		~+16

CASL2_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b		CASL2_START

####
####
# end label used by _isp_cas_inrange()
	global		_CASHI
_CASHI:
@


1.0.1.2
log
@Amiga Port, PhxAss 3.x
Optimizing switches added
Beautified source
@
text
@d2 18
a19 15
**---------------------------------------------------------------------------
**  /\  |\     Silicon Department      Telefax     06404-64760
**  \_ o| \_ _  Software Entwicklung    Telefon        06404-7996
**    \|| |_)|)   Carsten Schlote         Egelseeweg 52     35423 Lich
** \__/||_/\_|     Branko Miki            Limmerstrasse 10   30451 Hannover
**--------------------------------------------------------------------------
*
;;
;; $Id: isp.asm,v 1.1 1996/02/11 20:00:05 schlote Exp $
;;
;; $Log: isp.asm,v $
;; Revision 1.1  1996/02/11  20:00:05  schlote
;; Amiga Port, PhxAss 3.x
;; Optimizing switches added
;; Beautified source
d24 24
a47 43
*
*
****************************************************************************
*
* ireal.s:
*	This file is appended to the top of the 060ISP package
* and contains the entry points into the package. The user, in
* effect, branches to one of the branch table entries located
* after _060ISP_TABLE.
*	Also, subroutine stubs exist in this file (_isp_done for
* example) that are referenced by the ISP package itself in order
* to call a given routine. The stub routine actually performs the
* callout. The ISP code does a "bsr" to the stub routine. This
* extra layer of hierarchy adds a slight performance penalty but
* it makes the ISP code easier to read and more mainatinable.
*
***************************************************************************
	MACHINE	MC68060
	OPT 0
_OUT	ds.b	80

_off_chk	equ	$00
_off_divbyzero	equ	$04
_off_trace	equ	$08
_off_access	equ	$0c
_off_done	equ	$10

_off_cas	equ	$14
_off_cas2	equ	$18
_off_lock	equ	$1c
_off_unlock	equ	$20

_off_imr	equ	$40
_off_dmr	equ	$44
_off_dmw	equ	$48
_off_irw	equ	$4c
_off_irl	equ	$50
_off_drb	equ	$54
_off_drw	equ	$58
_off_drl	equ	$5c
_off_dwb	equ	$60
_off_dww	equ	$64
_off_dwl	equ	$68
a48 1
***************************************************************************
d51 3
a53 1
* Here's the table of ENTRY POINTS for those linking the package.
a54 2
	bra.l		_isp_unimp
	cnop		0,8
d56 2
a57 1
	cnop		0,8
d59 2
a60 1
	cnop		0,8
d62 2
a63 1
	cnop		0,8
d65 2
a66 1
	cnop		0,8
d68 2
a69 1
	cnop		0,8
d71 2
a72 1
	cnop		0,8
d74 1
a74 2
	cnop		0,8
	ds.b		64
d76 1
a76 1
***************************************************************************
d78 1
a78 1
	opt !
d80 1
a80 1
	xdef  		_real_chk
d82 5
a86 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_chk,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d88 1
a88 1
	xdef  		_real_divbyzero
d90 5
a94 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_divbyzero,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d96 1
a96 1
	xdef  		_real_trace
d98 5
a102 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_trace,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d104 1
a104 1
	xdef  		_real_access
d106 5
a110 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_access,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d112 1
a112 1
	xdef  		_isp_done
d114 5
a118 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_done,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d120 1
a120 1
***************************************************************************
d122 1
a122 1
	xdef  		_real_cas
d124 5
a128 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_cas,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d130 1
a130 1
	xdef  		_real_cas2
d132 5
a136 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_cas2,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d138 1
a138 1
	xdef  		_real_lock_page
d140 5
a144 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_lock,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d146 1
a146 1
	xdef  		_real_unlock_page
d148 5
a152 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_unlock,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d154 1
a154 1
***************************************************************************
d156 1
a156 1
	xdef  		_imem_read
d158 5
a162 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_imr,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d164 1
a164 1
	xdef  		_dmem_read
d166 5
a170 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_dmr,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d172 1
a172 1
	xdef  		_dmem_write
d174 5
a178 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_dmw,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d180 1
a180 1
	xdef  		_imem_read_word
d182 5
a186 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_irw,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d188 1
a188 1
	xdef  		_imem_read_long
d190 5
a194 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_irl,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d196 1
a196 1
	xdef  		_dmem_read_byte
d198 5
a202 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_drb,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d204 1
a204 1
	xdef  		_dmem_read_word
d206 5
a210 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_drw,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d212 1
a212 1
	xdef  		_dmem_read_long
d214 5
a218 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_drl,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d220 1
a220 1
	xdef  		_dmem_write_byte
d222 5
a226 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_dwb,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d228 1
a228 1
	xdef  		_dmem_write_word
d230 5
a234 5
	move.l		d0,-(sp)
	move.l		(_OUT+_off_dww,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4
d236 1
a236 1
	xdef  		_dmem_write_long
d238 142
a379 152
	move.l		d0,-(sp)
	move.l		(_OUT+_off_dwl,pc),d0
	pea.l		(_OUT,pc,d0)
	move.l		$4(sp),d0
	rtd		#$4


***************************************************************************
*
* define statements for constants
* in oreder to promote readability within the core code itself.
*
***************************************************************************

		rsreset
                rs.l		1		* stack link register <a6> store
EXC_ISR		rs.w		1		* stack status register
EXC_IPC		rs.l		1		* stack pc
EXC_IVOFF	rs.l		1		* stacked vector offset


EXC_OPWORD	rs.w		1		* offset of current opword
EXC_EXTWORD	rs.w		1		* offset of current ext opword
EXC_EXTWPTR	rs.w		1		* offset of current PC
EXC_CC		rs.w		1		* offset of cc register

SPCOND_FLG	rs.b		1		* offset of spc condition flg
EXC_SAVREG	rs.b		1		* offset of old areg index
EXC_SAVVAL	rs.b		1		* offset of old areg value

		rsset		16
EXC_TEMP	rs.b		0		* offset of temp stack space

		rsset		32
EXC_DREGS	rs.l		0		* offset of all data regs
EXC_D7		rs.l		1		* offset of d7
EXC_D6		rs.l		1		* offset of d6
EXC_D5		rs.l		1		* offset of d5
EXC_D4		rs.l		1		* offset of d4
EXC_D3		rs.l		1		* offset of d3
EXC_D2		rs.l		1		* offset of d2
EXC_D1		rs.l		1		* offset of d1
EXC_D0		rs.l		1		* offset of d0

		rsset		64
EXC_AREGS	rs.b		0		* offset of all address regs
EXC_A0		rs.l		1		* offset of a0
EXC_A1		rs.l		1		* offset of a1
EXC_A2		rs.l		1		* offset of a2
EXC_A3		rs.l		1		* offset of a3
EXC_A4		rs.l		1		* offset of a4
EXC_A5		rs.l		1		* offset of a5
EXC_A6		rs.l		1		* offset of a6
EXC_A7		rs.l		1		* offset of a7

		rsset		96
LOCAL_SIZE	rs.b		0		* stack frame size(bytes)

***************************
* SPecial CONDition FLaGs *
***************************

mia7_flg	equ		$04			* (a7)+ flag
mda7_flg	equ		$08			* -(a7) flag
ichk_flg	equ		$10			* chk exception flag
idbyz_flg	equ		$20			* divbyzero flag
restore_flg	equ		$40			* restore -(an)+ flag
immed_flg	equ		$80			* immediate data flag

mia7_bit	equ		$2			* (a7)+ bit
mda7_bit	equ		$3			* -(a7) bit
ichk_bit	equ		$4			* chk exception bit
idbyz_bit	equ		$5			* divbyzero bit
restore_bit	equ		$6			* restore -(a7)+ bit
immed_bit	equ		$7			* immediate data bit

*********
* Misc. *
*********
BYTE	equ		1			* len(byte) == 1 byte
WORD	equ 		2			* len(word) == 2 bytes
LONG	equ 		4			* len(longword) == 4 bytes


*************************************************************************
* XDEF ****************************************************************	*
*	_isp_unimp(): 060ISP entry point for Unimplemented Instruction	*
*									*
*	This handler should be the first code executed upon taking the 	*
* 	"Unimplemented Integer Instruction" exception in an operating	*
*	system.								*
*									*
* XREF ****************************************************************	*
*	_imem_read_{word,long}() - read instruction word/longword	*
*	_mul64() - emulate 64-bit multiply				*
* 	_div64() - emulate 64-bit divide				*
*	_moveperipheral() - emulate "movep"				*
*	_compandset() - emulate misaligned "cas"			*
*	_compandset2() - emulate "cas2"					*
*	_chk2_cmp2() - emulate "cmp2" and "chk2"			*
*	_isp_done() - "callout" for normal final exit			*
*	_real_trace() - "callout" for Trace exception			*
*	_real_chk() - "callout" for Chk exception			*
*	_real_divbyzero() - "callout" for DZ exception			*
*	_real_access() - "callout" for access error exception		*
*									*
* INPUT ***************************************************************	*
*	- The system stack contains the Unimp Int Instr stack frame	*
* 									*
* OUTPUT **************************************************************	*
*	If Trace exception:						*
*	- The system stack changed to contain Trace exc stack frame	*
*	If Chk exception:						*
*	- The system stack changed to contain Chk exc stack frame	*
*	If DZ exception:						*
*	- The system stack changed to contain DZ exc stack frame	*
*	If access error exception:					*
*	- The system stack changed to contain access err exc stk frame	*
*	Else:								*
*	- Results saved as appropriate					*
*									*
* ALGORITHM ***********************************************************	*
*	This handler fetches the first instruction longword from	*
* memory and decodes it to determine which of the unimplemented		*
* integer instructions caused this exception. This handler then calls	*
* one of _mul64(), _div64(), _moveperipheral(), _compandset(), 		*
* _compandset2(), or _chk2_cmp2() as appropriate. 			*
*	Some of these instructions, by their nature, may produce other	*
* types of exceptions. "div" can produce a divide-by-zero exception,	*
* and "chk2" can cause a "Chk" exception. In both cases, the current	*
* exception stack frame must be converted to an exception stack frame	*
* of the correct exception type and an exit must be made through	*
* _real_divbyzero() or _real_chk() as appropriate. In addition, all	*
* instructions may be executing while Trace is enabled. If so, then	*
* a Trace exception stack frame must be created and an exit made 	*
* through _real_trace().						*
*	Meanwhile, if any read or write to memory using the		*
* _mem_{read,write}() "callout"s returns a failing value, then an	*
* access error frame must be created and an exit made through		*
* _real_access().							*
*	If none of these occur, then a normal exit is made through	*
* _isp_done().								*
*									*
*	This handler, upon entry, saves almost all user-visible 	*
* address and data registers to the stack. Although this may seem to	*
* cause excess memory traffic, it was found that due to having to	*
* access these register files for things like data retrieval and <ea>	*
* calculations, it was more efficient to have them on the stack where	*
* they could be accessed by indexing rather than to make subroutine 	*
* calls to retrieve a register of a particular index. 			*
*									*
*************************************************************************
d381 1
a381 2
	xdef  		_isp_unimp
	cnop		0,16
d383 1
a383 1
	link.w 		a6,#-LOCAL_SIZE			* create room for stack frame
d385 2
a386 2
	movem.l		d0-d7/a0-a5,EXC_DREGS(a6)	* store d0-d7/a0-a5
	move.l		(a6),EXC_A6(a6)			* store a6
d388 2
a389 2
	btst		#$5,EXC_ISR(a6)			* from s or u mode?
	bne.b		uieh_s				* supervisor mode
d391 2
a392 2
	move.l		usp,a0				* fetch user stack pointer
	move.l		a0,EXC_A7(a6)			* store a7
d395 2
a396 2
	lea		$c(a6),a0
	move.l		a0,EXC_A7(a6)			* store corrected sp
d398 1
a398 1
*******************************************************************************
d401 4
a404 1
	clr.b		SPCOND_FLG(a6)			* clear "special case" flag
d406 51
a456 52
	move.w		EXC_ISR(a6),EXC_CC(a6) 		* store cc copy on stack
	move.l		EXC_IPC(a6),EXC_EXTWPTR(a6) 	* store extwptr on stack
*
* fetch the opword and first extension word pointed to by the stacked pc
* and store them to the stack for now
*
	move.l		EXC_EXTWPTR(a6),a0		* fetch instruction addr
	addq.l		#$4,EXC_EXTWPTR(a6)		* incr instruction ptr
	bsr.l		_imem_read_long			* fetch opword # extword
	move.l		d0,EXC_OPWORD(a6)		* store extword on stack


*************************************************************************
* muls.l	0100 1100 00 |<ea>|	0*** 1100 0000 0*** 		*
* mulu.l	0100 1100 00 |<ea>|	0*** 0100 0000 0***		*
*									*
* divs.l	0100 1100 01 |<ea>|	0*** 1100 0000 0***		*
* divu.l	0100 1100 01 |<ea>|	0*** 0100 0000 0***		*
*									*
* movep.w m2r	0000 ***1 00 001***	| <displacement>  |		*
* movep.l m2r	0000 ***1 01 001***	| <displacement>  |		*
* movep.w r2m	0000 ***1 10 001***	| <displacement>  |		*
* movep.l r2m	0000 ***1 11 001***	| <displacement>  |		*
*									*
* cas.w		0000 1100 11 |<ea>|	0000 000* **00 0***		*
* cas.l		0000 1110 11 |<ea>|	0000 000* **00 0***		*
*									*
* cas2.w	0000 1100 11 111100	**** 000* **00 0***		*
*					**** 000* **00 0***		*
* cas2.l	0000 1110 11 111100	**** 000* **00 0***		*
*					**** 000* **00 0***		*
*									*
* chk2.b	0000 0000 11 |<ea>|	**** 1000 0000 0000		*
* chk2.w	0000 0010 11 |<ea>|	**** 1000 0000 0000		*
* chk2.l	0000 0100 11 |<ea>|	**** 1000 0000 0000		*
*									*
* cmp2.b	0000 0000 11 |<ea>|	**** 0000 0000 0000		*
* cmp2.w	0000 0010 11 |<ea>|	**** 0000 0000 0000		*
* cmp2.l	0000 0100 11 |<ea>|	**** 0000 0000 0000		*
*************************************************************************

*
* using bit 14 of the operation word, separate into 2 groups:
* (group1) mul64, div64
* (group2) movep, chk2, cmp2, cas2, cas
*
	btst		#$1e,d0				* group1 or group2
	beq.b		uieh_group2			* go handle group2
*
* now, w/ group1, make mul64's decode the fastest since it will
* most likely be used the most.
*
d458 2
a459 2
	btst		#$16,d0				* test for div64
	bne.b		uieh_div64			* go handle div64
d462 1
a462 1
* mul64() may use ()+ addressing and may, therefore, alter a7
d464 1
a464 1
	bsr.l		_mul64				* _mul64()
d466 1
a466 1
	btst		#$5,EXC_ISR(a6)			* supervisor mode?
d468 5
a472 5
	btst		#mia7_bit,SPCOND_FLG(a6) 	* was a7 changed?
	beq.w		uieh_done			* no
	btst		#$7,EXC_ISR(a6)			* is trace enabled?
	bne.w		uieh_trace_a7			* yes
	bra.w		uieh_a7				* no
d475 2
a476 2
* div64() may use ()+ addressing and may, therefore, alter a7.
* div64() may take a divide by zero exception.
d478 1
a478 1
	bsr.l		_div64				* _div64()
d480 3
a482 3
* here, we sort out all of the special cases that may have happened.
	btst		#mia7_bit,SPCOND_FLG(a6) 	* was a7 changed?
	bne.b		uieh_div64_a7			* yes
d484 3
a486 3
	btst		#idbyz_bit,SPCOND_FLG(a6) 	* did divide-by-zero occur?
	bne.w		uieh_divbyzero			* yes
	bra.w		uieh_done			* no
d488 18
a505 19
	btst		#$5,EXC_ISR(a6)			* supervisor mode?
	beq.b		uieh_div64_dbyz			* no

* here, a7 has been incremented by 4 bytes in supervisor mode. we still
* may have the following 3 cases:
*	(i)	(a7)+
*	(ii)	(a7)+; trace
*	(iii)	(a7)+; divide-by-zero
*
	btst		#idbyz_bit,SPCOND_FLG(a6) 	* did divide-by-zero occur?
	bne.w		uieh_divbyzero_a7		* yes
	tst.b		EXC_ISR(a6)			* no; is trace enabled?
	bmi.w		uieh_trace_a7			* yes
	bra.w		uieh_a7				* no

*
* now, w/ group2, make movep's decode the fastest since it will
* most likely be used the most.
*
d507 1
a507 1
	btst		#$18,d0				* test for not movep
d511 1
a511 1
	bsr.l		_moveperipheral			* _movep()
d515 2
a516 2
	btst		#$1b,d0				* test for chk2,cmp2
	beq.b		uieh_chk2cmp2			* go handle chk2,cmp2
d518 3
a520 3
	swap		d0				* put opword in lo word
	cmp.b	 	#$fc,d0				* test for cas2
	beq.b		uieh_cas2			* go handle cas2
d524 1
a524 1
	bsr.l		_compandset			* _cas()
d526 2
a527 2
* the cases of "cas Dc,Du,(a7)+" and "cas Dc,Du,-(a7)" used from supervisor
* mode are simply not considered valid and therefore are not handled.
d533 3
a535 3
	move.l		EXC_EXTWPTR(a6),a0		* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)		* incr instruction ptr
	bsr.l		_imem_read_word			* read extension word
d537 2
a538 2
	tst.l		d1				* ifetch error?
	bne.w		isp_iacc			* yes
d540 1
a540 1
	bsr.l		_compandset2			* _cas2()
d544 1
d546 1
a546 5
* chk2 may take a chk exception

	bsr.l		_chk2_cmp2			* _chk2_cmp2()

* here we check to see if a chk trap should be taken
d548 2
a549 1
	cmp.b		#ichk_flg,SPCOND_FLG(a6)
d553 1
a553 1
***************************************************************************
d555 4
a558 4
*
* the required emulation has been completed. now, clean up the necessary stack
* info and prepare for rte
*
d560 1
a560 1
	move.b		EXC_CC+1(a6),EXC_ISR+1(a6) * insert new ccodes
d562 5
a566 3
* if exception occurred in user mode, then we have to restore a7 in case it
* changed. we don't have to update a7  for supervisor mose because that case
* doesn't flow through here
d568 2
a569 5
	btst		#$5,EXC_ISR(a6)			* user or supervisor?
	bne.b		uieh_finish			* supervisor

	move.l		EXC_A7(a6),a0			* fetch user stack pointer
	move.l		a0,usp				* restore it
d572 1
a572 1
	movem.l		EXC_DREGS(a6),d0-d7/a0-a5 	* restore d0-d7/a0-a5
d574 2
a575 2
	btst		#$7,EXC_ISR(a6)			* is trace mode on?
	bne.b		uieh_trace			* yes;go handle trace mode
d577 3
a579 3
	move.l		EXC_EXTWPTR(a6),EXC_IPC(a6) 	* new pc on stack frame
	move.l		EXC_A6(a6),(a6)			* prepare new a6 for unlink
	unlk		a6				* unlink stack frame
d581 26
a606 25
*
* The instruction that was just emulated was also being traced. The trace
* trap for this instruction will be lost unless we jump to the trace handler.
* So, here we create a Trace Exception format number two exception stack
* frame from the Unimplemented Integer Intruction Exception stack frame
* format number zero and jump to the user supplied hook "_real_trace()".
*
*		   UIEH FRAME		   TRACE FRAME
*		*****************	*****************
*		* $0 *  $0f4	*	*    Current	*
*		*****************	*      PC	*
*		*    Current	*	*****************
*		*      PC 	*	* $2 *  $024	*
*		*****************	*****************
*		*      SR	*	*     Next	*
*		*****************	*      PC	*
*	      ->*     Old   	*	*****************
*  from link -->*      A6	*	*      SR	*
*	        *****************	*****************
*	       /*      A7	*	*      New	* <-- for final unlink
*	      / *		*	*      A6	*
* link frame <  *****************	*****************
*	      \ ~		~	~		~
*	       \*****************	*****************
*
d608 7
a614 7
	move.l		EXC_A6(a6),-$4(a6)
	move.w		EXC_ISR(a6),$0(a6)
	move.l		EXC_IPC(a6),$8(a6)
	move.l		EXC_EXTWPTR(a6),$2(a6)
	move.w		#$2024,$6(a6)
	sub.l		#$4,a6
	unlk		a6
d617 19
a635 19
*
*	   UIEH FRAME		    CHK FRAME
*	*****************	*****************
*	* $0 *  $0f4	*	*    Current	*
*	*****************	*      PC	*
*	*    Current	*	*****************
*	*      PC	*	* $2 *  $018	*
*	*****************	*****************
*	*      SR	*	*     Next	*
*	*****************	*      PC	*
*	    (4 words)		*****************
*				*      SR	*
*				*****************
*				    (6 words)
*
* the chk2 instruction should take a chk trap. so, here we must create a
* chk stack frame from an unimplemented integer instruction exception frame
* and jump to the user supplied entry point "_real_chk()".
*
d637 2
a638 2
	move.b		EXC_CC+1(a6),EXC_ISR+1(a6) 	* insert new ccodes
	movem.l		EXC_DREGS(a6),d0-d7/a0-a5	* restore d0-d7/a0-a5
d640 4
a643 4
	move.w		EXC_ISR(a6),(a6)		* put new SR on stack
	move.l		EXC_IPC(a6),$8(a6)		* put "Current PC" on stack
	move.l		EXC_EXTWPTR(a6),$2(a6) 		* put "Next PC" on stack
	move.w		#$2018,$6(a6)			* put Vector Offset on stack
d645 2
a646 2
	move.l		EXC_A6(a6),a6			* restore a6
	add.l		#LOCAL_SIZE,sp			* clear stack frame
d650 20
a669 20
*
*	   UIEH FRAME		 DIVBYZERO FRAME
*	*****************	*****************
*	* $0 *  $0f4	*	*    Current	*
*	*****************	*      PC	*
*	*    Current	*	*****************
*	*      PC	*	* $2 *  $014	*
*	*****************	*****************
*	*      SR	*	*     Next	*
*	*****************	*      PC	*
*	    (4 words)		*****************
*				*      SR	*
*				*****************
*				    (6 words)
*
* the divide instruction should take an integer divide by zero trap. so, here
* we must create a divbyzero stack frame from an unimplemented integer
* instruction exception frame and jump to the user supplied entry point
* "_real_divbyzero()".
*
d671 2
a672 2
	move.b		EXC_CC+1(a6),EXC_ISR+1(a6) 	* insert new ccodes
	movem.l		EXC_DREGS(a6),d0-d7/a0-a5	* restore d0-d7/a0-a5
d674 4
a677 4
	move.w		EXC_ISR(a6),(a6)		* put new SR on stack
	move.l		EXC_IPC(a6),$8(a6)		* put "Current PC" on stack
	move.l		EXC_EXTWPTR(a6),$2(a6) 		* put "Next PC" on stack
	move.w		#$2014,$6(a6)			* put Vector Offset on stack
d679 2
a680 2
	move.l		EXC_A6(a6),a6			* restore a6
	add.l		#LOCAL_SIZE,sp			* clear stack frame
d684 23
a706 23
*
*				 DIVBYZERO FRAME
*				*****************
*				*    Current	*
*	   UIEH FRAME		*      PC	*
*	*****************	*****************
*	* $0 *  $0f4	*	* $2 * $014	*
*	*****************	*****************
*	*    Current	*	*     Next	*
*	*      PC	*	*      PC	*
*	*****************	*****************
*	*      SR	*	*      SR	*
*	*****************	*****************
*	    (4 words)		    (6 words)
*
* the divide instruction should take an integer divide by zero trap. so, here
* we must create a divbyzero stack frame from an unimplemented integer
* instruction exception frame and jump to the user supplied entry point
* "_real_divbyzero()".
*
* However, we must also deal with the fact that (a7)+ was used from supervisor
* mode, thereby shifting the stack frame up 4 bytes.
*
d708 2
a709 2
	move.b		EXC_CC+1(a6),EXC_ISR+1(a6) 	* insert new ccodes
	movem.l		EXC_DREGS(a6),d0-d7/a0-a5	* restore d0-d7/a0-a5
d711 3
a713 3
	move.l		EXC_IPC(a6),$c(a6)		* put "Current PC" on stack
	move.w		#$2014,$a(a6)			* put Vector Offset on stack
	move.l		EXC_EXTWPTR(a6),$6(a6) 		* put "Next PC" on stack
d715 2
a716 2
	move.l		EXC_A6(a6),a6			* restore a6
	add.l		#4+LOCAL_SIZE,sp		* clear stack frame
d720 25
a744 25
*
*				   TRACE FRAME
*				*****************
*				*    Current	*
*	   UIEH FRAME		*      PC	*
*	*****************	*****************
*	* $0 *  $0f4	*	* $2 * $024	*
*	*****************	*****************
*	*    Current	*	*     Next	*
*	*      PC	*	*      PC	*
*	*****************	*****************
*	*      SR	*	*      SR	*
*	*****************	*****************
*	    (4 words)		    (6 words)
*
*
* The instruction that was just emulated was also being traced. The trace
* trap for this instruction will be lost unless we jump to the trace handler.
* So, here we create a Trace Exception format number two exception stack
* frame from the Unimplemented Integer Intruction Exception stack frame
* format number zero and jump to the user supplied hook "_real_trace()".
*
* However, we must also deal with the fact that (a7)+ was used from supervisor
* mode, thereby shifting the stack frame up 4 bytes.
*
d746 2
a747 2
	move.b		EXC_CC+1(a6),EXC_ISR+1(a6) 	* insert new ccodes
	movem.l		EXC_DREGS(a6),d0-d7/a0-a5	* restore d0-d7/a0-a5
d749 3
a751 3
	move.l		EXC_IPC(a6),$c(a6)		* put "Current PC" on stack
	move.w		#$2024,$a(a6)			* put Vector Offset on stack
	move.l		EXC_EXTWPTR(a6),$6(a6)  	* put "Next PC" on stack
d753 2
a754 2
	move.l		EXC_A6(a6),a6			* restore a6
	add.l		#4+LOCAL_SIZE,sp		* clear stack frame
d758 14
a771 14
*
*				   UIEH FRAME
*				*****************
*				* $0 * $0f4	*
*	   UIEH FRAME		*****************
*	*****************	*     Next	*
*	* $0 *  $0f4	*	*      PC	*
*	*****************	*****************
*	*    Current	*	*      SR	*
*	*      PC	*	*****************
*	*****************	    (4 words)
*	*      SR	*
*	*****************
*	    (4 words)
d773 2
a774 2
	move.b		EXC_CC+1(a6),EXC_ISR+1(a6) 	* insert new ccodes
	movem.l		EXC_DREGS(a6),d0-d7/a0-a5 	* restore d0-d7/a0-a5
d776 3
a778 3
	move.w		#$00f4,$e(a6)			* put Vector Offset on stack
	move.l		EXC_EXTWPTR(a6),$a(a6) 		* put "Next PC" on stack
	move.w		EXC_ISR(a6),$8(a6)		* put SR on stack
d780 2
a781 2
	move.l		EXC_A6(a6),a6			* restore a6
	add.l		#8+LOCAL_SIZE,sp		* clear stack frame
d784 1
a784 1
**********
d786 3
a788 3
* this is the exit point if a data read or write fails.
* a0 = failing address
* d0 = fslw
d790 2
a791 2
	move.l		a0,(a6)				* save address
	move.l		d0,-$4(a6)			* save partial fslw
d793 2
a794 2
	lea		-64(a6),sp
	movem.l		(sp)+,d0-d7/a0-a6 		* restore d0-d7/a0-a6
d796 6
a801 6
	move.l		$c(sp),-(sp)			* move voff,hi(pc)
	move.l		$4(sp),$10(sp)			* store fslw
	move.l		$c(sp),$4(sp)			* store sr,lo(pc)
	move.l		$8(sp),$c(sp)			* store address
	move.l		(sp)+,$4(sp)			* store voff,hi(pc)
	move.w		#$4008,$6(sp)			* store new voff
d805 7
a811 7
* this is the exit point if an instruction word read fails.
* FSLW:
*	misaligned = true
*	read = true
* 	size = word
* 	instruction = true
* 	software emulation error = true
d813 8
a820 8
	movem.l		EXC_DREGS(a6),d0-d7/a0-a5 	* restore d0-d7/a0-a5
	unlk		a6				* unlink frame
	sub.w		#$8,sp				* make room for acc frame
	move.l		$8(sp),(sp)			* store sr,lo(pc)
	move.w		$c(sp),$4(sp)			* store hi(pc)
	move.w		#$4008,$6(sp)			* store new voff
	move.l		$2(sp),$8(sp)			* store address (=pc)
	move.l		#$09428001,$c(sp)		* store fslw
d823 3
a825 3
	btst		#$5,(sp)			* user or supervisor?
	beq.b		isp_acc_exit2			* user
	bset		#$2,$d(sp)			* set supervisor TM bit
d827 1
a827 1
	bra.l		_real_access
d829 2
a830 2
* if the addressing mode was (an)+ or -(an), the address register must
* be restored to it's pre-exception value before entering _real_access.
d832 5
a836 5
	cmp.b		#restore_flg,SPCOND_FLG(a6)	* do we need a restore?
	bne.b		isp_restore_done		* no
	clr.l		d0
	move.b		EXC_SAVREG(a6),d0			* regno to restore
	move.l		EXC_SAVVAL(a6),(EXC_AREGS,a6,d0.l*4) 	* restore value
d840 55
a894 55
*************************************************************************
* XDEF ****************************************************************	*
*	_calc_ea(): routine to calculate effective address		*
*									*
* XREF ****************************************************************	*
* 	_imem_read_word() - read instruction word			*
* 	_imem_read_long() - read instruction longword			*
* 	_dmem_read_long() - read data longword (for memory indirect)	*
* 	isp_iacc() - handle instruction access error exception		*
*	isp_dacc() - handle data access error exception			*
*									*
* INPUT ***************************************************************	*
* 	d0 = number of bytes related to effective address (w,l)		*
*									*
* OUTPUT **************************************************************	*
*	If exiting through isp_dacc...					*
*		a0 = failing address					*
*		d0 = FSLW						*
*	elsif exiting though isp_iacc...				*
*		none							*
*	else								*
*		a0 = effective address					*
*									*
* ALGORITHM ***********************************************************	*
* 	The effective address type is decoded from the opword residing	*
* on the stack. A jump table is used to vector to a routine for the 	*
* appropriate mode. Since none of the emulated integer instructions	*
* uses byte-sized operands, only handle word and long operations.	*
*									*
* 	Dn,An	- shouldn't enter here					*
*	(An)	- fetch An value from stack				*
* 	-(An)	- fetch An value from stack; return decr value;		*
*		  place decr value on stack; store old value in case of	*
*		  future access error; if -(a7), set mda7_flg in 	*
*		  SPCOND_FLG						*
*	(An)+	- fetch An value from stack; return value;		*
*		  place incr value on stack; store old value in case of	*
*		  future access error; if (a7)+, set mia7_flg in	*
*		  SPCOND_FLG						*
*	(d16,An) - fetch An value from stack; read d16 using 		*
*		  _imem_read_word(); fetch may fail -> branch to	*
*		  isp_iacc()						*
*	(xxx).w,(xxx).l - use _imem_read_{word,long}() to fetch		*
*		  address; fetch may fail				*
*	*<data> - return address of immediate value; set immed_flg	*
*		  in SPCOND_FLG						*
*	(d16,PC) - fetch stacked PC value; read d16 using		*
*		  _imem_read_word(); fetch may fail -> branch to	*
*		  isp_iacc()						*
*	everything else - read needed displacements as appropriate w/	*
*		  _imem_read_{word,long}(); read may fail; if memory	*
* 		  indirect, read indirect address using			*
*		  _dmem_read_long() which may also fail			*
*									*
*************************************************************************
d896 1
a896 1
	xdef  		_calc_ea
d898 1
a898 1
	move.l		d0,a0			* move * bytes to a0
d900 12
a911 14
* MODE and REG are taken from the EXC_OPWORD.
	move.w		EXC_OPWORD(a6),d0	* fetch opcode word
	move.w		d0,d1			* make a copy

	andi.w		#$3f,d0			* extract mode field
	andi.l		#$7,d1			* extract reg  field

* jump to the corresponding function for each {MODE,REG} pair.

	move.w		((tbl_ea_mode).b,pc,d0.w*2),d0 	* fetch jmp distance
	jmp		((tbl_ea_mode).b,pc,d0.w*1) * jmp to correct ea mode
tbl_ea_mode_ill:
	illegal                         	* illegal opcode
	dc.w		64
d913 75
a987 75
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode

	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		-	tbl_ea_mode

	dc.w		addr_ind_a0		- 	tbl_ea_mode
	dc.w		addr_ind_a1		- 	tbl_ea_mode
	dc.w		addr_ind_a2		- 	tbl_ea_mode
	dc.w		addr_ind_a3 		- 	tbl_ea_mode
	dc.w		addr_ind_a4 		- 	tbl_ea_mode
	dc.w		addr_ind_a5 		- 	tbl_ea_mode
	dc.w		addr_ind_a6 		- 	tbl_ea_mode
	dc.w		addr_ind_a7 		- 	tbl_ea_mode

	dc.w		addr_ind_p_a0		- 	tbl_ea_mode
	dc.w		addr_ind_p_a1 		- 	tbl_ea_mode
	dc.w		addr_ind_p_a2 		- 	tbl_ea_mode
	dc.w		addr_ind_p_a3 		- 	tbl_ea_mode
	dc.w		addr_ind_p_a4 		- 	tbl_ea_mode
	dc.w		addr_ind_p_a5 		- 	tbl_ea_mode
	dc.w		addr_ind_p_a6 		- 	tbl_ea_mode
	dc.w		addr_ind_p_a7 		- 	tbl_ea_mode

	dc.w		addr_ind_m_a0 		- 	tbl_ea_mode
	dc.w		addr_ind_m_a1 		- 	tbl_ea_mode
	dc.w		addr_ind_m_a2 		- 	tbl_ea_mode
	dc.w		addr_ind_m_a3 		- 	tbl_ea_mode
	dc.w		addr_ind_m_a4 		- 	tbl_ea_mode
	dc.w		addr_ind_m_a5 		- 	tbl_ea_mode
	dc.w		addr_ind_m_a6 		- 	tbl_ea_mode
	dc.w		addr_ind_m_a7 		- 	tbl_ea_mode

	dc.w		addr_ind_disp_a0	- 	tbl_ea_mode
	dc.w		addr_ind_disp_a1 	- 	tbl_ea_mode
	dc.w		addr_ind_disp_a2 	- 	tbl_ea_mode
	dc.w		addr_ind_disp_a3 	- 	tbl_ea_mode
	dc.w		addr_ind_disp_a4 	- 	tbl_ea_mode
	dc.w		addr_ind_disp_a5 	- 	tbl_ea_mode
	dc.w		addr_ind_disp_a6 	- 	tbl_ea_mode
	dc.w		addr_ind_disp_a7	-	tbl_ea_mode

	dc.w		_addr_ind_ext 		- 	tbl_ea_mode
	dc.w		_addr_ind_ext 		- 	tbl_ea_mode
	dc.w		_addr_ind_ext 		- 	tbl_ea_mode
	dc.w		_addr_ind_ext 		- 	tbl_ea_mode
	dc.w		_addr_ind_ext 		- 	tbl_ea_mode
	dc.w		_addr_ind_ext 		- 	tbl_ea_mode
	dc.w		_addr_ind_ext 		- 	tbl_ea_mode
	dc.w		_addr_ind_ext 		- 	tbl_ea_mode

	dc.w		abs_short		- 	tbl_ea_mode
	dc.w		abs_long		- 	tbl_ea_mode
	dc.w		pc_ind			- 	tbl_ea_mode
	dc.w		pc_ind_ext		- 	tbl_ea_mode
	dc.w		immediate		- 	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		- 	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		- 	tbl_ea_mode
	dc.w		tbl_ea_mode_ill		- 	tbl_ea_mode

***********************************
* Address register indirect: (An) *
***********************************
d989 1
a989 1
	move.l		EXC_A0(a6),a0		* Get current a0
d993 1
a993 1
	move.l		EXC_A1(a6),a0		* Get current a1
d997 1
a997 1
	move.l		EXC_A2(a6),a0		* Get current a2
d1001 1
a1001 1
	move.l		EXC_A3(a6),a0		* Get current a3
d1005 1
a1005 1
	move.l		EXC_A4(a6),a0		* Get current a4
d1009 1
a1009 1
	move.l		EXC_A5(a6),a0		* Get current a5
d1013 1
a1013 1
	move.l		EXC_A6(a6),a0		* Get current a6
d1017 1
a1017 1
	move.l		EXC_A7(a6),a0		* Get current a7
d1020 3
a1022 3
*****************************************************
* Address register indirect w/ postincrement: (An)+ *
*****************************************************
d1024 8
a1031 8
	move.l		a0,d0			* copy no. bytes
	move.l		EXC_A0(a6),a0		* load current value
	add.l		a0,d0			* increment
	move.l		d0,EXC_A0(a6)		* save incremented value

	move.l		a0,EXC_SAVVAL(a6)	* save in case of access error
	move.b		#$0,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1035 8
a1042 8
	move.l		a0,d0			* copy no. bytes
	move.l		EXC_A1(a6),a0		* load current value
	add.l		a0,d0			* increment
	move.l		d0,EXC_A1(a6)		* save incremented value

	move.l		a0,EXC_SAVVAL(a6)	* save in case of access error
	move.b		#$1,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1046 8
a1053 8
	move.l		a0,d0			* copy no. bytes
	move.l		EXC_A2(a6),a0		* load current value
	add.l		a0,d0			* increment
	move.l		d0,EXC_A2(a6)		* save incremented value

	move.l		a0,EXC_SAVVAL(a6)	* save in case of access error
	move.b		#$2,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1057 8
a1064 8
	move.l		a0,d0			* copy no. bytes
	move.l		EXC_A3(a6),a0		* load current value
	add.l		a0,d0			* increment
	move.l		d0,EXC_A3(a6)		* save incremented value

	move.l		a0,EXC_SAVVAL(a6)	* save in case of access error
	move.b		#$3,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1068 8
a1075 8
	move.l		a0,d0			* copy no. bytes
	move.l		EXC_A4(a6),a0		* load current value
	add.l		a0,d0			* increment
	move.l		d0,EXC_A4(a6)		* save incremented value

	move.l		a0,EXC_SAVVAL(a6)	* save in case of access error
	move.b		#$4,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1079 8
a1086 8
	move.l		a0,d0			* copy no. bytes
	move.l		EXC_A5(a6),a0		* load current value
	add.l		a0,d0			* increment
	move.l		d0,EXC_A5(a6)		* save incremented value

	move.l		a0,EXC_SAVVAL(a6)	* save in case of access error
	move.b		#$5,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1090 8
a1097 8
	move.l		a0,d0			* copy no. bytes
	move.l		EXC_A6(a6),a0		* load current value
	add.l		a0,d0			* increment
	move.l		d0,EXC_A6(a6)		* save incremented value

	move.l		a0,EXC_SAVVAL(a6)	* save in case of access error
	move.b		#$6,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1101 1
a1101 1
	move.b		#mia7_flg,SPCOND_FLG(a6) * set "special case" flag
d1103 4
a1106 4
	move.l		a0,d0			* copy no. bytes
	move.l		EXC_A7(a6),a0		* load current value
	add.l		a0,d0			* increment
	move.l		d0,EXC_A7(a6)		* save incremented value
d1109 3
a1111 3
****************************************************
* Address register indirect w/ predecrement: -(An) *
****************************************************
d1113 5
a1117 5
	move.l		EXC_A0(a6),d0		* Get current a0
	move.l		d0,EXC_SAVVAL(a6)	* save in case of access error
	sub.l		a0,d0			* Decrement
	move.l		d0,EXC_A0(a6)		* Save decr value
	move.l		d0,a0
d1119 2
a1120 2
	move.b		#$0,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1124 5
a1128 5
	move.l		EXC_A1(a6),d0		* Get current a1
	move.l		d0,EXC_SAVVAL(a6)	* save in case of access error
	sub.l		a0,d0			* Decrement
	move.l		d0,EXC_A1(a6)		* Save decr value
	move.l		d0,a0
d1130 2
a1131 2
	move.b		#$1,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1135 5
a1139 5
	move.l		EXC_A2(a6),d0		* Get current a2
	move.l		d0,EXC_SAVVAL(a6)	* save in case of access error
	sub.l		a0,d0			* Decrement
	move.l		d0,EXC_A2(a6)		* Save decr value
	move.l		d0,a0
d1141 2
a1142 2
	move.b		#$2,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1146 5
a1150 5
	move.l		EXC_A3(a6),d0		* Get current a3
	move.l		d0,EXC_SAVVAL(a6)	* save in case of access error
	sub.l		a0,d0			* Decrement
	move.l		d0,EXC_A3(a6)		* Save decr value
	move.l		d0,a0
d1152 2
a1153 2
	move.b		#$3,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1157 5
a1161 5
	move.l		EXC_A4(a6),d0		* Get current a4
	move.l		d0,EXC_SAVVAL(a6)	* save in case of access error
	sub.l		a0,d0			* Decrement
	move.l		d0,EXC_A4(a6)		* Save decr value
	move.l		d0,a0
d1163 2
a1164 2
	move.b		#$4,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1168 5
a1172 5
	move.l		EXC_A5(a6),d0		* Get current a5
	move.l		d0,EXC_SAVVAL(a6)	* save in case of access error
	sub.l		a0,d0			* Decrement
	move.l		d0,EXC_A5(a6)		* Save decr value
	move.l		d0,a0
d1174 2
a1175 2
	move.b		#$5,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1179 5
a1183 5
	move.l		EXC_A6(a6),d0		* Get current a6
	move.l		d0,EXC_SAVVAL(a6)	* save in case of access error
	sub.l		a0,d0			* Decrement
	move.l		d0,EXC_A6(a6)		* Save decr value
	move.l		d0,a0
d1185 2
a1186 2
	move.b		#$6,EXC_SAVREG(a6)	* save regno, too
	move.b		#restore_flg,SPCOND_FLG(a6) * set flag
d1190 1
a1190 1
	move.b		#mda7_flg,SPCOND_FLG(a6) * set "special case" flag
d1192 4
a1195 4
	move.l		EXC_A7(a6),d0		* Get current a7
	sub.l		a0,d0			* Decrement
	move.l		d0,EXC_A7(a6)		* Save decr value
	move.l		d0,a0
d1198 3
a1200 3
********************************************************
* Address register indirect w/ displacement: (d16, An) *
********************************************************
d1202 2
a1203 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1206 2
a1207 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1209 2
a1210 2
	move.w		d0,a0			* sign extend displacement
	add.l		EXC_A0(a6),a0		* a0 + d16
d1214 2
a1215 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1218 2
a1219 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1221 2
a1222 2
	move.w		d0,a0			* sign extend displacement
	add.l		EXC_A1(a6),a0		* a1 + d16
d1226 2
a1227 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1230 2
a1231 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1233 2
a1234 2
	move.w		d0,a0			* sign extend displacement
	add.l		EXC_A2(a6),a0		* a2 + d16
d1238 2
a1239 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1242 2
a1243 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1245 2
a1246 2
	move.w		d0,a0			* sign extend displacement
	add.l		EXC_A3(a6),a0		* a3 + d16
d1250 2
a1251 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1254 2
a1255 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1257 2
a1258 2
	move.w		d0,a0			* sign extend displacement
	add.l		EXC_A4(a6),a0		* a4 + d16
d1262 2
a1263 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1266 2
a1267 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1269 2
a1270 2
	move.w		d0,a0			* sign extend displacement
	add.l		EXC_A5(a6),a0		* a5 + d16
d1274 2
a1275 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1278 2
a1279 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1281 2
a1282 2
	move.w		d0,a0			* sign extend displacement
	add.l		EXC_A6(a6),a0		* a6 + d16
d1286 2
a1287 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1290 2
a1291 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1293 2
a1294 2
	move.w		d0,a0			* sign extend displacement
	add.l		EXC_A7(a6),a0		* a7 + d16
d1297 6
a1302 6
************************************************************************
* Address register indirect w/ index(8-bit displacement): (dn, An, Xn) *
*    "       "         "    w/   "  (base displacement): (bd, An, Xn)  *
* Memory indirect postindexed: ([bd, An], Xn, od)		       *
* Memory indirect preindexed: ([bd, An, Xn], od)		       *
************************************************************************
d1304 1
a1304 1
	move.l		d1,-(sp)
d1306 3
a1308 3
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
	bsr.l		_imem_read_word		* fetch extword in d0
d1310 2
a1311 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1313 1
a1313 1
	move.l		(sp)+,d1
d1315 1
a1315 1
	move.l		(EXC_AREGS,a6,d1.w*4),a0 * put base in a0
d1317 2
a1318 2
	btst		#$8,d0
	beq.b		addr_ind_index_8bit	* for ext word or not?
d1320 1
a1320 1
	movem.l		d2-d5,-(sp)		* save d2-d5
d1322 2
a1323 4
	move.l		d0,d5			* put extword in d5
	move.l		a0,d3			* put base in d3

	bra.l		calc_mem_ind		* calc memory indirect
d1325 2
d1328 1
a1328 1
	move.l		d2,-(sp)		* save old d2
d1330 3
a1332 3
	move.l		d0,d1
	rol.w		#$4,d1
	andi.w		#$f,d1			* extract index regno
d1334 1
a1334 1
	move.l		(EXC_DREGS,a6,d1.w*4),d1 * fetch index reg value
d1336 1
a1336 1
	btst		#$b,d0			* is it word or long?
d1338 1
a1338 1
	ext.l		d1			* sign extend word index
d1340 20
a1359 20
	move.l		d0,d2
	rol.w		#$7,d2
	andi.l		#$3,d2			* extract scale value

	lsl.l		d2,d1			* shift index by scale

	extb.l		d0			* sign extend displacement
	add.l		d1,d0			* index + disp
	add.l		d0,a0			* An + (index + disp)

	move.l		(sp)+,d2		* restore old d2
	rts

**********************
* Immediate: *<data> *
*************************************************************************
* word, long: <ea> of the data is the current extension word		*
* 	pointer value. new extension word pointer is simply the old	*
* 	plus the number of bytes in the data type(2 or 4).		*
*************************************************************************
d1361 1
a1361 1
	move.b		#immed_flg,SPCOND_FLG(a6) * set immediate flag
d1363 1
a1363 1
	move.l		EXC_EXTWPTR(a6),a0	* fetch extension word ptr
d1366 3
a1368 3
***************************
* Absolute short: (XXX).W *
***************************
d1370 3
a1372 3
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
	bsr.l		_imem_read_word		* fetch short address
d1374 2
a1375 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1377 1
a1377 1
	move.w		d0,a0			* return <ea> in a0
d1380 3
a1382 3
**************************
* Absolute long: (XXX).L *
**************************
d1384 3
a1386 3
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$4,EXC_EXTWPTR(a6)	* incr instruction ptr
	bsr.l		_imem_read_long		* fetch long address
d1388 2
a1389 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1391 1
a1391 1
	move.l		d0,a0			* return <ea> in a0
d1394 3
a1396 3
*******************************************************
* Program counter indirect w/ displacement: (d16, PC) *
*******************************************************
d1398 3
a1400 6
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
	bsr.l		_imem_read_word		* fetch word displacement

	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1402 2
a1403 1
	move.w		d0,a0			* sign extend displacement
d1405 1
a1405 1
	add.l		EXC_EXTWPTR(a6),a0	* pc + d16
d1407 1
a1407 1
* _imem_read_word() increased the extwptr by 2. need to adjust here.
d1409 2
a1410 1
	subq.l		#$2,a0			* adjust <ea>
d1414 6
a1419 6
**********************************************************
* PC indirect w/ index(8-bit displacement): (d8, PC, An) *
* "     "     w/   "  (base displacement): (bd, PC, An)  *
* PC memory indirect postindexed: ([bd, PC], Xn, od)     *
* PC memory indirect preindexed: ([bd, PC, Xn], od)      *
**********************************************************
d1421 3
a1423 6
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
	bsr.l		_imem_read_word		* fetch ext word

	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1425 2
a1426 2
	move.l		EXC_EXTWPTR(a6),a0	* put base in a0
	subq.l		#$2,a0			* adjust base
d1428 2
a1429 2
	btst		#$8,d0			* is disp only 8 bits?
	beq.b		pc_ind_index_8bit	* yes
d1431 2
a1432 3
* the indexed addressing mode uses a base displacement of size
* word or long
	movem.l		d2-d5,-(sp)		* save d2-d5
d1434 3
a1436 2
	move.l		d0,d5			* put extword in d5
	move.l		a0,d3			* put base in d3
d1438 2
a1439 1
	bra.l		calc_mem_ind		* calc memory indirect
d1441 2
d1444 1
a1444 1
 	move.l		d2,-(sp)		* create a temp register
d1446 3
a1448 3
	move.l		d0,d1			* make extword copy
	rol.w		#$4,d1			* rotate reg num into place
	andi.w		#$f,d1			* extract register number
d1450 1
a1450 1
	move.l		(EXC_DREGS,a6,d1.w*4),d1 * fetch index reg value
d1452 3
a1454 3
	btst		#$b,d0			* is index word or long?
	bne.b		pii8_long		* long
	ext.l		d1			* sign extend word index
d1456 3
a1458 3
	move.l		d0,d2			* make extword copy
	rol.w		#$7,d2			* rotate scale value into place
	andi.l		#$3,d2			* extract scale value
d1460 1
a1460 1
	lsl.l		d2,d1			* shift index by scale
d1462 3
a1464 3
	extb.l		d0			* sign extend displacement
	add.l		d1,d0			* index + disp
	add.l		d0,a0			* An + (index + disp)
d1466 1
a1466 1
	move.l		(sp)+,d2		* restore temp register
d1470 3
a1472 3
* a5 = exc_extwptr	(xdef   to uaeh)
* a4 = exc_opword	(xdef   to uaeh)
* a3 = exc_dregs	(xdef   to uaeh)
d1474 4
a1477 4
* d2 = index		(internal "     "    )
* d3 = base		(internal "     "    )
* d4 = od		(internal "     "    )
* d5 = extword		(internal "     "    )
d1479 1
a1479 1
	btst		#$6,d5			* is the index suppressed?
d1481 1
a1481 1
	clr.l		d2			* yes, so index = 0
d1484 3
a1486 3
	bfextu		d5{16:4},d2
	move.l		(EXC_DREGS,a6,d2.w*4),d2
	btst		#$b,d5			* is index word or long?
d1488 1
a1488 1
	ext.l		d2
d1490 2
a1491 2
	bfextu		d5{21:2},d0
	lsl.l		d0,d2
d1493 1
a1493 1
	btst		#$7,d5			* is the bd suppressed?
d1495 1
a1495 1
	clr.l		d3
d1497 3
a1499 3
	bfextu		d5{26:2},d0		* get bd size
*	beq.l		_error			* if (size == 0) it's reserved
	cmp.b	 	#2,d0
d1503 2
a1504 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$4,EXC_EXTWPTR(a6)	* incr instruction ptr
d1506 3
a1508 3

	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1512 2
a1513 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1516 2
a1517 4
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes

	ext.l		d0			* sign extend bd
d1519 2
d1522 1
a1522 1
	add.l		d0,d3			* base += bd
d1524 1
a1524 1
	bfextu		d5{30:2},d0		* is od suppressed?
d1526 1
a1526 1
	cmp.b	 	#2,d0
d1529 3
a1531 3

	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$4,EXC_EXTWPTR(a6)	* incr instruction ptr
d1534 2
a1535 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1540 2
a1541 2
	move.l		EXC_EXTWPTR(a6),a0	* fetch instruction addr
	addq.l		#$2,EXC_EXTWPTR(a6)	* incr instruction ptr
d1544 2
a1545 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d1547 1
a1547 1
	ext.l		d0			* sign extend od
d1551 1
a1551 1
	clr.l		d0
d1553 2
a1554 2
	move.l		d0,d4
	btst		#$2,d5			* pre or post indexing?
d1557 1
a1557 1
	move.l		d3,a0
d1560 2
a1561 2
	tst.l		d1			* dfetch error?
	bne.b		calc_ea_err		* yes
d1563 2
a1564 2
	add.l		d2,d0			* <ea> += index
	add.l		d4,d0			* <ea> += od
d1568 2
a1569 2
	add.l		d2,d3			* preindexing
	move.l		d3,a0
d1572 2
a1573 2
	tst.l		d1			* ifetch error?
	bne.b		calc_ea_err		* yes
d1575 1
a1575 1
	add.l		d4,d0			* ea += od
d1579 2
a1580 2
	add.l		d2,d3			* ea = (base + bd) + index
	move.l		d3,d0
d1582 1
a1582 1
	move.l		d0,a0
d1584 1
a1584 1
	movem.l		(sp)+,d2-d5		* restore d2-d5
d1587 8
a1594 8
* if dmem_read_long() returns a fail message in d1, the package
* must create an access error frame. here, we pass a skeleton fslw
* and the failing address to the routine that creates the new frame.
* FSLW:
* 	read = true
* 	size = longword
*	TM = data
* 	software emulation error = true
d1596 2
a1597 2
	move.l		d3,a0			* pass failing address
	move.l		#$01010001,d0		* pass fslw
d1600 35
a1634 35
*************************************************************************
* XDEF **************************************************************** *
* 	_moveperipheral(): routine to emulate movep instruction		*
*									*
* XREF **************************************************************** *
*	_dmem_read_byte() - read byte from memory			*
*	_dmem_write_byte() - write byte to memory			*
*	isp_dacc() - handle data access error exception			*
*									*
* INPUT *************************************************************** *
*	none								*
*									*
* OUTPUT ************************************************************** *
*	If exiting through isp_dacc...					*
*		a0 = failing address					*
*		d0 = FSLW						*
*	else								*
*		none							*
*									*
* ALGORITHM ***********************************************************	*
*	Decode the movep instruction words stored at EXC_OPWORD and	*
* either read or write the required bytes from/to memory. Use the	*
* _dmem_{read,write}_byte() routines. If one of the memory routines	*
* returns a failing value, we must pass the failing address and	a FSLW	*
* to the _isp_dacc() routine.						*
*	Since this instruction is used to access peripherals, make sure	*
* to only access the required bytes.					*
*									*
*************************************************************************

***************************
* movep.(w,l)	Dx,(d,Ay) *
* movep.(w,l)	(d,Ay),Dx *
***************************
	xdef   		_moveperipheral
d1636 1
a1636 1
	move.w		EXC_OPWORD(a6),d1	* fetch the opcode word
d1638 2
a1639 2
	move.b		d1,d0
	and.w		#$7,d0			* extract Ay from opcode word
d1641 1
a1641 1
	move.l		(EXC_AREGS,a6,d0.w*4),a0 * fetch ay
d1643 1
a1643 1
	add.w		EXC_EXTWORD(a6),a0	* add: an + sgn_ext(disp)
d1645 1
a1645 1
	btst		#$7,d1			* (reg 2 mem) or (mem 2 reg)
d1648 1
a1648 1
* reg2mem: fetch dx, then write it to memory
d1650 3
a1652 3
	move.w		d1,d0
	rol.w		#$7,d0
	and.w		#$7,d0			* extract Dx from opcode word
d1654 1
a1654 1
	move.l		(EXC_DREGS,a6,d0.w*4), d0 * fetch dx
d1656 1
a1656 1
	btst		#$6,d1			* word or long operation?
d1659 2
a1660 2
* a0 = dst addr
* d0 = Dx
d1662 4
a1665 4
	move.l		d0,d2			* store data
	move.l		a0,a2			* store addr
	rol.l		#$8,d2
	move.l		d2,d0
d1667 1
a1667 1
	bsr.l		_dmem_write_byte	* os  : write hi
d1669 2
a1670 2
	tst.l		d1			* dfetch error?
	bne.w		movp_write_err		* yes
d1672 4
a1675 4
	add.w		#$2,a2			* incr addr
	move.l		a2,a0
	rol.l		#$8,d2
	move.l		d2,d0
d1677 1
a1677 1
	bsr.l		_dmem_write_byte	* os  : write lo
d1679 2
a1680 2
	tst.l		d1			* dfetch error?
	bne.w		movp_write_err		* yes
d1682 4
a1685 4
	add.w		#$2,a2			* incr addr
	move.l		a2,a0
	rol.l		#$8,d2
	move.l		d2,d0
d1687 1
a1687 1
	bsr.l		_dmem_write_byte	* os  : write lo
d1689 2
a1690 2
	tst.l		d1			* dfetch error?
	bne.w		movp_write_err		* yes
d1692 4
a1695 4
	add.w		#$2,a2			* incr addr
	move.l		a2,a0
	rol.l		#$8,d2
	move.l		d2,d0
d1697 1
a1697 1
	bsr.l		_dmem_write_byte	* os  : write lo
d1699 2
a1700 2
	tst.l		d1			* dfetch error?
	bne.w		movp_write_err		* yes
d1704 2
a1705 2
* a0 = dst addr
* d0 = Dx
d1707 3
a1709 3
	move.l		d0,d2			* store data
	move.l		a0,a2			* store addr
	lsr.w		#$8,d0
d1711 1
a1711 1
	bsr.l		_dmem_write_byte	* os  : write hi
d1713 2
a1714 2
	tst.l		d1			* dfetch error?
	bne.w		movp_write_err		* yes
d1716 3
a1718 3
	add.w		#$2,a2
	move.l		a2,a0
	move.l		d2,d0
d1720 1
a1720 1
	bsr.l		_dmem_write_byte	* os  : write lo
d1722 2
a1723 2
	tst.l		d1			* dfetch error?
	bne.w		movp_write_err		* yes
d1727 2
a1728 2
* mem2reg: read bytes from memory.
* determines the dest register, and then writes the bytes into it.
d1730 1
a1730 1
	btst		#$6,d1			* word or long operation?
d1733 1
a1733 1
* a0 = dst addr
d1735 1
a1735 1
	move.l		a0,a2			* store addr
d1737 1
a1737 1
	bsr.l		_dmem_read_byte		* read first byte
d1739 2
a1740 2
	tst.l		d1			* dfetch error?
	bne.w		movp_read_err		* yes
d1742 1
a1742 1
	move.l		d0,d2
d1744 2
a1745 2
	add.w		#$2,a2			* incr addr by 2 bytes
	move.l		a2,a0
d1747 1
a1747 1
	bsr.l		_dmem_read_byte		* read second byte
d1749 2
a1750 2
	tst.l		d1			* dfetch error?
	bne.w		movp_read_err		* yes
d1752 2
a1753 2
	lsl.w		#$8,d2
	move.b		d0,d2			* append bytes
d1755 2
a1756 2
	add.w		#$2,a2			* incr addr by 2 bytes
	move.l		a2,a0
d1758 1
a1758 1
	bsr.l		_dmem_read_byte		* read second byte
d1760 2
a1761 2
	tst.l		d1			* dfetch error?
	bne.w		movp_read_err		* yes
d1763 2
a1764 2
	lsl.l		#$8,d2
	move.b		d0,d2			* append bytes
d1766 2
a1767 2
	add.w		#$2,a2			* incr addr by 2 bytes
	move.l		a2,a0
d1769 1
a1769 1
	bsr.l		_dmem_read_byte		* read second byte
d1771 2
a1772 2
	tst.l		d1			* dfetch error?
	bne.w		movp_read_err		* yes
d1774 2
a1775 2
	lsl.l		#$8,d2
	move.b		d0,d2			* append bytes
d1777 5
a1781 5
	move.b		EXC_OPWORD(a6),d1
	lsr.b		#$1,d1
	and.w		#$7,d1			* extract Dx from opcode word

	move.l		d2,(EXC_DREGS,a6,d1.w*4) * store dx
d1784 2
a1785 2

* a0 = dst addr
d1787 1
a1787 3
	move.l		a0,a2			* store addr

	bsr.l		_dmem_read_byte		* read first byte
d1789 1
a1789 2
	tst.l		d1			* dfetch error?
	bne.w		movp_read_err		* yes
d1791 2
a1792 1
	move.l		d0,d2
d1794 1
a1794 2
	add.w		#$2,a2			* incr addr by 2 bytes
	move.l		a2,a0
d1796 2
a1797 1
	bsr.l		_dmem_read_byte		* read second byte
d1799 1
a1799 2
	tst.l		d1			* dfetch error?
	bne.w		movp_read_err		* yes
d1801 2
a1802 2
	lsl.w		#$8,d2
	move.b		d0,d2			* append bytes
d1804 2
a1805 3
	move.b		EXC_OPWORD(a6),d1
	lsr.b		#$1,d1
	and.w		#$7,d1			* extract Dx from opcode word
d1807 5
a1811 1
	move.w		d2,(EXC_DREGS+2,a6,d1.w*4) * store dx
d1815 8
a1822 8
* if dmem_{read,write}_byte() returns a fail message in d1, the package
* must create an access error frame. here, we pass a skeleton fslw
* and the failing address to the routine that creates the new frame.
* FSLW:
* 	write = true
*	size = byte
*	TM = data
*	software emulation error = true
d1824 2
a1825 2
	move.l		a2,a0			* pass failing address
	move.l		#$00a10001,d0		* pass fslw
d1828 5
a1832 5
* FSLW:
* 	read = true
*	size = byte
*	TM = data
*	software emulation error = true
d1834 2
a1835 2
	move.l		a2,a0			* pass failing address
	move.l		#$01210001,d0		* pass fslw
d1838 35
a1872 35
*************************************************************************
* XDEF ****************************************************************	*
* 	_chk2_cmp2(): routine to emulate chk2/cmp2 instructions		*
*									*
* XREF ****************************************************************	*
*	_calc_ea(): calculate effective address				*
*	_dmem_read_long(): read operands				*
* 	_dmem_read_word(): read operands				*
*	isp_dacc(): handle data access error exception			*
*									*
* INPUT ***************************************************************	*
*	none								*
*									*
* OUTPUT **************************************************************	*
*	If exiting through isp_dacc...					*
*		a0 = failing address					*
*		d0 = FSLW						*
*	else								*
* 		none							*
*									*
* ALGORITHM ***********************************************************	*
*	First, calculate the effective address, then fetch the byte,	*
* word, or longword sized operands. Then, in the interest of 		*
* simplicity, all operands are converted to longword size whether the 	*
* operation is byte, word, or long. The bounds are sign extended 	*
* accordingly. If Rn is a data regsiter, Rn is also sign extended. If 	*
* Rn is an address register, it need not be sign extended since the 	*
* full register is always used.						*
*	The comparisons are made and the condition codes calculated.	*
* If the instruction is chk2 and the Rn value is out-of-bounds, set	*
* the ichk_flg in SPCOND_FLG.						*
*	If the memory fetch returns a failing value, pass the failing 	*
* address and FSLW to the isp_dacc() routine.				*
*									*
*************************************************************************
d1874 1
a1874 1
	xdef   		_chk2_cmp2
d1877 13
a1889 13
* passing size parameter doesn't matter since chk2 # cmp2 can't do
* either predecrement, postincrement, or immediate.
	bsr.l		_calc_ea		* calculate <ea>

	move.b		EXC_EXTWORD(a6), d0	* fetch hi extension word
	rol.b		#$4, d0			* rotate reg bits into lo
	and.w		#$f, d0			* extract reg bits

	move.l		(EXC_DREGS,a6,d0.w*4), d2 * get regval

	cmp.b		#$2,EXC_OPWORD(a6)	* what size is operation?
	blt.b		chk2_cmp2_byte		* size == byte
	beq.b		chk2_cmp2_word		* size == word
d1891 2
a1892 2
* the bounds are longword size. call routine to read the lower
* bound into d0 and the higher bound into d1.
d1894 2
a1895 2
	move.l		a0,a2			* save copy of <ea>
	bsr.l		_dmem_read_long		* fetch long lower bound
d1897 2
a1898 2
	tst.l		d1			* dfetch error?
	bne.w		chk2_cmp2_err_l		* yes
d1900 15
a1914 15
	move.l		d0,d3			* save long lower bound
	addq.l		#$4,a2
	move.l		a2,a0			* pass <ea> of long upper bound
	bsr.l		_dmem_read_long		* fetch long upper bound

	tst.l		d1			* dfetch error?
	bne.w		chk2_cmp2_err_l		* yes

	move.l		d0,d1			* long upper bound in d1
	move.l		d3,d0			* long lower bound in d0
	bra.w		chk2_cmp2_compare	* go do the compare emulation

* the bounds are word size. fetch them in one subroutine call by
* reading a longword. sign extend both. if it's a data operation,
* sign extend Rn to long, also.
d1916 2
a1917 2
	move.l		a0,a2
	bsr.l		_dmem_read_long		* fetch 2 word bounds
d1919 2
a1920 2
	tst.l		d1			* dfetch error?
	bne.w		chk2_cmp2_err_l		* yes
d1922 2
a1923 2
	move.w		d0, d1			* place hi in d1
	swap		d0			* place lo in d0
d1925 2
a1926 2
	ext.l		d0			* sign extend lo bnd
	ext.l		d1			* sign extend hi bnd
d1928 2
a1929 2
	btst		#$7, EXC_EXTWORD(a6)	* address compare?
	bne.w		chk2_cmp2_compare	* yes; don't sign extend
d1931 4
a1934 4
* operation is a data register compare.
* sign extend word to long so we can do simple longword compares.
	ext.l		d2			* sign extend data word
	bra.w		chk2_cmp2_compare	* go emulate compare
d1936 3
a1938 3
* the bounds are byte size. fetch them in one subroutine call by
* reading a word. sign extend both. if it's a data operation,
* sign extend Rn to long, also.
d1940 2
a1941 2
	move.l		a0,a2
	bsr.l		_dmem_read_word		* fetch 2 byte bounds
d1943 2
a1944 2
	tst.l		d1			* dfetch error?
	bne.w		chk2_cmp2_err_w		* yes
d1946 2
a1947 2
	move.b		d0, d1			* place hi in d1
	lsr.w		#$8, d0			* place lo in d0
d1949 17
a1965 17
	extb.l		d0			* sign extend lo bnd
	extb.l		d1			* sign extend hi bnd

	btst		#$7, EXC_EXTWORD(a6)	* address compare?
	bne.b		chk2_cmp2_compare	* yes; don't sign extend

* operation is a data register compare.
* sign extend byte to long so we can do simple longword compares.
	extb.l		d2			* sign extend data byte

*
* To set the ccodes correctly:
* 	(1) save 'Z' bit from (Rn - lo)
*	(2) save 'Z' and 'N' bits from ((hi - lo) - (Rn - hi))
*	(3) keep 'X', 'N', and 'V' from before instruction
*	(4) combine ccodes
*
d1967 17
a1983 17
	sub.l		d0, d2			* (Rn - lo)
	move.w		ccr, d3			* fetch resulting ccodes
	andi.b		#$4, d3			* keep 'Z' bit
	sub.l		d0, d1			* (hi - lo)
	cmp.l	 	d1,d2			* ((hi - lo) - (Rn - hi))

	move.w		ccr, d4			* fetch resulting ccodes
	or.b		d4, d3			* combine w/ earlier ccodes
	andi.b		#$5, d3			* keep 'Z' and 'N'

	move.w		EXC_CC(a6), d4		* fetch old ccodes
	andi.b		#$1a, d4		* keep 'X','N','V' bits
	or.b		d3, d4			* insert new ccodes
	move.w		d4, EXC_CC(a6)		* save new ccodes

	btst		#$3, EXC_EXTWORD(a6)	* separate chk2,cmp2
	bne.b		chk2_finish		* it's a chk2
d1987 6
a1992 6
* this code handles the only difference between chk2 and cmp2. chk2 would
* have trapped out if the value was out of bounds. we check this by seeing
* if the 'N' bit was set by the operation.
chk2_finish:
	btst		#$0, d4			* is 'N' bit set?
	bne.b		chk2_trap		* yes;chk2 should trap
d1995 1
a1995 1
	move.b		#ichk_flg,SPCOND_FLG(a6) * set "special case" flag
d1998 8
a2005 8
* if dmem_read_{long,word}() returns a fail message in d1, the package
* must create an access error frame. here, we pass a skeleton fslw
* and the failing address to the routine that creates the new frame.
* FSLW:
*	read = true
*	size = longword
*	TM = data
* 	software emulation error = true
d2007 2
a2008 2
	move.l		a2,a0			* pass failing address
	move.l		#$01010001,d0		* pass fslw
d2011 5
a2015 5
* FSLW:
*	read = true
*	size = word
*	TM = data
* 	software emulation error = true
d2017 2
a2018 2
	move.l		a2,a0			* pass failing address
	move.l		#$01410001,d0		* pass fslw
d2021 49
a2069 49
*************************************************************************
* XDEF ****************************************************************	*
* 	_div64(): routine to emulate div{u,s}.l <ea>,Dr:Dq		*
*							64/32->32r:32q	*
*									*
* XREF ****************************************************************	*
*	_calc_ea() - calculate effective address			*
* 	isp_iacc() - handle instruction access error exception		*
*	isp_dacc() - handle data access error exception			*
*	isp_restore() - restore An on access error w/ -() or ()+	*
*									*
* INPUT ***************************************************************	*
*	none								*
*									*
* OUTPUT **************************************************************	*
* 	If exiting through isp_dacc...					*
*		a0 = failing address					*
* 		d0 = FSLW						*
*	else								*
*		none							*
*									*
* ALGORITHM ***********************************************************	*
* 	First, decode the operand location. If it's in Dn, fetch from	*
* the stack. If it's in memory, use _calc_ea() to calculate the 	*
* effective address. Use _dmem_read_long() to fetch at that address.	*
* Unless the operand is immediate data. Then use _imem_read_long().	*
* Send failures to isp_dacc() or isp_iacc() as appropriate.		*
*	If the operands are signed, make them unsigned and save	the 	*
* sign info for later. Separate out special cases like divide-by-zero	*
* or 32-bit divides if possible. Else, use a special math algorithm	*
* to calculate the result. 						*
*	Restore sign info if signed instruction. Set the condition 	*
* codes. Set idbyz_flg in SPCOND_FLG if divisor was zero. Store the 	*
* quotient and remainder in the appropriate data registers on the stack.*
*									*
*************************************************************************

NDIVISOR	equ	EXC_TEMP+$0
NDIVIDEND	equ	EXC_TEMP+$1
NDRSAVE		equ	EXC_TEMP+$2
NDQSAVE		equ	EXC_TEMP+$4
DDSECOND	equ	EXC_TEMP+$6
DDQUOTIENT	equ	EXC_TEMP+$8
DDNORMAL	equ	EXC_TEMP+$c

	xdef  		_div64
*************
* div(u,s)l *
*************
d2071 2
a2072 2
	move.b		EXC_OPWORD+1(a6), d0
	andi.b		#$38, d0			* extract src mode
d2074 1
a2074 1
	bne.w		dcontrolmodel_s			* dn dest or control mode?
d2076 3
a2078 3
	move.b		EXC_OPWORD+1(a6), d0		* extract Dn from opcode
	andi.w		#$7, d0
	move.l		(EXC_DREGS,a6,d0.w*4), d7 	* fetch divisor from register
d2081 1
a2081 1
	beq.w		div64eq0		* divisor is = 0!!!
d2083 20
a2102 20
	move.b		EXC_EXTWORD+1(a6), d0	* extract Dr from extword
	move.b		EXC_EXTWORD(a6), d1	* extract Dq from extword
	and.w		#$7, d0
	lsr.b		#$4, d1
	and.w		#$7, d1
	move.w		d0, NDRSAVE(a6)		* save Dr for later
	move.w		d1, NDQSAVE(a6)		* save Dq for later

* fetch dr and dq directly off stack since all regs are saved there
	move.l		(EXC_DREGS,a6,d0.w*4), d5 * get dividend hi
	move.l		(EXC_DREGS,a6,d1.w*4), d6 * get dividend lo

* separate signed and unsigned divide
	btst		#$3, EXC_EXTWORD(a6)	* signed or unsigned?
	beq.b		dspecialcases		* use positive divide

* save the sign of the divisor
* make divisor unsigned if it's negative
	tst.l		d7			* chk sign of divisor
	slt		NDIVISOR(a6)		* save sign of divisor
d2104 1
a2104 1
	neg.l		d7			* complement negative divisor
d2106 2
a2107 2
* save the sign of the dividend
* make dividend unsigned if it's negative
d2109 2
a2110 2
	tst.l		d5			* chk sign of hi(dividend)
	slt		NDIVIDEND(a6)		* save sign of dividend
d2113 7
a2119 7
	move.w		#$0, ccr		* clear 'X' cc bit
	negx.l		d6			* complement signed dividend
	negx.l		d5

* extract some special cases:
* 	- is (dividend == 0) ?
*	- is (hi(dividend) == 0 ## (divisor <= lo(dividend))) ? (32-bit div)
d2121 2
a2122 2
	tst.l		d5			* is (hi(dividend) == 0)
	bne.b		dnormaldivide		* no, so try it the long way
d2124 2
a2125 2
	tst.l		d6			* is (lo(dividend) == 0), too
	beq.w		ddone			* yes, so (dividend == 0)
d2127 2
a2128 2
	cmp.l	 	d7,d6			* is (divisor <= lo(dividend))
	bls.b		d32bitdivide		* yes, so use 32 bit divide
d2130 2
a2131 2
	exg		d5,d6			* q = 0, r = dividend
	bra.w		divfinish		* can't divide, we're done.
d2134 1
a2134 1
	divu.l		d7, d5:d6		* it's only a 32/32 bit div!
d2139 4
a2142 4
* last special case:
* 	- is hi(dividend) >= divisor ? if yes, then overflow
	cmp.l		d7,d5
	bls.b		ddovf			* answer won't fit in 32 bits
d2144 2
a2145 2
* perform the divide algorithm:
	bsr.l		dclassical		* do int divide
d2147 1
a2147 1
* separate into signed and unsigned finishes.
d2149 2
a2150 2
	btst		#$3, EXC_EXTWORD(a6)	* do divs, divu separately
	beq.b		ddone			* divu has no processing!!!
d2152 4
a2155 4
* it was a divs.l, so ccode setting is a little more complicated...
	tst.b		NDIVIDEND(a6)		* remainder has same sign
	beq.b		dcc			* as dividend.
	neg.l		d5			* sgn(rem) = sgn(dividend)
d2157 7
a2163 7
	move.b		NDIVISOR(a6), d0
	eor.b		d0, NDIVIDEND(a6)	* chk if quotient is negative
	beq.b		dqpos			* branch to quot positive

* $80000000 is the largest number representable as a 32-bit negative
* number. the negative of $80000000 is $80000000.
	cmp.l		#$80000000,d6		* will (-quot) fit in 32 bits?
d2166 1
a2166 1
	neg.l		d6			* make (-quot) 2's comp
d2171 1
a2171 1
	btst		#$1f, d6		* will (+quot) fit in 32 bits?
d2175 12
a2186 12
* at this point, result is normal so ccodes are set based on result.
	move.w		EXC_CC(a6), ccr
	tst.l		d6			* set ccrode bits
	move.w		ccr, EXC_CC(a6)

	move.w		NDRSAVE(a6), d0		* get Dr off stack
	move.w		NDQSAVE(a6), d1		* get Dq off stack

* if the register numbers are the same, only the quotient gets saved.
* so, if we always save the quotient second, we save ourselves a cmp#beq
	move.l		d5, (EXC_DREGS,a6,d0.w*4) * save remainder
	move.l		d6, (EXC_DREGS,a6,d1.w*4) * save quotient
d2191 2
a2192 2
	bset		#$1, EXC_CC+1(a6)	* 'V' set on overflow
	bclr		#$0, EXC_CC+1(a6)	* 'C' cleared on overflow
d2197 2
a2198 2
	andi.b		#$1e, EXC_CC+1(a6)	* clear 'C' bit on divbyzero
	ori.b		#idbyz_flg,SPCOND_FLG(a6) * set "special case" flag
d2201 15
a2215 15
***************************************************************************
*************************************************************************
* This routine uses the 'classical' Algorithm D from Donald Knuth's	*
* Art of Computer Programming, vol II, Seminumerical Algorithms.	*
* For this implementation b=2**16, and the target is U1U2U3U4/V1V2,	*
* where U,V are words of the quadword dividend and longword divisor,	*
* and U1, V1 are the most significant words.				*
* 									*
* The most sig. longword of the 64 bit dividend must be in d5, least 	*
* in d6. The divisor must be in the variable ddivisor, and the		*
* signed/unsigned flag ddusign must be set (0=unsigned,1=signed).	*
* The quotient is returned in d6, remainder in d5, unless the		*
* v (overflow) bit is set in the saved ccrr. If overflow, the dividend	*
* is unchanged.								*
*************************************************************************
d2217 2
a2218 2
* if the divisor msw is 0, use simpler algorithm then the full blown
* one at ddknuth:
d2220 2
a2221 2
	cmp.l		 #$ffff,d7
	bhi.b		ddknuth			* go use D. Knuth algorithm
d2223 27
a2249 27
* Since the divisor is only a word (and larger than the mslw of the dividend),
* a simpler algorithm may be used :
* In the general case, four quotient words would be created by
* dividing the divisor word into each dividend word. In this case,
* the first two quotient words must be zero, or overflow would occur.
* Since we already checked this case above, we can treat the most significant
* longword of the dividend as (0) remainder (see Knuth) and merely complete
* the last two divisions to get a quotient longword and word remainder:

	clr.l		d1
	swap		d5			* same as r*b if previous step rqd
	swap		d6			* get u3 to lsw position
	move.w		d6, d5			* rb + u3

	divu.w		d7, d5

	move.w		d5, d1			* first quotient word
	swap		d6			* get u4
	move.w		d6, d5			* rb + u4

	divu.w		d7, d5

	swap		d1
	move.w		d5, d1			* 2nd quotient 'digit'
	clr.w		d5
	swap		d5			* now remainder
	move.l		d1, d6			* and quotient
d2254 10
a2263 10
* In this algorithm, the divisor is treated as a 2 digit (word) number
* which is divided into a 3 digit (word) dividend to get one quotient
* digit (word). After subtraction, the dividend is shifted and the
* process repeated. Before beginning, the divisor and quotient are
* 'normalized' so that the process of estimating the quotient digit
* will yield verifiably correct results..

	clr.l		DDNORMAL(a6)		* count of shifts for normalization
	clr.b		DDSECOND(a6)		* clear flag for quotient digits
	clr.l		d1			* d1 will hold trial quotient
d2265 6
a2270 6
	btst		#31, d7			* must we normalize? first word of
	bne.b		ddnormalized		* divisor (V1) must be >= 65536/2
	addq.l		#$1, DDNORMAL(a6)	* count normalization shifts
	lsl.l		#$1, d7			* shift the divisor
	lsl.l		#$1, d6			* shift u4,u3 with overflow to u2
	roxl.l		#$1, d5			* shift u1,u2
d2274 7
a2280 7
* Now calculate an estimate of the quotient words (msw first, then lsw).
* The comments use subscripts for the first quotient digit determination.
	move.l		d7, d3			* divisor
	move.l		d5, d2			* dividend mslw
	swap		d2
	swap		d3
	cmp.w	 	d2, d3			* V1 = U1 ?
d2282 1
a2282 1
	move.w		#$ffff, d1		* use max trial quotient word
d2285 1
a2285 1
	move.l		d5, d1
d2287 1
a2287 1
	divu.w		d3, d1			* use quotient of mslw/msw
d2289 1
a2289 1
	andi.l		#$0000ffff, d1		* zero any remainder
d2292 13
a2304 13
* now test the trial quotient and adjust. This step plus the
* normalization assures (according to Knuth) that the trial
* quotient will be at worst 1 too large.
	move.l		d6, -(sp)
	clr.w		d6			* word u3 left
	swap		d6			* in lsw position
ddadj1: move.l		d7, d3
	move.l		d1, d2
	mulu.w		d7, d2			* V2q
	swap		d3
	mulu.w		d1, d3			* V1q
	move.l		d5, d4			* U1U2
	sub.l		d3, d4			* U1U2 - V1q
d2306 1
a2306 1
	swap		d4
d2308 2
a2309 2
	move.w		d4,d0
	move.w		d6,d4			* insert lower word (U3)
d2311 1
a2311 1
	tst.w		d0			* is upper word set?
d2314 1
a2314 1
*	add.l		d6, d4			* (U1U2 - V1q) + U3
d2316 3
a2318 3
	cmp.l	 	d2, d4
	bls.b		ddadjd1			* is V2q > (U1U2-V1q) + U3 ?
	subq.l		#$1, d1			* yes, decrement and recheck
d2321 6
a2326 6
* now test the word by multiplying it by the divisor (V1V2) and comparing
* the 3 digit (word) result with the current dividend words
	move.l		d5, -(sp)		* save d5 (d6 already saved)
	move.l		d1, d6
	swap		d6			* shift answer to ms 3 words
	move.l		d7, d5
d2328 21
a2348 21
	move.l		d5, d2			* now d2,d3 are trial*divisor
	move.l		d6, d3
	move.l		(sp)+, d5		* restore dividend
	move.l		(sp)+, d6
	sub.l		d3, d6
	subx.l		d2, d5			* subtract double precision
	bcc		dd2nd			* no carry, do next quotient digit
	subq.l		#$1, d1			* q is one too large
* need to add back divisor longword to current ms 3 digits of dividend
* - according to Knuth, this is done only 2 out of 65536 times for random
* divisor, dividend selection.
	clr.l		d2
	move.l		d7, d3
	swap		d3
	clr.w		d3			* d3 now ls word of divisor
	add.l		d3, d6			* aligned with 3rd word of dividend
	addx.l		d2, d5
	move.l		d7, d3
	clr.w		d3			* d3 now ms word of divisor
	swap		d3			* aligned with 2nd word of dividend
	add.l		d3, d5
d2350 1
a2350 1
	tst.b		DDSECOND(a6)		* both q words done?
d2352 9
a2360 9
* first quotient digit now correct. store digit and shift the
* (subtracted) dividend
	move.w		d1, DDQUOTIENT(a6)
	clr.l		d1
	swap		d5
	swap		d6
	move.w		d6, d5
	clr.w		d6
	st		DDSECOND(a6)		* second digit
d2363 7
a2369 7
* add 2nd word to quotient, get the remainder.
	move.w 		d1, DDQUOTIENT+2(a6)
* shift down one word/digit to renormalize remainder.
	move.w		d5, d6
	swap		d6
	swap		d5
	move.l		DDNORMAL(a6), d7	* get norm shift count
d2371 1
a2371 1
	subq.l		#$1, d7			* set for loop count
d2373 3
a2375 3
	lsr.l		#$1, d5			* shift into d6
	roxr.l		#$1, d6
	dbf		d7, ddnlp
d2377 2
a2378 2
	move.l		d6, d5			* remainder
	move.l		DDQUOTIENT(a6), d6 	* quotient
d2382 28
a2409 28
* factors for the 32X32->64 multiplication are in d5 and d6.
* returns 64 bit result in d5 (hi) d6(lo).
* destroys d2,d3,d4.

* multiply hi,lo words of each factor to get 4 intermediate products
	move.l		d6, d2
	move.l		d6, d3
	move.l		d5, d4
	swap		d3
	swap		d4
	mulu.w		d5, d6			* d6 <- lsw*lsw
	mulu.w		d3, d5			* d5 <- msw-dest*lsw-source
	mulu.w		d4, d2			* d2 <- msw-source*lsw-dest
	mulu.w		d4, d3			* d3 <- msw*msw
* now use swap and addx to consolidate to two longwords
	clr.l		d4
	swap		d6
	add.w		d5, d6			* add msw of l*l to lsw of m*l product
	addx.w		d4, d3			* add any carry to m*m product
	add.w		d2, d6			* add in lsw of other m*l product
	addx.w		d4, d3			* add any carry to m*m product
	swap		d6			* d6 is low 32 bits of final product
	clr.w		d5
	clr.w		d2			* lsw of two mixed products used,
	swap		d5			* now use msws of longwords
	swap		d2
	add.l		d2, d5
	add.l		d3, d5			* d5 now ms 32 bits of final product
d2412 1
a2412 1
**********
d2414 2
a2415 2
	moveq.l		#LONG,d0
	bsr.l		_calc_ea		* calc <ea>
d2417 2
a2418 2
	cmp.b		#immed_flg,SPCOND_FLG(a6) * immediate addressing mode?
	beq.b		dimmed			* yes
d2420 2
a2421 2
	move.l		a0,a2
	bsr.l		_dmem_read_long		* fetch divisor from <ea>
d2423 2
a2424 2
	tst.l		d1			* dfetch error?
	bne.b		div64_err		* yes
d2426 1
a2426 1
	move.l		d0, d7
d2429 3
a2431 3
* we have to split out immediate data here because it must be read using
* imem_read() instead of dmem_read(). this becomes especially important
* if the fetch runs into some deadly fault.
d2433 2
a2434 2
	addq.l		#$4,EXC_EXTWPTR(a6)
	bsr.l		_imem_read_long		* read immediate value
d2436 2
a2437 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d2439 1
a2439 1
	move.l		d0,d7
d2442 1
a2442 1
**********
d2444 10
a2453 10
* if dmem_read_long() returns a fail message in d1, the package
* must create an access error frame. here, we pass a skeleton fslw
* and the failing address to the routine that creates the new frame.
* also, we call isp_restore in case the effective addressing mode was
* (an)+ or -(an) in which case the previous "an" value must be restored.
* FSLW:
* 	read = true
* 	size = longword
*	TM = data
* 	software emulation error = true
d2455 3
a2457 3
	bsr.l		isp_restore		* restore addr reg
	move.l		a2,a0			* pass failing address
	move.l		#$01010001,d0		* pass fslw
d2460 38
a2497 38
*************************************************************************
* XDEF ****************************************************************	*
*	_mul64(): routine to emulate mul{u,s}.l <ea>,Dh:Dl 32x32->64	*
*									*
* XREF ****************************************************************	*
*	_calc_ea() - calculate effective address			*
*	isp_iacc() - handle instruction access error exception		*
* 	isp_dacc() - handle data access error exception			*
*	isp_restore() - restore An on access error w/ -() or ()+	*
*									*
* INPUT ***************************************************************	*
*	none								*
*									*
* OUTPUT **************************************************************	*
* 	If exiting through isp_dacc...					*
*		a0 = failing address					*
*		d0 = FSLW						*
* 	else								*
*		none							*
*									*
* ALGORITHM ***********************************************************	*
*	First, decode the operand location. If it's in Dn, fetch from	*
* the stack. If it's in memory, use _calc_ea() to calculate the		*
* effective address. Use _dmem_read_long() to fetch at that address.	*
* Unless the operand is immediate data. Then use _imem_read_long().	*
* Send failures to isp_dacc() or isp_iacc() as appropriate.		*
*	If the operands are signed, make them unsigned and save the 	*
* sign info for later. Perform the multiplication using 16x16->32	*
* unsigned multiplies and "add" instructions. Store the high and low 	*
* portions of the result in the appropriate data registers on the	*
* stack. Calculate the condition codes, also.				*
*									*
*************************************************************************

*************
* mul(u,s)l *
*************
	xdef  		_mul64
d2499 3
a2501 3
	move.b		EXC_OPWORD+1(a6), d0	* extract src {mode,reg}
	cmp.b		#$7,d0			* is src mode Dn or other?
	bgt.w		mul64_memop		* src is in memory
d2503 2
a2504 2
* multiplier operand in the the data register file.
* must extract the register number and fetch the operand from the stack.
d2506 2
a2507 2
	andi.w		#$7, d0			* extract Dn
	move.l		(EXC_DREGS,a6,d0.w*4), d3 * fetch multiplier
d2509 2
a2510 2
* multiplier is in d3. now, extract Dl and Dh fields and fetch the
* multiplicand from the data register specified by Dl.
d2512 25
a2536 25
	move.w		EXC_EXTWORD(a6), d2	* fetch ext word
	clr.w		d1			* clear Dh reg
	move.b		d2, d1			* grab Dh
	rol.w		#$4, d2			* align Dl byte
	andi.w		#$7, d2			* extract Dl

	move.l		(EXC_DREGS,a6,d2.w*4), d4 * get multiplicand

* check for the case of "zero" result early
	tst.l		d4			* test multiplicand
	beq.w		mul64_zero		* handle zero separately
	tst.l		d3			* test multiplier
	beq.w		mul64_zero		* handle zero separately

* multiplier is in d3 and multiplicand is in d4.
* if the operation is to be signed, then the operands are converted
* to unsigned and the result sign is saved for the end.
	clr.b		EXC_TEMP(a6)		* clear temp space
	btst		#$3, EXC_EXTWORD(a6)	* signed or unsigned?
	beq.b		mul64_alg		* unsigned; skip sgn calc

	tst.l		d3			* is multiplier negative?
	bge.b		mul64_chk_md_sgn	* no
	neg.l		d3			* make multiplier positive
	ori.b		#$1, EXC_TEMP(a6)	* save multiplier sgn
d2538 1
a2538 1
* the result sign is the exclusive or of the operand sign bits.
d2540 24
a2563 24
	tst.l		d4			* is multiplicand negative?
	bge.b		mul64_alg		* no
	neg.l		d4			* make multiplicand positive
	eori.b		#$1, EXC_TEMP(a6)	* calculate correct sign

*************************************************************************
*	63			   32				0	*
* 	----------------------------					*
* 	| hi(mplier) * hi(mplicand)|					*
* 	----------------------------					*
*		     -----------------------------			*
*		     | hi(mplier) * lo(mplicand) |			*
*		     -----------------------------			*
*		     -----------------------------			*
*		     | lo(mplier) * hi(mplicand) |			*
*		     -----------------------------			*
*	  |			   -----------------------------	*
*	--|--			   | lo(mplier) * lo(mplicand) |	*
*	  |			   -----------------------------	*
*	========================================================	*
*	--------------------------------------------------------	*
*	|	hi(result)	   |	    lo(result)         |	*
*	--------------------------------------------------------	*
*************************************************************************
d2565 40
a2604 41
* load temp registers with operands
	move.l		d3, d5			* mr in d5
	move.l		d3, d6			* mr in d6
	move.l		d4, d7			* md in d7
	swap		d6			* hi(mr) in lo d6
	swap		d7			* hi(md) in lo d7

* complete necessary multiplies:
	mulu.w		d4, d3			* [1] lo(mr) * lo(md)
	mulu.w		d6, d4			* [2] hi(mr) * lo(md)
	mulu.w		d7, d5			* [3] lo(mr) * hi(md)
	mulu.w		d7, d6			* [4] hi(mr) * hi(md)

* add lo portions of [2],[3] to hi portion of [1].
* add carries produced from these adds to [4].
* lo([1]) is the final lo 16 bits of the result.
	clr.l		d7			* load d7 w/ zero value
	swap		d3			* hi([1]) <==> lo([1])
	add.w		d4, d3			* hi([1]) + lo([2])
	addx.l		d7, d6			*    [4]  + carry
	add.w		d5, d3			* hi([1]) + lo([3])
	addx.l		d7, d6			*    [4]  + carry
	swap		d3			* lo([1]) <==> hi([1])

* lo portions of [2],[3] have been added in to final result.
* now, clear lo, put hi in lo reg, and add to [4]

	clr.w		d4			* clear lo([2])
	clr.w		d5			* clear hi([3])
	swap		d4			* hi([2]) in lo d4
	swap		d5			* hi([3]) in lo d5
	add.l		d5, d4			*    [4]  + hi([2])
	add.l		d6, d4			*    [4]  + hi([3])

* unsigned result is now in {d4,d3}
	tst.b		EXC_TEMP(a6)		* should result be signed?
	beq.b		mul64_done		* no

* result should be a signed negative number.
* compute 2's complement of the unsigned number:
*   -negate all bits and add 1
d2606 9
a2614 9
	not.l		d3			* negate lo(result) bits
	not.l		d4			* negate hi(result) bits
	addq.l		#1, d3			* add 1 to lo(result)
	addx.l		d7, d4			* add carry to hi(result)

* the result is saved to the register file.
* for '040 compatability, if Dl == Dh then only the hi(result) is
* saved. so, saving hi after lo accomplishes this without need to
* check Dl,Dh equality.
d2616 8
a2623 9
	move.l		d3, (EXC_DREGS,a6,d2.w*4) * save lo(result)
	move.w		#$0, ccr
	move.l		d4, (EXC_DREGS,a6,d1.w*4) * save hi(result)

* now, grab the condition codes. only one that can be set is 'N'.
* 'N' CAN be set if the operation is unsigned if bit 63 is set.

	move.w		ccr, d7			* fetch ccrr to see if 'N' set
	andi.b		#$8, d7			* extract 'N' bit
d2626 2
a2627 2
	move.b		EXC_CC+1(a6), d6 	* fetch previous ccrr
	andi.b		#$10, d6		* all but 'X' bit changes
d2629 2
a2630 2
	or.b		d7, d6			* group 'X' and 'N'
	move.b		d6, EXC_CC+1(a6)	* save new ccrr
d2634 2
a2635 2
* one or both of the operands is zero so the result is also zero.
* save the zero result to the register file and set the 'Z' ccode bit.
d2637 2
a2638 2
	clr.l		(EXC_DREGS,a6,d2.w*4) * save lo(result)
	clr.l		(EXC_DREGS,a6,d1.w*4) * save hi(result)
d2640 2
a2641 2
	moveq.l		#$4, d7			* set 'Z' ccode bit
	bra.b		mul64_ccode_set		* finish ccode set
d2643 1
a2643 1
**********
d2645 2
a2646 2
* multiplier operand is in memory at the effective address.
* must calculate the <ea> and go fetch the 32-bit operand.
d2648 2
a2649 2
	moveq.l		#LONG, d0		* pass * of bytes
	bsr.l		_calc_ea		* calculate <ea>
d2651 2
a2652 2
	cmp.b		#immed_flg,SPCOND_FLG(a6)	* immediate addressing mode?
	beq.b		mul64_immed			* yes
d2654 2
a2655 2
	move.l		a0,a2
	bsr.l		_dmem_read_long		* fetch src from addr (a0)
d2657 2
a2658 2
	tst.l		d1			* dfetch error?
	bne.w		mul64_err		* yes
d2660 1
a2660 1
	move.l		d0, d3			* store multiplier in d3
d2664 3
a2666 3
* we have to split out immediate data here because it must be read using
* imem_read() instead of dmem_read(). this becomes especially important
* if the fetch runs into some deadly fault.
d2668 2
a2669 2
	addq.l		#$4,EXC_EXTWPTR(a6)
	bsr.l		_imem_read_long		* read immediate value
d2671 2
a2672 2
	tst.l		d1			* ifetch error?
	bne.l		isp_iacc		* yes
d2674 1
a2674 1
	move.l		d0,d3
d2677 1
a2677 1
**********
d2679 10
a2688 10
* if dmem_read_long() returns a fail message in d1, the package
* must create an access error frame. here, we pass a skeleton fslw
* and the failing address to the routine that creates the new frame.
* also, we call isp_restore in case the effective addressing mode was
* (an)+ or -(an) in which case the previous "an" value must be restored.
* FSLW:
* 	read = true
* 	size = longword
*	TM = data
* 	software emulation error = true
d2690 3
a2692 3
	bsr.l		isp_restore		* restore addr reg
	move.l		a2,a0			* pass failing address
	move.l		#$01010001,d0		* pass fslw
d2695 51
a2745 51
*************************************************************************
* XDEF ****************************************************************	*
*	_compandset2(): routine to emulate cas2()			*
*			(internal to package)				*
*									*
*	_isp_cas2_finish(): store ccodes, store compare regs		*
*			    (external to package)			*
*									*
* XREF ****************************************************************	*
*	_real_lock_page() - "callout" to lock op's page from page-outs	*
*	_cas_terminate2() - access error exit				*
*	_real_cas2() - "callout" to core cas2 emulation code		*
*	_real_unlock_page() - "callout" to unlock page			*
*									*
* INPUT ***************************************************************	*
* _compandset2():							*
*	d0 = instruction extension word					*
*									*
* _isp_cas2_finish():							*
*	see cas2 core emulation code					*
* 									*
* OUTPUT **************************************************************	*
* _compandset2():							*
*	see cas2 core emulation code					*
*									*
* _isp_cas_finish():							*
*	None (register file or memroy changed as appropriate)		*
*									*
* ALGORITHM ***********************************************************	*
* compandset2():							*
*	Decode the instruction and fetch the appropriate Update and	*
* Compare operands. Then call the "callout" _real_lock_page() for each	*
* memory operand address so that the operating system can keep these	*
* pages from being paged out. If either _real_lock_page() fails, exit	*
* through _cas_terminate2(). Don't forget to unlock the 1st locked page	*
* using _real_unlock_paged() if the 2nd lock-page fails.		*
* Finally, branch to the core cas2 emulation code by calling the 	*
* "callout" _real_cas2().						*
*									*
* _isp_cas2_finish():							*
*	Re-perform the comparison so we can determine the condition	*
* codes which were too much trouble to keep around during the locked	*
* emulation. Then unlock each operands page by calling the "callout"	*
* _real_unlock_page().							*
*									*
*************************************************************************

ADDR1	equ	EXC_TEMP+$c
ADDR2	equ	EXC_TEMP+$0
DC2	equ	EXC_TEMP+$a
DC1	equ	EXC_TEMP+$8
d2747 1
a2747 1
	xdef  		_compandset2
d2749 2
a2750 2
	move.l		d0,EXC_TEMP+$4(a6)	* store for possible restart
	move.l		d0,d1			* extension word in d0
d2752 56
a2807 56
	rol.w		#$4,d0
	andi.w		#$f,d0			* extract Rn2
	move.l		(EXC_DREGS,a6,d0.w*4),a1 * fetch ADDR2
	move.l		a1,ADDR2(a6)

	move.l		d1,d0

	lsr.w		#$6,d1
	andi.w		#$7,d1			* extract Du2
	move.l		(EXC_DREGS,a6,d1.w*4),d5 * fetch Update2 Op

	andi.w		#$7,d0			* extract Dc2
	move.l		(EXC_DREGS,a6,d0.w*4),d3 * fetch Compare2 Op
	move.w		d0,DC2(a6)

	move.w		EXC_EXTWORD(a6),d0
	move.l		d0,d1

	rol.w		#$4,d0
	andi.w		#$f,d0			* extract Rn1
	move.l		(EXC_DREGS,a6,d0.w*4),a0 * fetch ADDR1
	move.l		a0,ADDR1(a6)

	move.l		d1,d0

	lsr.w		#$6,d1
	andi.w		#$7,d1			* extract Du1
	move.l		(EXC_DREGS,a6,d1.w*4),d4 * fetch Update1 Op

	andi.w		#$7,d0			* extract Dc1
	move.l		(EXC_DREGS,a6,d0.w*4),d2 * fetch Compare1 Op
	move.w		d0,DC1(a6)

	btst		#$1,EXC_OPWORD(a6)	* word or long?
	sne		d7

	btst		#$5,EXC_ISR(a6)		* user or supervisor?
	sne		d6

	move.l		a0,a2
	move.l		a1,a3

	move.l		d7,d1			* pass size
	move.l		d6,d0			* pass mode
	bsr.l		_real_lock_page		* lock page
	move.l		a2,a0
	tst.l		d0			* error?
	bne.l		_cas_terminate2		* yes

	move.l		d7,d1			* pass size
	move.l		d6,d0			* pass mode
	move.l		a3,a0			* pass addr
	bsr.l		_real_lock_page		* lock page
	move.l		a3,a0
	tst.l		d0			* error?
	bne.b		cas_preterm		* yes
d2809 2
a2810 2
	move.l		a2,a0
	move.l		a3,a1
d2814 2
a2815 2
* if the 2nd lock attempt fails, then we must still unlock the
* first page(s).
d2817 7
a2823 7
	move.l		d0,-(sp)		* save FSLW
	move.l		d7,d1			* pass size
	move.l		d6,d0			* pass mode
	move.l		a2,a0			* pass ADDR1
	bsr.l		_real_unlock_page	* unlock first page(s)
	move.l		(sp)+,d0		* restore FSLW
	move.l		a3,a0			* pass failing addr
d2826 1
a2826 1
*************************************************************
d2828 1
a2828 1
	xdef  		_isp_cas2_finish
d2830 1
a2830 1
	btst		#$1,EXC_OPWORD(a6)
d2833 2
a2834 2
	move.w		EXC_CC(a6),ccr		* load old ccodes
	cmp.w		d0,d2
d2836 1
a2836 1
	cmp.w		d1,d3
d2838 1
a2838 1
	move.w		ccr,EXC_CC(a6)		* save new ccodes
d2840 2
a2841 2
	tst.b		d4			* update compare reg?
	bne.b		cas2_finish_w_done	* no
d2843 2
a2844 2
	move.w		DC2(a6),d3		* fetch Dc2
	move.w		d1,(2+EXC_DREGS,a6,d3.w*4) * store new Compare2 Op
d2846 2
a2847 2
	move.w		DC1(a6),d2		* fetch Dc1
	move.w		d0,(2+EXC_DREGS,a6,d2.w*4) * store new Compare1 Op
d2850 11
a2860 11
	btst		#$5,EXC_ISR(a6)
	sne		d2
	move.l		d2,d0			* pass mode
	sf		d1			* pass size
	move.l		ADDR1(a6),a0		* pass ADDR1
	bsr.l		_real_unlock_page	* unlock page

	move.l		d2,d0			* pass mode
	sf		d1			* pass size
	move.l		ADDR2(a6),a0		* pass ADDR2
	bsr.l		_real_unlock_page	* unlock page
d2864 2
a2865 2
	move.w		EXC_CC(a6),ccr		* load old ccodes
	cmp.l		d0,d2
d2867 1
a2867 1
	cmp.l		d1,d3
d2869 1
a2869 1
	move.w		ccr,EXC_CC(a6)		* save new ccodes
d2871 2
a2872 2
	tst.b		d4			* update compare reg?
	bne.b		cas2_finish_l_done	* no
d2874 2
a2875 2
	move.w		DC2(a6),d3		* fetch Dc2
	move.l		d1,(EXC_DREGS,a6,d3.w*4) * store new Compare2 Op
d2877 2
a2878 2
	move.w		DC1(a6),d2		* fetch Dc1
	move.l		d0,(EXC_DREGS,a6,d2.w*4) * store new Compare1 Op
d2881 11
a2891 11
	btst		#$5,EXC_ISR(a6)
	sne		d2
	move.l		d2,d0			* pass mode
	st		d1			* pass size
	move.l		ADDR1(a6),a0		* pass ADDR1
	bsr.l		_real_unlock_page	* unlock page

	move.l		d2,d0			* pass mode
	st		d1			* pass size
	move.l		ADDR2(a6),a0		* pass ADDR2
	bsr.l		_real_unlock_page	* unlock page
d2894 2
a2895 2
********
	xdef  		cr_cas2
d2897 1
a2897 1
	move.l		EXC_TEMP+$4(a6),d0
d2900 83
a2982 83
*************************************************************************
* XDEF ****************************************************************	*
*	_compandset(): routine to emulate cas w/ misaligned <ea>	*
*		       (internal to package)				*
*	_isp_cas_finish(): routine called when cas emulation completes	*
*			   (external and internal to package)		*
*	_isp_cas_restart(): restart cas emulation after a fault		*
*			    (external to package)			*
*	_isp_cas_terminate(): create access error stack frame on fault	*
*			      (external and internal to package)	*
*	_isp_cas_inrange(): checks whether instr addess is within range	*
*			    of core cas/cas2emulation code		*
*			    (external to package)			*
*									*
* XREF ****************************************************************	*
* 	_calc_ea(): calculate effective address				*
*									*
* INPUT ***************************************************************	*
* compandset():								*
* 	none								*
* _isp_cas_restart():							*
*	d6 = previous sfc/dfc						*
* _isp_cas_finish():							*
* _isp_cas_terminate():							*
*	a0 = failing address						*
*	d0 = FSLW							*
*	d6 = previous sfc/dfc						*
* _isp_cas_inrange():							*
*	a0 = instruction address to be checked				*
*									*
* OUTPUT **************************************************************	*
* compandset():								*
*		none							*
* _isp_cas_restart():							*
*	a0 = effective address						*
*	d7 = word or longword flag					*
* _isp_cas_finish():							*
*	a0 = effective address						*
* _isp_cas_terminate():							*
*	initial register set before emulation exception			*
* _isp_cas_inrange():							*
*	d0 = 0 => in range; -1 => out of range				*
*									*
* ALGORITHM ***********************************************************	*
*									*
* compandset():								*
*	First, calculate the effective address. Then, decode the 	*
* instruction word and fetch the "compare" (DC) and "update" (Du)	*
* operands.								*
* 	Next, call the external routine _real_lock_page() so that the	*
* operating system can keep this page from being paged out while we're	*
* in this routine. If this call fails, jump to _cas_terminate2().	*
*	The routine then branches to _real_cas(). This external routine	*
* that actually emulates cas can be supplied by the external os or	*
* made to point directly back into the 060ISP which has a routine for	*
* this purpose.								*
*									*
* _isp_cas_finish():							*
* 	Either way, after emulation, the package is re-entered at	*
* _isp_cas_finish(). This routine re-compares the operands in order to	*
* set the condition codes. Finally, these routines will call		*
* _real_unlock_page() in order to unlock the pages that were previously	*
* locked.								*
*									*
* _isp_cas_restart():							*
*	This routine can be entered from an access error handler where	*
* the emulation sequence should be re-started from the beginning.	*
*									*
* _isp_cas_terminate():							*
*	This routine can be entered from an access error handler where	*
* an emulation operand access failed and the operating system would	*
* like an access error stack frame created instead of the current 	*
* unimplemented integer instruction frame.				*
* 	Also, the package enters here if a call to _real_lock_page()	*
* fails.								*
*									*
* _isp_cas_inrange():							*
* 	Checks to see whether the instruction address passed to it in	*
* a0 is within the software package cas/cas2 emulation routines. This	*
* can be helpful for an operating system to determine whether an access	*
* error during emulation was due to a cas/cas2 emulation access.	*
*									*
*************************************************************************
d2984 2
a2985 2
DC	equ		EXC_TEMP+$8
ADDR	equ		EXC_TEMP+$4
d2987 1
a2987 1
	xdef  		_compandset
d2989 2
a2990 2
	btst		#$1,EXC_OPWORD(a6)	* word or long operation?
	bne.b		compandsetl		* long
d2993 4
a2996 4
	moveq.l		#$2,d0			* size = 2 bytes
	bsr.l		_calc_ea		* a0 = calculated <ea>
	move.l		a0,ADDR(a6)		* save <ea> for possible restart
	sf		d7			* clear d7 for word size
d3000 4
a3003 4
	moveq.l		#$4,d0			* size = 4 bytes
	bsr.l		_calc_ea		* a0 = calculated <ea>
	move.l		a0,ADDR(a6)		* save <ea> for possible restart
	st		d7			* set d7 for longword size
d3006 2
a3007 21
	move.w		EXC_EXTWORD(a6),d0	* fetch cas extension word
	move.l		d0,d1			* make a copy

	lsr.w		#$6,d0
	andi.w		#$7,d0				* extract Du
	move.l		(EXC_DREGS,a6,d0.w*4),d2 	* get update operand

	andi.w		#$7,d1				* extract Dc
	move.l		(EXC_DREGS,a6,d1.w*4),d4 	* get compare operand
	move.w		d1,DC(a6)		* save Dc

	btst		#$5,EXC_ISR(a6)		* which mode for exception?
	sne		d6			* set on supervisor mode

	move.l		a0,a2			* save temporarily
	move.l		d7,d1			* pass size
	move.l		d6,d0			* pass mode
	bsr.l		_real_lock_page		* lock page
	tst.l		d0			* did error occur?
	bne.w		_cas_terminate2		* yes, clean up the mess
	move.l		a2,a0			* pass addr in a0
d3009 19
d3030 2
a3031 2
********
	xdef  		_isp_cas_finish
d3033 1
a3033 1
	btst		#$1,EXC_OPWORD(a6)
d3036 2
a3037 2
* just do the compare again since it's faster than saving the ccodes
* from the locked routine...
d3039 3
a3041 3
	move.w		EXC_CC(a6),ccr		* restore cc
	cmp.w	 	d0,d4			* do word compare
	move.w		ccr,EXC_CC(a6)		* save cc
d3043 2
a3044 2
	tst.b		d1			* update compare reg?
	bne.b		cas_finish_w_done	* no
d3046 2
a3047 2
	move.w		DC(a6),d3
	move.w		d0,(EXC_DREGS+2,a6,d3.w*4) * Dc = destination
d3050 5
a3054 5
	move.l		ADDR(a6),a0		* pass addr
	sf		d1			* pass size
	btst		#$5,EXC_ISR(a6)
	sne		d0			* pass mode
	bsr.l		_real_unlock_page	* unlock page
d3057 2
a3058 2
* just do the compare again since it's faster than saving the ccodes
* from the locked routine...
d3060 3
a3062 3
	move.w		EXC_CC(a6),ccr		* restore cc
	cmp.l	 	d0,d4			* do longword compare
	move.w		ccr,EXC_CC(a6)		* save cc
d3064 2
a3065 2
	tst.b		d1			* update compare reg?
	bne.b		cas_finish_l_done	* no
d3067 2
a3068 2
	move.w		DC(a6),d3
	move.l		d0,(EXC_DREGS,a6,d3.w*4) * Dc = destination
d3071 5
a3075 5
	move.l		ADDR(a6),a0		* pass addr
	st		d1			* pass size
	btst		#$5,EXC_ISR(a6)
	sne		d0			* pass mode
	bsr.l		_real_unlock_page	* unlock page
d3078 3
a3080 3
********

	xdef  		_isp_cas_restart
d3082 2
a3083 2
	movec.l		d6,sfc			* restore previous sfc
	movec.l		d6,dfc			* restore previous dfc
d3085 2
a3086 2
	cmp.b		#$fc,EXC_OPWORD+1(a6)	* cas or cas2?
	beq.l		cr_cas2			* cas2
d3088 4
a3091 4
	move.l		ADDR(a6),a0		* load <ea>
	btst		#$1,EXC_OPWORD(a6)	* word or long operation?
	sne		d7			* set d7 accordingly
	bra.w		compandsetfetch
d3093 1
a3093 1
********
d3095 2
a3096 2
* At this stage, it would be nice if d0 held the FSLW.
	xdef  		_isp_cas_terminate
d3098 2
a3099 2
	movec.l		d6,sfc			* restore previous sfc
	movec.l		d6,dfc			* restore previous dfc
d3101 1
a3101 1
	xdef  		_cas_terminate2
d3103 1
a3103 1
	move.l		a0,a2			* copy failing addr to a2
d3105 10
a3114 10
	move.l		d0,-(sp)
	bsr.l		isp_restore		* restore An (if ()+ or -())
	move.l		(sp)+,d0

	addq.l		#$4,sp			* remove sub return addr
	subq.l		#$8,sp			* make room for bigger stack
	subq.l		#$8,a6			* shift frame ptr down, too
	move.l		#26,d1			* want to move 51 longwords
	lea		$8(sp),a0		* get address of old stack
	lea		$0(sp),a1		* get address of new stack
d3116 2
a3117 2
	move.l		(a0)+,(a1)+		* move a longword
	dbra.w		d1,cas_term_cont	* keep going
d3119 5
a3123 5
	move.w		#$4008,EXC_IVOFF(a6)	* put new stk fmt, voff
	move.l		a2,EXC_IVOFF+$2(a6)	* put faulting addr on stack
	move.l		d0,EXC_IVOFF+$6(a6)		* put FSLW on stack
	movem.l		EXC_DREGS(a6),d0-d7/a0-a5	* restore user regs
	unlk		a6				* unlink stack frame
d3126 1
a3126 1
********
d3128 1
a3128 1
	xdef  		_isp_cas_inrange
d3130 107
a3236 110
	clr.l		d0			* clear return result
	lea		_CASHI(pc),a1		* load end of CAS core code
	cmp.l		a1,a0			* is PC in range?
	blt.b		cin_no			* no
	lea		_CASLO(pc),a1		* load begin of CAS core code
	cmp.l		a0,a1			* is PC in range?
	blt.b		cin_no			* no
	rts					* yes; return d0 = 0
cin_no:
	move.l		#-$1,d0			* out of range; return d0 = -1
	rts

****************************************************************************
****************************************************************************

*****************************************************************
*****************************************************************
*****************************************************************
* This is the start of the cas and cas2 "core" emulation code.	*
* This is the section that may need to be replaced by the host	*
* OS if it is too operating system-specific.			*
* Please refer to the package documentation to see how to	*
* "replace" this section, if necessary.				*
*****************************************************************
*****************************************************************
*****************************************************************

*       ******      **      ******     ****
*       *	   *  *     *         *    *
*	*	  ******    ******        *
*	*	  *    *         *      *
*       ******    *    *    ******    ******

*************************************************************************
* XDEF ****************************************************************	*
*	_isp_cas2(): "core" emulation code for the cas2 instruction	*
*									*
* XREF ****************************************************************	*
*	_isp_cas2_finish() - only exit point for this emulation code;	*
*			     do clean-up; calculate ccodes; store 	*
*			     Compare Ops if appropriate.		*
*									*
* INPUT ***************************************************************	*
*	*see chart below*						*
* 									*
* OUTPUT **************************************************************	*
*	*see chart below*						*
*									*
* ALGORITHM ***********************************************************	*
*	(1) Make several copies of the effective address.		*
*	(2) Save current SR; Then mask off all maskable interrupts.	*
*	(3) Save current SFC/DFC (ASSUMED TO BE EQUAL!!!); Then set 	*
*	    according to whether exception occurred in user or 		*
*	    supervisor mode.						*
*	(4) Use "plpaw" instruction to pre-load ATC with effective	*
*	    address pages(s). THIS SHOULD NOT FAULT!!! The relevant	*
*	    page(s) should have already been made resident prior to	*
* 	    entering this routine.					*
*	(5) Push the operand lines from the cache w/ "cpushl". 		*
*	    In the 68040, this was done within the locked region. In	*
* 	    the 68060, it is done outside of the locked region.		*
*	(6) Use "plpar" instruction to do a re-load of ATC entries for	*
*	    ADDR1 since ADDR2 entries may have pushed ADDR1 out of the	*
*	    ATC.							*
*	(7) Pre-fetch the core emulation instructions by executing	*
*	    one branch within each physical line (16 bytes) of the code	*
*	    before actually executing the code.				*
*	(8) Load the BUSCR w/ the bus lock value.			*
*	(9) Fetch the source operands using "moves".			*
*	(10)Do the compares. If both equal, go to step (13).		*
*	(11)Unequal. No update occurs. But, we do write the DST1 op	*
*	    back to itself (as w/ the '040) so we can gracefully unlock	*
*	    the bus (and assert LOCKE*) using BUSCR and the final move.	*
*	(12)Exit.							*
*	(13)Write update operand to the DST locations. Use BUSCR to 	*
*	    assert LOCKE* for the final write operation.		*
*	(14)Exit.							*
*									*
* 	The algorithm is actually implemented slightly differently	*
* depending on the size of the operation and the misalignment of the 	*
* operands. A misaligned operand must be written in aligned chunks or	*
* else the BUSCR register control gets confused.			*
*									*
*************************************************************************

*****************************************************************
* THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON		* 
* ENTERING _isp_cas2().						*
*								*
* D0 = xxxxxxxx							*
* D1 = xxxxxxxx							*
* D2 = cmp operand 1						*
* D3 = cmp operand 2						*
* D4 = update oper 1						*
* D5 = update oper 2						*
* D6 = 'xxxxxxff if supervisor mode; 'xxxxxx00 if user mode	*
* D7 = 'xxxxxxff if longword operation; 'xxxxxx00 if word 	*
* A0 = ADDR1							*
* A1 = ADDR2							*
* A2 = xxxxxxxx							*
* A3 = xxxxxxxx							*
* A4 = xxxxxxxx							*
* A5 = xxxxxxxx							*
* A6 = frame pointer						*
* A7 = stack pointer						*
*****************************************************************

*	align		$1000
* beginning label used by _isp_cas_inrange()
	xdef  		_CASLO
d3239 1
a3239 1
	xdef  		_isp_cas2
d3241 2
a3242 2
	tst.b		d6			* user or supervisor mode?
	bne.b		cas2_supervisor		* supervisor
d3244 1
a3244 1
	moveq.l		#$1,d0			* load user data fc
d3247 1
a3247 1
	moveq.l		#$5,d0			* load supervisor data fc
d3249 2
a3250 2
	tst.b		d7			* word or longword?
	beq.w		cas2w			* word
d3252 1
a3252 1
****
d3254 73
a3326 80
	move.l		a0,a2			* copy ADDR1
	move.l		a1,a3			* copy ADDR2
	move.l		a0,a4			* copy ADDR1
	move.l		a1,a5			* copy ADDR2

	addq.l		#$3,a4			* ADDR1+3
	addq.l		#$3,a5			* ADDR2+3
	move.l		a2,d1			* ADDR1

* mask interrupts levels 0-6. save old mask value.

	move.w		sr,d7			* save current SR
	ori.w		#$0700,sr		* inhibit interrupts

* load the SFC and DFC with the appropriate mode.

	movec		sfc,d6			* save old SFC/DFC
	movec		d0,sfc			* store new SFC
	movec		d0,dfc			* store new DFC

* pre-load the operand ATC. no page faults should occur here because
* _real_lock_page() should have taken care of this.

	plpaw		(a2)			* load atc for ADDR1
	plpaw		(a4)			* load atc for ADDR1+3
	plpaw		(a3)			* load atc for ADDR2
	plpaw		(a5)			* load atc for ADDR2+3

* push the operand lines from the cache if they exist.

	cpushl		dc,(a2)			* push line for ADDR1
	cpushl		dc,(a4)			* push line for ADDR1+3
	cpushl		dc,(a3)			* push line for ADDR2
	cpushl		dc,(a5)			* push line for ADDR2+2

	move.l		d1,a2			* ADDR1
	addq.l		#$3,d1
	move.l		d1,a4			* ADDR1+3

* if ADDR1 was ATC resident before the above "plpaw" and was executed
* and it was the next entry scheduled for replacement and ADDR2
* shares the same set, then the "plpaw" for ADDR2 can push the ADDR1
* entries from the ATC. so, we do a second set of "plpa"s.

	plpar		(a2)			* load atc for ADDR1
	plpar		(a4)			* load atc for ADDR1+3

* load the BUSCR values.
	move.l		#$80000000,a2		* assert LOCK* buscr value
	move.l		#$a0000000,a3		* assert LOCKE* buscr value
	move.l		#$00000000,a4		* buscr unlock value

* there are three possible mis-aligned cases for longword cas. they
* are separated because the final write which asserts LOCKE* must
* be aligned.
	move.l		a0,d0			* is ADDR1 misaligned?
	andi.b		#$3,d0
	beq.b		CAS2L_ENTER		* no
	cmp.b		#$2,d0
	beq.w		CAS2L2_ENTER		* yes; word misaligned
	bra.w		CAS2L3_ENTER		* yes; byte misaligned

*
* D0 = dst operand 1 <-
* D1 = dst operand 2 <-
* D2 = cmp operand 1
* D3 = cmp operand 2
* D4 = update oper 1
* D5 = update oper 2
* D6 = old SFC/DFC
* D7 = old SR
* A0 = ADDR1
* A1 = ADDR2
* A2 = bus LOCK*  value
* A3 = bus LOCKE* value
* A4 = bus unlock value
* A5 = xxxxxxxx
*
	opt 0
	cnop 		0,$10
d3328 3
a3330 3
	movec		a2,buscr		* assert LOCK*
	moves.l		(a1),d1			* fetch Dest2[31:0]
	moves.l		(a0),d0			* fetch Dest1[31:0]
d3333 1
a3333 1
	bra.b		*+16
d3336 1
a3336 1
	cmp.l	 	d0,d2			* Dest1 - Compare1
d3338 1
a3338 1
	cmp.l	 	d1,d3			* Dest2 - Compare2
d3340 1
a3340 1
	moves.l		d5,(a1)			* Update2[31:0] -> DEST2
d3342 1
a3342 1
	bra.b		*+16
d3345 3
a3347 3
	movec		a3,buscr		* assert LOCKE*
	moves.l		d4,(a0)			* Update1[31:0] -> DEST1
	movec		a4,buscr		* unlock the bus
d3349 1
a3349 1
	bra.b		*+16
d3352 3
a3354 3
	movec		a3,buscr		* assert LOCKE*
	moves.l		d0,(a0)			* Dest1[31:0] -> DEST1
	movec		a4,buscr		* unlock the bus
d3356 1
a3356 1
	bra.b		*+16
d3367 24
a3390 23
        opt !
****
*****************************************************************
* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	*
* ENTERING _isp_cas2().						*
*								*
* D0 = destination[31:0] operand 1				*
* D1 = destination[31:0] operand 2				*
* D2 = cmp[31:0] operand 1					*
* D3 = cmp[31:0] operand 2					*
* D4 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	*
* D5 = xxxxxxxx							*
* D6 = xxxxxxxx							*
* D7 = xxxxxxxx							*
* A0 = xxxxxxxx							*
* A1 = xxxxxxxx							*
* A2 = xxxxxxxx							*
* A3 = xxxxxxxx							*
* A4 = xxxxxxxx							*
* A5 = xxxxxxxx							*
* A6 = frame pointer						*
* A7 = stack pointer						*
*****************************************************************
d3394 3
a3396 3
* restore previous SFC/DFC value.
	movec		d6,sfc			* restore old SFC
	movec		d6,dfc			* restore old DFC
d3398 2
a3399 2
* restore previous interrupt mask level.
	move.w		d7,sr			* restore old SR
d3401 1
a3401 1
	sf		d4			* indicate no update was done
d3406 3
a3408 3
* restore previous SFC/DFC value.
	movec		d6,sfc			* restore old SFC
	movec		d6,dfc			* restore old DFC
d3410 2
a3411 2
* restore previous interrupt mask level.
	move.w		d7,sr			* restore old SR
d3413 1
a3413 1
	st		d4			* indicate update was done
d3415 3
a3417 3
****
	opt 0
	cnop 		0,$10
d3419 3
a3421 3
	movec		a2,buscr		* assert LOCK*
	moves.l		(a1),d1			* fetch Dest2[31:0]
	moves.l		(a0),d0			* fetch Dest1[31:0]
d3424 1
a3424 1
	bra.b		*+16
d3427 1
a3427 1
	cmp.l	 	d0,d2			* Dest1 - Compare1
d3429 1
a3429 1
	cmp.l	 	d1,d3			* Dest2 - Compare2
d3431 1
a3431 1
	moves.l		d5,(a1)			* Update2[31:0] -> Dest2
d3433 1
a3433 1
	bra.b		*+16
d3436 4
a3439 4
	swap		d4			* get Update1[31:16]
	moves.w		d4,(a0)+		* Update1[31:16] -> DEST1
	movec		a3,buscr		* assert LOCKE*
	swap		d4			* get Update1[15:0]
d3441 1
a3441 1
	bra.b		*+16
d3444 2
a3445 2
	moves.w		d4,(a0)			* Update1[15:0] -> DEST1+$2
	movec		a4,buscr		* unlock the bus
d3448 1
a3448 1
	bra.b		*+16
d3451 4
a3454 4
	swap		d0			* get Dest1[31:16]
	moves.w		d0,(a0)+		* Dest1[31:16] -> DEST1
	movec		a3,buscr		* assert LOCKE*
	swap		d0			* get Dest1[15:0]
d3456 1
a3456 1
	bra.b		*+16
d3459 2
a3460 2
	moves.w		d0,(a0)			* Dest1[15:0] -> DEST1+$2
	movec		a4,buscr		* unlock the bus
d3463 1
a3463 1
	bra.b		*+16
a3473 1
	opt !
d3475 1
a3475 1
*********************************
d3477 1
a3477 2
	opt 0
	cnop 		0,$10
d3479 3
a3481 3
	movec		a2,buscr		* assert LOCK*
	moves.l		(a1),d1			* fetch Dest2[31:0]
	moves.l		(a0),d0			* fetch Dest1[31:0]
d3484 1
a3484 1
	bra.b		*+16
d3487 1
a3487 1
	cmp.l	 	d0,d2			* Dest1 - Compare1
d3489 1
a3489 1
	cmp.l	 	d1,d3			* Dest2 - Compare2
d3491 1
a3491 1
	moves.l		d5,(a1)			* Update2[31:0] -> DEST2
d3493 1
a3493 1
	bra.b		*+16
d3496 4
a3499 4
	rol.l		#$8,d4			* get Update1[31:24]
	moves.b		d4,(a0)+		* Update1[31:24] -> DEST1
	swap		d4			* get Update1[23:8]
	moves.w		d4,(a0)+		* Update1[23:8] -> DEST1+$1
d3501 1
a3501 1
	bra.b		*+16
d3504 3
a3506 3
	rol.l		#$8,d4			* get Update1[7:0]
	movec		a3,buscr		* assert LOCKE*
	moves.b		d4,(a0)			* Update1[7:0] -> DEST1+$3
d3509 1
a3509 1
	bra.b		*+16
d3512 1
a3512 1
	movec		a4,buscr		* unlock the bus
d3517 2
a3518 2
	bra.b		*+16

d3520 4
a3523 4
	rol.l		#$8,d0			* get Dest1[31:24]
	moves.b		d0,(a0)+		* Dest1[31:24] -> DEST1
	swap		d0			* get Dest1[23:8]
	moves.w		d0,(a0)+		* Dest1[23:8] -> DEST1+$1
d3525 1
a3525 1
	bra.b		*+16
d3528 3
a3530 3
	rol.l		#$8,d0			* get Dest1[7:0]
	movec		a3,buscr		* assert LOCKE*
	moves.b		d0,(a0)			* Update1[7:0] -> DEST1+$3
d3533 1
a3533 1
	bra.b		*+16
d3536 1
a3536 1
	movec		a4,buscr		* unlock the bus
d3541 1
a3541 1
	bra.b		*+14
d3552 2
a3553 4
	opt !

*************************************************************
*************************************************************
d3556 71
a3626 72
	move.l		a0,a2			* copy ADDR1
	move.l		a1,a3			* copy ADDR2
	move.l		a0,a4			* copy ADDR1
	move.l		a1,a5			* copy ADDR2

	addq.l		#$1,a4			* ADDR1+1
	addq.l		#$1,a5			* ADDR2+1
	move.l		a2,d1			* ADDR1

* mask interrupt levels 0-6. save old mask value.
	move.w		sr,d7			* save current SR
	ori.w		#$0700,sr		* inhibit interrupts

* load the SFC and DFC with the appropriate mode.
	movec		sfc,d6			* save old SFC/DFC
	movec		d0,sfc			* store new SFC
	movec		d0,dfc			* store new DFC

* pre-load the operand ATC. no page faults should occur because
* _real_lock_page() should have taken care of this.
	plpaw		(a2)			* load atc for ADDR1
	plpaw		(a4)			* load atc for ADDR1+1
	plpaw		(a3)			* load atc for ADDR2
	plpaw		(a5)			* load atc for ADDR2+1

* push the operand cache lines from the cache if they exist.
	cpushl		dc,(a2)			* push line for ADDR1
	cpushl		dc,(a4)			* push line for ADDR1+1
	cpushl		dc,(a3)			* push line for ADDR2
	cpushl		dc,(a5)			* push line for ADDR2+1

	move.l		d1,a2			* ADDR1
	addq.l		#$3,d1
	move.l		d1,a4			* ADDR1+3
* if ADDR1 was ATC resident before the above "plpaw" and was executed
* and it was the next entry scheduled for replacement and ADDR2
* shares the same set, then the "plpaw" for ADDR2 can push the ADDR1
* entries from the ATC. so, we do a second set of "plpa"s.
	plpar		(a2)			* load atc for ADDR1
	plpar		(a4)			* load atc for ADDR1+3

* load the BUSCR values.
	move.l		#$80000000,a2		* assert LOCK* buscr value
	move.l		#$a0000000,a3		* assert LOCKE* buscr value
	move.l		#$00000000,a4		* buscr unlock value

* there are two possible mis-aligned cases for word cas. they
* are separated because the final write which asserts LOCKE* must
* be aligned.
	move.l		a0,d0			* is ADDR1 misaligned?
	btst		#$0,d0
	bne.w		CAS2W2_ENTER		* yes
	bra.b		CAS2W_ENTER		* no

*
* D0 = dst operand 1 <-
* D1 = dst operand 2 <-
* D2 = cmp operand 1
* D3 = cmp operand 2
* D4 = update oper 1
* D5 = update oper 2
* D6 = old SFC/DFC
* D7 = old SR
* A0 = ADDR1
* A1 = ADDR2
* A2 = bus LOCK*  value
* A3 = bus LOCKE* value
* A4 = bus unlock value
* A5 = xxxxxxxx
*
	opt 0
	cnop 		0,$10
d3628 3
a3630 3
	movec		a2,buscr		* assert LOCK*
	moves.w		(a1),d1			* fetch Dest2[15:0]
	moves.w		(a0),d0			* fetch Dest1[15:0]
d3633 1
a3633 1
	bra.b		*+16
d3636 1
a3636 1
	cmp.w	 	d0,d2			* Dest1 - Compare1
d3638 1
a3638 1
	cmp.w	 	d1,d3			* Dest2 - Compare2
d3640 1
a3640 1
	moves.w		d5,(a1)			* Update2[15:0] -> DEST2
d3642 1
a3642 1
	bra.b		*+16
d3645 3
a3647 3
	movec		a3,buscr		* assert LOCKE*
	moves.w		d4,(a0)			* Update1[15:0] -> DEST1
	movec		a4,buscr		* unlock the bus
d3649 1
a3649 1
	bra.b		*+16
d3652 3
a3654 3
	movec		a3,buscr		* assert LOCKE*
	moves.w		d0,(a0)			* Dest1[15:0] -> DEST1
	movec		a4,buscr		* unlock the bus
d3656 1
a3656 1
	bra.b		*+16
d3668 1
a3668 1
	opt !
d3670 21
a3690 23
****

*****************************************************************
* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	*
* ENTERING _isp_cas2().						*
*								*
* D0 = destination[15:0] operand 1				*
* D1 = destination[15:0] operand 2				*
* D2 = cmp[15:0] operand 1					*
* D3 = cmp[15:0] operand 2					*
* D4 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	*
* D5 = xxxxxxxx							*
* D6 = xxxxxxxx							*
* D7 = xxxxxxxx							*
* A0 = xxxxxxxx							*
* A1 = xxxxxxxx							*
* A2 = xxxxxxxx							*
* A3 = xxxxxxxx							*
* A4 = xxxxxxxx							*
* A5 = xxxxxxxx							*
* A6 = frame pointer						*
* A7 = stack pointer						*
*****************************************************************
d3694 3
a3696 3
* restore previous SFC/DFC value.
	movec		d6,sfc			* restore old SFC
	movec		d6,dfc			* restore old DFC
d3698 2
a3699 2
* restore previous interrupt mask level.
	move.w		d7,sr			* restore old SR
d3701 1
a3701 1
	sf		d4			* indicate no update was done
d3706 3
a3708 3
* restore previous SFC/DFC value.
	movec		d6,sfc			* restore old SFC
	movec		d6,dfc			* restore old DFC
d3710 2
a3711 2
* restore previous interrupt mask level.
	move.w		d7,sr			* restore old SR
d3713 1
a3713 1
	st		d4			* indicate update was done
d3715 1
a3715 1
****
d3717 1
a3717 2
	opt 0
	cnop 		0,$10
d3719 3
a3721 3
	movec		a2,buscr		* assert LOCK*
	moves.w		(a1),d1			* fetch Dest2[15:0]
	moves.w		(a0),d0			* fetch Dest1[15:0]
d3724 1
a3724 1
	bra.b		*+16
d3727 1
a3727 1
	cmp.w	 	d0,d2			* Dest1 - Compare1
d3729 1
a3729 1
	cmp.w	 	d1,d3			* Dest2 - Compare2
d3731 1
a3731 1
	moves.w		d5,(a1)			* Update2[15:0] -> DEST2
d3733 1
a3733 1
	bra.b		*+16
d3736 4
a3739 4
	ror.l		#$8,d4			* get Update1[15:8]
	moves.b		d4,(a0)+		* Update1[15:8] -> DEST1
	movec		a3,buscr		* assert LOCKE*
	rol.l		#$8,d4			* get Update1[7:0]
d3741 1
a3741 1
	bra.b		*+16
d3744 2
a3745 2
	moves.b		d4,(a0)			* Update1[7:0] -> DEST1+$1
	movec		a4,buscr		* unlock the bus
d3748 1
a3748 1
	bra.b		*+16
d3751 4
a3754 4
	ror.l		#$8,d0			* get Dest1[15:8]
	moves.b		d0,(a0)+		* Dest1[15:8] -> DEST1
	movec		a3,buscr		* assert LOCKE*
	rol.l		#$8,d0			* get Dest1[7:0]
d3756 1
a3756 1
	bra.b		*+16
d3759 2
a3760 2
	moves.b		d0,(a0)			* Dest1[7:0] -> DEST1+$1
	movec		a4,buscr		* unlock the bus
d3763 1
a3763 1
	bra.b		*+16
d3775 75
a3849 83
	opt !

****************************************************************************
****************************************************************************

*       ******      **      ******
*       *	   *  *     *
*	*	  ******    ******
*	*	  *    *         *
*       ******    *    *    ******

****************************************************************************
****************************************************************************

*************************************************************************
* XDEF ****************************************************************	*
* 	_isp_cas(): "core" emulation code for the cas instruction	*
*									*
* XREF ****************************************************************	*
*	_isp_cas_finish() - only exit point for this emulation code;	*
*			    do clean-up					*
*									*
* INPUT ***************************************************************	*
* 	*see entry chart below*						*
*									*
* OUTPUT **************************************************************	*
*	*see exit chart below*						*
*									*
* ALGORITHM ***********************************************************	*
* 	(1) Make several copies of the effective address. 		*
* 	(2) Save current SR; Then mask off all maskable interrupts.	*
*	(3) Save current DFC/SFC (ASSUMED TO BE EQUAL!!!); Then set	*
*	    SFC/DFC according to whether exception occurred in user or	*
*	    supervisor mode.						*
*	(4) Use "plpaw" instruction to pre-load ATC with efective	*
*	    address page(s). THIS SHOULD NOT FAULT!!! The relevant	*
* 	    page(s) should have been made resident prior to entering 	*
*	    this routine.						*
*	(5) Push the operand lines from the cache w/ "cpushl".		*
*	    In the 68040, this was done within the locked region. In	*
*	    the 68060, it is done outside of the locked region.		*
*	(6) Pre-fetch the core emulation instructions by executing one	*
*	    branch within each physical line (16 bytes) of the code	*
*	    before actually executing the code.				*
*	(7) Load the BUSCR with the bus lock value.			*
*	(8) Fetch the source operand.					*
*	(9) Do the compare. If equal, go to step (12).			*
*	(10)Unequal. No update occurs. But, we do write the DST op back	*
*	    to itself (as w/ the '040) so we can gracefully unlock	*
*	    the bus (and assert LOCKE*) using BUSCR and the final move.	*
*	(11)Exit.							*
*	(12)Write update operand to the DST location. Use BUSCR to	*
*	    assert LOCKE* for the final write operation.		*
*	(13)Exit.							*
* 									*
* 	The algorithm is actually implemented slightly diferently	*
* depending on the size of the operation and the misalignment of the	*
* operand. A misaligned operand must be written in aligned chunks or	*
* else the BUSCR register control gets confused.			*
*									*
*************************************************************************

*********************************************************
* THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON	*
* ENTERING _isp_cas().					*
*							*
* D0 = xxxxxxxx						*
* D1 = xxxxxxxx						*
* D2 = update operand					*
* D3 = xxxxxxxx						*
* D4 = compare operand					*
* D5 = xxxxxxxx						*
* D6 = supervisor ('xxxxxxff) or user mode ('xxxxxx00)	*
* D7 = longword ('xxxxxxff) or word size ('xxxxxx00)	*
* A0 = ADDR						*
* A1 = xxxxxxxx						*
* A2 = xxxxxxxx						*
* A3 = xxxxxxxx						*
* A4 = xxxxxxxx						*
* A5 = xxxxxxxx						*
* A6 = frame pointer					*
* A7 = stack pointer					*
*********************************************************
d3851 1
a3851 1
	xdef  		_isp_cas
d3853 2
a3854 2
	tst.b		d6			* user or supervisor mode?
	bne.b		cas_super		* supervisor
d3856 1
a3856 1
	moveq.l		#$1,d0			* load user data fc
d3859 1
a3859 1
	moveq.l		#$5,d0			* load supervisor data fc
d3862 2
a3863 2
	tst.b		d7			* word or longword?
	bne.w		casl			* longword
d3865 1
a3865 1
****
d3867 51
a3917 52
	move.l		a0,a1			* make copy for plpaw1
	move.l		a0,a2			* make copy for plpaw2
	addq.l		#$1,a2			* plpaw2 points to end of word

	move.l		d2,d3			* d3 = update[7:0]
	lsr.w		#$8,d2			* d2 = update[15:8]

* mask interrupt levels 0-6. save old mask value.
	move.w		sr,d7			* save current SR
	ori.w		#$0700,sr		* inhibit interrupts

* load the SFC and DFC with the appropriate mode.
	movec		sfc,d6			* save old SFC/DFC
	movec		d0,sfc			* load new sfc
	movec		d0,dfc			* load new dfc

* pre-load the operand ATC. no page faults should occur here because
* _real_lock_page() should have taken care of this.
	plpaw		(a1)			* load atc for ADDR
	plpaw		(a2)			* load atc for ADDR+1

* push the operand lines from the cache if they exist.
	cpushl		dc,(a1)			* push dirty data
	cpushl		dc,(a2)			* push dirty data

* load the BUSCR values.
	move.l		#$80000000,a1		* assert LOCK* buscr value
	move.l		#$a0000000,a2		* assert LOCKE* buscr value
	move.l		#$00000000,a3		* buscr unlock value

* pre-load the instruction cache for the following algorithm.
* this will minimize the number of cycles that LOCK* will be asserted.
	bra.b		CASW_ENTER		* start pre-loading icache

*
* D0 = dst operand <-
* D1 = update[15:8] operand
* D2 = update[7:0]  operand
* D3 = xxxxxxxx
* D4 = compare[15:0] operand
* D5 = xxxxxxxx
* D6 = old SFC/DFC
* D7 = old SR
* A0 = ADDR
* A1 = bus LOCK*  value
* A2 = bus LOCKE* value
* A3 = bus unlock value
* A4 = xxxxxxxx
* A5 = xxxxxxxx
*
	opt 0
	cnop		0,$10
d3919 3
a3921 3
	movec		a1,buscr		* assert LOCK*
	moves.w		(a0),d0			* fetch Dest[15:0]
	cmp.w	 	d0,d4			* Dest - Compare
d3925 1
a3925 1
	bra.b		*+16
d3928 3
a3930 3
	moves.b		d2,(a0)+		* Update[15:8] -> DEST
	movec		a2,buscr		* assert LOCKE*
	moves.b		d3,(a0)			* Update[7:0] -> DEST+$1
d3932 1
a3932 1
	bra.b		*+16
d3935 1
a3935 1
	movec		a3,buscr		* unlock the bus
d3941 1
a3941 1
	bra.b		*+16
d3944 4
a3947 4
	ror.l		#$8,d0			* get Dest[15:8]
	moves.b		d0,(a0)+		* Dest[15:8] -> DEST
	movec		a2,buscr		* assert LOCKE*
	rol.l		#$8,d0			* get Dest[7:0]
d3949 1
a3949 1
	bra.b		*+16
d3952 2
a3953 2
	moves.b		d0,(a0)			* Dest[7:0] -> DEST+$1
	movec		a3,buscr		* unlock the bus
d3957 1
a3957 1
	bra.b		*+16
d3969 21
a3989 23
	opt !

*****************************************************************
* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	*
* CALLING _isp_cas_finish().					*
*								*
* D0 = destination[15:0] operand				*
* D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	*
* D2 = xxxxxxxx							*
* D3 = xxxxxxxx							*
* D4 = compare[15:0] operand					*
* D5 = xxxxxxxx							*
* D6 = xxxxxxxx							*
* D7 = xxxxxxxx							*
* A0 = xxxxxxxx							*
* A1 = xxxxxxxx							*
* A2 = xxxxxxxx							*
* A3 = xxxxxxxx							*
* A4 = xxxxxxxx							*
* A5 = xxxxxxxx							*
* A6 = frame pointer						*
* A7 = stack pointer						*
*****************************************************************
d3993 3
a3995 3
* restore previous SFC/DFC value.
	movec		d6,sfc			* restore old SFC
	movec		d6,dfc			* restore old DFC
d3997 2
a3998 2
* restore previous interrupt mask level.
	move.w		d7,sr			* restore old SR
d4000 1
a4000 1
	sf		d1			* indicate no update was done
d4005 3
a4007 3
* restore previous SFC/DFC value.
	movec		d6,sfc			* restore old SFC
	movec		d6,dfc			* restore old DFC
d4009 2
a4010 2
* restore previous interrupt mask level.
	move.w		d7,sr			* restore old SR
d4012 1
a4012 1
	st		d1			* indicate update was done
d4015 1
a4015 1
****************
d4017 3
a4019 3
* there are two possible mis-aligned cases for longword cas. they
* are separated because the final write which asserts LOCKE* must
* be an aligned write.
d4021 53
a4073 54
	move.l		a0,a1			* make copy for plpaw1
	move.l		a0,a2			* make copy for plpaw2
	addq.l		#$3,a2			* plpaw2 points to end of longword

	move.l		a0,d1			* byte or word misaligned?
	btst		#$0,d1
	bne.w		casl2			* byte misaligned

	move.l		d2,d3			* d3 = update[15:0]
	swap		d2			* d2 = update[31:16]

* mask interrupts levels 0-6. save old mask value.
	move.w		sr,d7			* save current SR
	ori.w		#$0700,sr		* inhibit interrupts

* load the SFC and DFC with the appropriate mode.
	movec		sfc,d6			* save old SFC/DFC
	movec		d0,sfc			* load new sfc
	movec		d0,dfc			* load new dfc

* pre-load the operand ATC. no page faults should occur here because
* _real_lock_page() should have taken care of this.
	plpaw		(a1)			* load atc for ADDR
	plpaw		(a2)			* load atc for ADDR+3

* push the operand lines from the cache if they exist.
	cpushl		dc,(a1)			* push dirty data
	cpushl		dc,(a2)			* push dirty data

* load the BUSCR values.
	move.l		#$80000000,a1		* assert LOCK* buscr value
	move.l		#$a0000000,a2		* assert LOCKE* buscr value
	move.l		#$00000000,a3		* buscr unlock value

	bra.b		CASL_ENTER		* start pre-loading icache

*
* D0 = dst operand <-
* D1 = xxxxxxxx
* D2 = update[31:16] operand
* D3 = update[15:0]  operand
* D4 = compare[31:0] operand
* D5 = xxxxxxxx
* D6 = old SFC/DFC
* D7 = old SR
* A0 = ADDR
* A1 = bus LOCK*  value
* A2 = bus LOCKE* value
* A3 = bus unlock value
* A4 = xxxxxxxx
* A5 = xxxxxxxx
*
	opt 0
	cnop		0,$10
d4075 3
a4077 3
	movec		a1,buscr		* assert LOCK*
	moves.l		(a0),d0			* fetch Dest[31:0]
	cmp.l	 	d0,d4			* Dest - Compare
d4081 1
a4081 1
	bra.b		*+16
d4084 3
a4086 3
	moves.w		d2,(a0)+		* Update[31:16] -> DEST
	movec		a2,buscr		* assert LOCKE*
	moves.w		d3,(a0)			* Update[15:0] -> DEST+$2
d4088 1
a4088 1
	bra.b		*+16
d4091 1
a4091 1
	movec		a3,buscr		* unlock the bus
d4097 1
a4097 1
	bra.b		*+16
d4100 4
a4103 4
	swap		d0			* get Dest[31:16]
	moves.w		d0,(a0)+		* Dest[31:16] -> DEST
	swap		d0			* get Dest[15:0]
	movec		a2,buscr		* assert LOCKE*
d4105 1
a4105 1
	bra.b		*+16
d4108 2
a4109 2
	moves.w		d0,(a0)			* Dest[15:0] -> DEST+$2
	movec		a3,buscr		* unlock the bus
d4113 1
a4113 1
	bra.b		*+16
d4125 21
a4145 23
	opt !

*****************************************************************
* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	*
* CALLING _isp_cas_finish().					*
*								*
* D0 = destination[31:0] operand				*
* D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	*
* D2 = xxxxxxxx							*
* D3 = xxxxxxxx							*
* D4 = compare[31:0] operand					*
* D5 = xxxxxxxx							*
* D6 = xxxxxxxx							*
* D7 = xxxxxxxx							*
* A0 = xxxxxxxx							*
* A1 = xxxxxxxx							*
* A2 = xxxxxxxx							*
* A3 = xxxxxxxx							*
* A4 = xxxxxxxx							*
* A5 = xxxxxxxx							*
* A6 = frame pointer						*
* A7 = stack pointer						*
*****************************************************************
d4149 3
a4151 3
* restore previous SFC/DFC value.
	movec		d6,sfc		* restore old SFC
	movec		d6,dfc		* restore old DFC
d4153 2
a4154 2
* restore previous interrupt mask level.
	move.w		d7,sr			* restore old SR
d4156 1
a4156 1
	sf		d1			* indicate no update was done
d4161 3
a4163 3
* restore previous SFC/DFC value.
	movec		d6,sfc		* restore old SFC
	movec		d6,dfc		* restore old DFC
d4165 2
a4166 2
* restore previous interrupts mask level.
	move.w		d7,sr			* restore old SR
d4168 1
a4168 1
	st		d1			* indicate update was done
d4171 1
a4171 1
***************************************
d4173 49
a4221 56
	move.l		d2,d5			* d5 = Update[7:0]
	lsr.l		#$8,d2
	move.l		d2,d3			* d3 = Update[23:8]
	swap		d2			* d2 = Update[31:24]

* mask interrupts levels 0-6. save old mask value.
	move.w		sr,d7			* save current SR
	ori.w		#$0700,sr		* inhibit interrupts

* load the SFC and DFC with the appropriate mode.
	movec		sfc,d6		* save old SFC/DFC
	movec		d0,sfc		* load new sfc
	movec		d0,dfc		* load new dfc

* pre-load the operand ATC. no page faults should occur here because
* _real_lock_page() should have taken care of this already.
	plpaw		(a1)			* load atc for ADDR
	plpaw		(a2)			* load atc for ADDR+3

* puch the operand lines from the cache if they exist.
	cpushl		dc,(a1)		* push dirty data
	cpushl		dc,(a2)		* push dirty data

* load the BUSCR values.
	move.l		#$80000000,a1		* assert LOCK* buscr value
	move.l		#$a0000000,a2		* assert LOCKE* buscr value
	move.l		#$00000000,a3		* buscr unlock value

* pre-load the instruction cache for the following algorithm.
* this will minimize the number of cycles that LOCK* will be asserted.

	bra.b		CASL2_ENTER		* start pre-loading icache


****************************************************************************
****************************************************************************
*
* D0 = dst operand <-
* D1 = xxxxxxxx
* D2 = update[31:24] operand
* D3 = update[23:8]  operand
* D4 = compare[31:0] operand
* D5 = update[7:0]  operand
* D6 = old SFC/DFC
* D7 = old SR
* A0 = ADDR
* A1 = bus LOCK*  value
* A2 = bus LOCKE* value
* A3 = bus unlock value
* A4 = xxxxxxxx
* A5 = xxxxxxxx
**
** DO NOT TOUCH CODE !!!
*
	opt 0
	cnop		0,$10
d4223 3
a4225 3
	movec		a1,buscr		* assert LOCK*
	moves.l		(a0),d0			* fetch Dest[31:0]
	cmp.l	 	d0,d4			* Dest - Compare
d4229 1
a4229 1
	bra.b		*+16
d4232 3
a4234 3
	moves.b		d2,(a0)+		* Update[31:24] -> DEST
	moves.w		d3,(a0)+		* Update[23:8] -> DEST+$1
	movec		a2,buscr		* assert LOCKE*
d4236 1
a4236 1
	bra.b		*+16
d4239 2
a4240 2
	moves.b		d5,(a0)			* Update[7:0] -> DEST+$3
	movec		a3,buscr		* unlock the bus
d4243 1
a4243 1
	bra.b		*+16
d4246 4
a4249 4
	rol.l		#$8,d0			* get Dest[31:24]
	moves.b		d0,(a0)+		* Dest[31:24] -> DEST
	swap		d0			* get Dest[23:8]
	moves.w		d0,(a0)+		* Dest[23:8] -> DEST+$1
d4251 1
a4251 1
	bra.b		*+16
d4254 3
a4256 3
	rol.l		#$8,d0			* get Dest[7:0]
	movec		a2,buscr		* assert LOCKE*
	moves.b		d0,(a0)			* Dest[7:0] -> DEST+$3
d4259 1
a4259 1
	bra.b		*+16
d4262 1
a4262 1
	movec		a3,buscr		* unlock the bus
d4267 1
a4267 1
	bra.b		*+16
d4279 4
a4282 8
	opt !

****************************************************************************
****************************************************************************
****
****
* end label used by _isp_cas_inrange()
	xdef  		_CASHI
a4283 2


@


1.0.1.3
log
@Added Macros for ISP Call Outs
@
text
@d2 1
a2 1
**--------------------------------------------------------------------------
d9 13
a21 1
* $Id: isp.asm,v 1.11 1996/02/16 12:34:37 schlote Exp $
d24 1
d26 10
d37 4
a40 15
* This  file  is appended to the top of the 060ISP package and contains the
* entry  points  into the package.  The user, in effect, branches to one of
* the branch table entries located after _060ISP_TABLE.
*
* Also,  subroutine  stubs  exist in this file (_isp_done for example) that
* are  referenced  by  the  ISP  package  itself  in  order to call a given
* routine.   The  stub routine actually performs the callout.  The ISP code
* does  a  "bsr" to the stub routine.  This extra layer of hierarchy adds a
* slight  performance  penalty but it makes the ISP code easier to read and
* more mainatinable.
*
****************************************************************************
	MACHINE	MC68060			; Destination CPU
	NEAR CODE                       ; Allow PC releative Only
****************************************************************************
d42 1
a42 2
		xref    _I_CALL_TOP	; External Jump Table for os support
_off_chk	equ	$00             ; Table offsets
d65 3
a67 1
****************************************************************************
a68 1
* NOTE: Disallow optimize
d70 17
a86 21
		xdef	_060ISP_TABLE
		OPT 0
_060ISP_TABLE:
		bra.l		_isp_unimp		* Main entry
		dc.w		0
		bra.l		_isp_cas                * Default CAS Handler
		dc.w		0                       * |
		bra.l		_isp_cas2               * |
		dc.w		0                       * V
		bra.l		_isp_cas_finish
		dc.w		0
		bra.l		_isp_cas2_finish
		dc.w		0
		bra.l		_isp_cas_inrange
		dc.w		0
		bra.l		_isp_cas_terminate
		dc.w		0
		bra.l		_isp_cas_restart
		dc.w		0
		ds.b		64
		opt !
a88 1
* Call stubs for external support routine
d90 1
a90 8
CALLOUT		MACRO
		xdef            \1
\1:		move.l		d0,-(sp)			* d0 retten
		move.l		( (_I_CALL_TOP).w + \2,pc),d0	* Hole ZielOffset
		pea.l		( (_I_CALL_TOP).w,pc,d0)        * Speiche Ziel auf Stack
		move.l		$4(sp),d0                       * d0 restaurieren
		rtd		#$4				* Jump Ziel & pop d0
                ENDM
d92 39
a130 4
		CALLOUT		_real_chk         ,_off_chk
		CALLOUT		_real_divbyzero   ,_off_divbyzero
		CALLOUT		_real_trace       ,_off_trace
		CALLOUT		_real_access      ,_off_access
d132 1
a132 1
		CALLOUT		_isp_done         ,_off_done
d134 31
a164 1
---------------------------------------------------------------------------
d166 1
a166 19
		CALLOUT		_real_cas	  ,_off_cas
		CALLOUT		_real_cas2	  ,_off_cas2

		CALLOUT		_real_lock_page	  ,_off_lock
		CALLOUT		_real_unlock_page ,_off_unlock

---------------------------------------------------------------------------

		CALLOUT		_imem_read	  ,_off_imr

		CALLOUT		_dmem_read        ,_off_dmr
		CALLOUT		_dmem_write       ,_off_dmw

		CALLOUT		_imem_read_word	  ,_off_irw
		CALLOUT		_imem_read_long	  ,_off_irl

		CALLOUT		_dmem_read_byte	  ,_off_drb
		CALLOUT		_dmem_read_word	  ,_off_drw
		CALLOUT		_dmem_read_long	  ,_off_drl
d168 87
a254 3
		CALLOUT		_dmem_write_byte  ,_off_dwb
		CALLOUT		_dmem_write_word  ,_off_dww
		CALLOUT		_dmem_write_long  ,_off_dwl
@


1.0.1.4
log
@Bugfix ->  Core Emu Stack Offsets for DataRegs (were reversed)
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.14 1996/02/16 14:12:18 schlote Exp $
d27 1
a27 1
*	NEAR CODE                       ; Allow PC releative Only
d30 1
a30 7
*		xref    _I_CALL_TOP	; External Jump Table for os support
*
* THIS SOURCE ASSUMES _I_CALL_TOP exactly -$80 Bytes before _060ISP_TABLE !!!!!!!!!
* CHANGE THIS TO REAL LINKAGE !!!!!!!

TOPOFF          equ	(_060ISP_TABLE-$80)

d64 4
a67 2
		dc.w		0                       * |  use this or own
		bra.l		_isp_cas2               * |  code
d69 1
a69 3
		bra.l		_isp_cas_finish         * External CAS Handler
		dc.w		0                       * |  exit here !!!
		bra.l		_isp_cas2_finish        * v
d71 1
a71 1
		bra.l		_isp_cas_inrange	* Was address fault inside emu core ??
d73 1
a73 1
		bra.l		_isp_cas_terminate      * Create ACCESS FAULT Frame
d75 1
a75 1
		bra.l		_isp_cas_restart        * Restart CAS op !
a83 1
		opt 0
d86 2
a87 2
		move.l		(TOPOFF+\2,pc),d0		* Hole ZielOffset
		pea.l		((TOPOFF).w,pc,d0.l)      	* Speiche Ziel auf Stack
a89 1
		opt !
d92 4
a95 4
		CALLOUT		_real_chk,_off_chk      	* Chk Exception		\
		CALLOUT		_real_divbyzero,_off_divbyzero  * DivZero Exeception     | Route to OS
		CALLOUT		_real_trace,_off_trace          * Trace Exception        |
		CALLOUT		_real_access,_off_access      	* Access Fault          /
d97 1
a97 1
		CALLOUT		_isp_done,_off_done             * Emu done - RTE
d99 1
a99 1
*--------------------------------------------------------------------------
d101 2
a102 2
		CALLOUT		_real_cas,_off_cas		* Custom CAS Emu callout
		CALLOUT		_real_cas2,_off_cas2
d104 2
a105 2
		CALLOUT		_real_lock_page,_off_lock      	* Lock Memory page for CAS
		CALLOUT		_real_unlock_page,_off_unlock
d107 1
a107 1
*--------------------------------------------------------------------------
d109 1
a109 1
		CALLOUT		_imem_read,_off_imr             * Memory access CALLOUTS
d111 2
a112 2
		CALLOUT		_dmem_read,_off_dmr
		CALLOUT		_dmem_write,_off_dmw
d114 2
a115 2
		CALLOUT		_imem_read_word,_off_irw
		CALLOUT		_imem_read_long,_off_irl
d117 3
a119 3
		CALLOUT		_dmem_read_byte,_off_drb
		CALLOUT		_dmem_read_word,_off_drw
		CALLOUT		_dmem_read_long,_off_drl
d121 3
a123 3
		CALLOUT		_dmem_write_byte,_off_dwb
		CALLOUT		_dmem_write_word,_off_dww
		CALLOUT		_dmem_write_long,_off_dwl
d129 1
a129 1
* in order to promote readability within the core code itself.
d154 7
a161 7
EXC_D1		rs.l		1		* offset of d1
EXC_D2		rs.l		1		* offset of d2
EXC_D3		rs.l		1		* offset of d3
EXC_D4		rs.l		1		* offset of d4
EXC_D5		rs.l		1		* offset of d5
EXC_D6		rs.l		1		* offset of d6
EXC_D7		rs.l		1		* offset of d7
@


1.0.1.5
log
@Changed to Resident Tag for Amiga
.
@
text
@d2 1
a2 1
**------------------------------------------------------------------------------------------------------
d7 1
a7 1
**------------------------------------------------------------------------------------------------------
d9 1
a9 1
* $Id: isp.asm,v 1.0.1.4 1996/02/19 23:02:26 schlote Exp schlote $
d11 13
a23 1
* This file is derived from the isp.asm,v 1.0.1.4 1996/02/19 23:02:26
d25 4
a28 1
**------------------------------------------------------------------------------------------------------
d30 1
a30 60
	incdir	include:
	include	all_lvo.i
	include	exec/exec.i
	include	exec/types.i
	include	exec/nodes.i
	include	exec/resident.i

	include	isp.i	; move stuff to header

	MACHINE	MC68060	; Destination CPU
	NEAR CODE               	; Allow PC releative Only
 	OPT !		; Keep optimize on

**------------------------------------------------------------------------------------------------------

ISP060_Start:	ILLEGAL
	dc.l             ISP060_Start
	dc.l	ISP060_End
	dc.b	RTF_AUTOINIT|RTF_COLDSTART	; This is a coldstart resident
	dc.b	43                             ; Version 43
	dc.b             NT_UNKNOWN		; Type
	dc.b	115		; Do patches right before diag.init
	dc.l	ISP060_Name
	dc.l	ISP060_Info
	dc.l	ISP060_Code
ISP060_Name:	dc.b	'cpu060.patch 43.0 (19.02.96)',0	; name
ISP060_Info:	dc.b	'mc68060 ISP Amiga\r\n',0      	; give some info
	dc.b	'1997 by Carsten Schlote,'
	dc.b	' Software Developments\r\n',0
                        even                                          		; align code

**------------------------------------------------------------------------------------------------------

ISP060_Code:	*PRINT	''
	*PRINT	'INSTALLING_MOVEP'

	MOVEM.L	A0/A1/A5/A6,-(SP)
	MOVEA.L	(4).L,A6
	LEA	(ISP060_SuperCode,PC),A5
	JSR	(_LVOSupervisor,A6)
	MOVEM.L	(SP)+,A0/A1/A5/A6

	*PRINT	'MOVEP_INSTALLED'
	RTS

ISP060_SuperCode:	MOVEC	VBR,A0
	LEA	(_isp_unimp,PC),A1
	MOVE.L	A1,(61*4,A0)			; Modify Vector 61
	RTE

**------------------------------------------------------------------------------------------------------
*
* This  file  is  appended  to  the top of the 060ISP package and contains the entry points into the
* package.   The  user,  in  effect,  branches  to  one  of  the  branch table entries located after
* _060ISP_TABLE.
*
* Also,  subroutine  stubs exist in this file (_isp_done for example) that are referenced by the ISP
* package  itself in order to call a given routine.  The stub routine actually performs the callout.
* The  ISP  code  does  a  "bsr"  to  the stub routine.  This extra layer of hierarchy adds a slight
* performance penalty but it makes the ISP code easier to read and more mainatinable.
d32 27
a58 1
***------------------------------------------------------------------------------------------------------
a62 93
*
* 	xdef	_060ISP_TABLE
* 	OPT 0
* _060ISP_TABLE:
* 	bra.l	_isp_unimp	* Main entry
* 	dc.w	0
* 	bra.l	_isp_cas                * Default CAS Handler
* 	dc.w	0                       * |  use this or own
* 	bra.l	_isp_cas2               * |  code
* 	dc.w	0
* 	bra.l	_isp_cas_finish         * External CAS Handler
* 	dc.w	0                       * |  exit here !!!
* 	bra.l	_isp_cas2_finish        * v
* 	dc.w	0
* 	bra.l	_isp_cas_inrange	* Was address fault inside emu core ??
* 	dc.w	0
* 	bra.l	_isp_cas_terminate      * Create ACCESS FAULT Frame
* 	dc.w	0
* 	bra.l	_isp_cas_restart        * Restart CAS op !
* 	dc.w	0
* 	ds.b	64


**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
*
* XDEF :
*
* 	_isp_unimp(): 	060ISP entry point for Unimplemented Instruction
*
* 	This handler should be the first code executed upon taking the
* 	"Unimplemented Integer Instruction" exception in an operating
* 	System.
*
* XREF :
*
* 	_imem_read_{word,long}() 	- read instruction word/longword
* 	_mul64() 		- emulate 64-bit multiply
* 	_div64() 		- emulate 64-bit divide
* 	_moveperipheral() 	- emulate "movep"
* 	_compandset() 		- emulate misaligned "cas"
* 	_compandset2() 		- emulate "cas2"
* 	_chk2_cmp2() 		- emulate "cmp2" and "chk2"
* 	_isp_done() 		- "callout" for normal final exit
* 	_real_trace() 		- "callout" for Trace exception
* 	_real_chk() 		- "callout" for Chk exception
* 	_real_divbyzero() 	- "callout" for DZ exception
* 	_real_access() 		- "callout" for access error exception
*
* INPUT :
*
* 	- The system stack contains the Unimp Int Instr stack frame
*
* OUTPUT :
*
* 	If Trace exception:        - The system stack changed to contain Trace exc stack frame
* 	If Chk exception:          - The system stack changed to contain Chk exc stack frame
* 	If DZ exception:           - The system stack changed to contain DZ exc stack frame
* 	If access error exception: - The system stack changed to contain access err exc stk frame
*	Else:
*			- Results saved as appropriate
*
* ALGORITHM :
*
*  This handler fetches the first instruction longword from memory and decodes it to determine which
* of the unimplemented integer instructions caused this exception.
*
*  This handler then calls one of:
*
*  _mul64(),  _div64(),  _moveperipheral(),  _compandset(),_compandset2(), or _chk2_cmp2()
*
*  as appropriate.
*
*  Some  of  these  instructions, by their nature, may produce other types of exceptions.  "div" can
* produce  a  divide-by-zero  exception, and "chk2" can cause a "Chk" exception.  In both cases, the
* current  exception  stack  frame  must  be  converted  to  an exception stack frame of the correct
* exception  type  and an exit must be made through _real_divbyzero() or _real_chk() as appropriate.
* In  addition,  all  instructions  may  be  executing  while Trace is enabled.  If so, then a Trace
* exception stack frame must be created and an exit made through _real_trace().
*
*  Meanwhile,  if  any  read  or  write to memory using the _mem_{read,write}() "callout"s returns a
* failing value, then an access error frame must be created and an exit made through _real_access().
*
* If none of these occur, then a normal exit is made through * _isp_done().
*
*  This  handler, upon entry, saves almost all user-visible address and data registers to the stack.
* Although  this  may seem to cause excess memory traffic, it was found that due to having to access
* these  register  files for things like data retrieval and <ea> calculations, it was more efficient
* to  have them on the stack where they could be accessed by indexing rather than to make subroutine
* calls to retrieve a register of a particular index.
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d64 215
a278 2
	** CAUTION : Access EXC_ data with negative Offsets
	**------------------------------------------------------------------------------
d280 2
a281 2
	XDEF  	_isp_unimp
	CNOP	0,16
d283 1
a283 1
	link.w 	a6,#-EXC_SIZEOF		* create room for stack frame
d285 2
a286 2
	movem.l	d0-d7/a0-a5,EXC_LV+EXC_DREGS(a6)		* store d0-d7/a0-a5
	move.l	(EXC_LV+EXC_A6OLD,a6),(EXC_LV+EXC_A6,a6)	* store a6
d288 2
a289 2
	btst	#$5,(SFF0_ISR,a6)		* from s or u mode?
	bne.b	uieh_s		* supervisor mode
d291 6
a296 2
	move.l	usp,a0		* fetch user stack pointer
	move.l	a0,(EXC_LV+EXC_A7,a6)		* store a7
d298 1
a298 4
	bra.b	uieh_cont
uieh_s:
	lea	((SFF0_IVOFF+2),a6),a0	* Get calc pre except. stack ptr
	move.l	a0,(EXC_LV+EXC_A7,a6)		* store corrected sp
a299 1
	**------------------------------------------------------------------------------
d301 1
a301 1
	clr.b	(EXC_LV+SPCOND_FLG,a6)		* clear "special case" flag
d303 52
a354 53
	move.w	(SFF0_ISR,a6),(EXC_LV+EXC_CC,a6) 	* store cc copy on stack
	move.l	(SFF0_IPC,a6),(EXC_LV+EXC_EXTWPTR,a6) 	* store extwptr on stack

	*
	* fetch the opword and first extension word pointed to by the stacked pc
	* and store them to the stack for now
	*

	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0		* fetch instruction addr
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)		* incr instruction ptr
	MOVE.L	(A0),(EXC_LV+EXC_OPWORD,a6)		* store extword on stack

	*************************************************************************
	* muls.l	0100 1100 00 |<ea>|	0*** 1100 0000 0***
	* mulu.l	0100 1100 00 |<ea>|	0*** 0100 0000 0***
	*
	* divs.l	0100 1100 01 |<ea>|	0*** 1100 0000 0***
	* divu.l	0100 1100 01 |<ea>|	0*** 0100 0000 0***
	*
	* movep.w m2r	0000 ***1 00 001***	| <displacement>  |
	* movep.l m2r	0000 ***1 01 001***	| <displacement>  |
	* movep.w r2m	0000 ***1 10 001***	| <displacement>  |
	* movep.l r2m	0000 ***1 11 001***	| <displacement>  |
	*
	* cas.w	0000 1100 11 |<ea>|	0000 000* **00 0***
	* cas.l	0000 1110 11 |<ea>|	0000 000* **00 0***
	*
	* cas2.w	0000 1100 11 111100	**** 000* **00 0***
	*		**** 000* **00 0***
	* cas2.l	0000 1110 11 111100	**** 000* **00 0***
	*		**** 000* **00 0***
	*
	* chk2.b	0000 0000 11 |<ea>|	**** 1000 0000 0000
	* chk2.w	0000 0010 11 |<ea>|	**** 1000 0000 0000
	* chk2.l	0000 0100 11 |<ea>|	**** 1000 0000 0000
	*
	* cmp2.b	0000 0000 11 |<ea>|	**** 0000 0000 0000
	* cmp2.w	0000 0010 11 |<ea>|	**** 0000 0000 0000
	* cmp2.l	0000 0100 11 |<ea>|	**** 0000 0000 0000
	*************************************************************************
	*
	* using bit 14 of the operation word, separate into 2 groups:
	* (group1) mul64, div64
	* (group2) movep, chk2, cmp2, cas2, cas
	*

	btst	#30,d0		* group1 or group2
	beq	uieh_group2		* go handle group2

	*
	* now, w/ group1, make mul64's decode the fastest since it will
	* most likely be used the most.
	*
d356 2
a357 2
	btst	#21,d0		* test for div64
	bne	uieh_div64		* go handle div64
d360 1
a360 3
	* mul64() may use ()+ addressing and may, therefore, alter a7

	bsr.l	_mul64		* _mul64()
d362 1
a362 2
	btst	#$5,(SFF0_ISR,a6)			* supervisor mode?
	beq.w	uieh_done
d364 7
a370 6
	btst	#mia7_bit,(EXC_LV+SPCOND_FLG,a6) 	* was a7 changed?
	beq.w	uieh_done			* no

	btst	#$7,(SFF0_ISR,a6)			* is trace enabled?
	bne.w	uieh_trace_a7			* yes
	bra.w	uieh_a7			* no
d373 2
a374 4
	* div64() may use ()+ addressing and may, therefore, alter a7.
	* div64() may take a divide by zero exception.

	bsr.l	_div64			* _div64()
d376 1
a376 1
	* here, we sort out all of the special cases that may have happened.
d378 3
a380 2
	btst	#mia7_bit,(EXC_LV+SPCOND_FLG,a6) 	* was a7 changed?
	bne.b	uieh_div64_a7			* yes
d382 3
a384 3
	btst	#idbyz_bit,(EXC_LV+SPCOND_FLG,a6) 	* did divide-by-zero occur?
	bne.w	uieh_divbyzero			* yes
	bra.w	uieh_done			* no
d386 2
a387 2
	btst	#$5,(SFF0_ISR,a6)			* supervisor mode?
	beq.b	uieh_div64_dbyz			* no
d389 16
a404 17
	* here, a7 has been incremented by 4 bytes in supervisor mode. we still
	* may have the following 3 cases:
	*	(i)	(a7)+
	*	(ii)	(a7)+; trace
	*	(iii)	(a7)+; divide-by-zero
	*

	btst	#idbyz_bit,(EXC_LV+SPCOND_FLG,a6) 	* did divide-by-zero occur?
	bne.w	uieh_divbyzero_a7			* yes
	tst.b	(SFF0_ISR,a6)			* no; is trace enabled?
	bmi.w	uieh_trace_a7			* yes
	bra.w	uieh_a7			* no

	*
	* now, w/ group2, make movep's decode the fastest since it will
	* most likely be used the most.
	*
d406 2
a407 2
	btst	#23,d0		* test for not movep
	beq.b	uieh_not_movep
d410 2
a411 2
	bsr.l	_moveperipheral		* _movep()
	bra.w	uieh_done
d414 6
a419 2
	btst	#$1b,d0		* test for chk2,cmp2
	beq.b	uieh_chk2cmp2		* go handle chk2,cmp2
a420 3
	swap	d0		* put opword in lo word
	cmp.b	#$fc,d0		* test for cas2
	beq.b	uieh_cas2		* go handle cas2
a421 1
	bsr.l	_compandset		* _cas()
d423 4
a426 2
	* the cases of "cas Dc,Du,(a7)+" and "cas Dc,Du,-(a7)" used from supervisor
	* mode are simply not considered valid and therefore are not handled.
d428 1
a428 1
	bra.w	uieh_done
d430 1
a430 2
uieh_cas2:	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
d432 3
a434 2
	MOVE.W	(A0),D0		* read extension word
	MOVEQ	#0,D1
d436 2
d439 2
a440 2
	tst.l	d1		* ifetch error?
	bne.w	isp_iacc		* yes
d442 1
a442 2
	bsr.l	_compandset2		* _cas2()
	bra.w	uieh_done
d444 1
a444 1
uieh_chk2cmp2:	* chk2 may take a chk exception
d446 1
a446 1
	bsr.l	_chk2_cmp2		* _chk2_cmp2()
d448 1
a448 1
	* here we check to see if a chk trap should be taken
d450 3
a452 3
	cmp.b	#ichk_flg,(EXC_LV+SPCOND_FLG,a6)
	bne.w	uieh_done
	bra.b	uieh_chk_trap
d454 6
a459 5
	***************************************************************************
	*
	* the required emulation has been completed. now, clean up the necessary stack
	* info and prepare for rte
	*
d461 1
a461 79
	move.b	(EXC_LV+EXC_CC+1,a6),(SFF0_ISR+1,a6) * insert new ccodes

	* if exception occurred in user mode, then we have to restore a7 in case it
	* changed. we don't have to update a7  for supervisor mose because that case
	* doesn't flow through here

	btst	#$5,(SFF0_ISR,a6)		* user or supervisor?
	bne.b	uieh_finish		* supervisor

	move.l	(EXC_LV+EXC_A7,a6),a0		* fetch user stack pointer
	move.l	a0,usp		* restore it

uieh_finish:	movem.l	(EXC_LV+EXC_DREGS,a6),d0-d7/a0-a5 	* restore d0-d7/a0-a5

	btst	#$7,(SFF0_ISR,a6)		* is trace mode on?
	bne.b	uieh_trace		* yes;go handle trace mode

	move.l	(EXC_LV+EXC_EXTWPTR,a6),(SFF0_IPC,a6) 	* new pc on stack frame
	move.l	(EXC_LV+EXC_A6,a6),(a6)		* prepare new a6 for unlink

	unlk	a6		* unlink stack frame

	rte			* _isp_done

	*
	* The instruction that was just emulated was also being traced. The trace
	* trap for this instruction will be lost unless we jump to the trace handler.
	* So, here we create a Trace Exception format number two exception stack
	* frame from the Unimplemented Integer Intruction Exception stack frame
	* format number zero and jump to the user supplied hook "_real_trace()".
	*
	*	   UIEH FRAME	   TRACE FRAME
	*	*****************	*****************
	*	* $0    * $0f4  *	*    Current	*
	*	*****************	*      PC	*
	*	*    Current    *	*****************
	*	*      PC       *	*  $2   *  $024	*
	*	*****************	*****************
	*	*      SR       *	*     Next	*
	*	*****************	*      PC	*
	*              ->*     Old       *	*****************
	*  from link  -->*      A6       *	*      SR	*
	*	*****************	*****************
	*               /*      A7       *	*      New	* <-- for final unlink
	*              / *               *	*      A6	*
	* link frame <   *****************	*****************
	*             \      ~       ~	    ~	    ~
	*              \ *****************	*****************
	*

uieh_trace:	move.l	(EXC_LV+EXC_A6,a6),(-$4,a6)
	move.w	(SFF0_ISR,a6),($0,a6)
	move.l	(SFF0_IPC,a6),($8,a6)
	move.l	(EXC_LV+EXC_EXTWPTR,a6),($2,a6)
	move.w	#$2024,($6,a6)
	sub.l	#$4,a6
	unlk	a6
	rte		*	bra.l	_real_trace

	*
	*	   UIEH FRAME	    CHK FRAME
	*	*****************	*****************
	*	*   $0 *  $0f4  *	*    Current	*
	*	*****************	*      PC	*
	*	*    Current    *	*****************
	*	*      PC       *	*   $2 *  $018	*
	*	*****************	*****************
	*	*      SR       *	*     Next	*
	*	*****************	*      PC	*
	*	    (4 words)	*****************
	*		*      SR	*
	*		*****************
	*		    (6 words)

	*
	* the chk2 instruction should take a chk trap. so, here we must create a
	* chk stack frame from an unimplemented integer instruction exception frame
	* and jump to the user supplied entry point "_real_chk()".
	*
d463 74
d538 2
a539 2
	move.b	(EXC_LV+EXC_CC+1,a6),(SFF0_ISR+1,a6) 	* insert new ccodes
	movem.l	(EXC_LV+EXC_DREGS,a6),d0-d7/a0-a5	* restore d0-d7/a0-a5
d541 30
a570 49
	move.w	(SFF0_ISR,a6),(a6)			* put new SR on stack
	move.l	(SFF0_IPC,a6),($8,a6)			* put "Current PC" on stack
	move.l	(EXC_LV+EXC_EXTWPTR,a6),($2,a6) 	* put "Next PC" on stack
	move.w	#$2018,($6,a6)			* put Vector Offset on stack

	move.l	(EXC_LV+EXC_A6,a6),a6			* restore a6
	add.l	#EXC_SIZEOF,sp			* clear stack frame

	TST.B	(SP)
	BPL.B	real_chk_end
	*
	*	    CHK FRAME		   TRACE FRAME
	*	*****************	*****************
	*	*   Current PC  *	*   Current PC	*
	*	*****************	*****************
	*	*   $2 *  $018  *	*   $2 *  $024	*
	*	*****************	*****************
	*	*     Next      *	*     Next	*
	*	*      PC       *	*      PC	*
	*	*****************	*****************
	*	*      SR       *	*      SR	*
	*	*****************	*****************
	*
	MOVE.B	#$24,(7,SP)		* BRA.L	_060_real_trace
real_chk_end:	RTE                         		* bra.l	_real_chk



	*
	*	   UIEH FRAME	 DIVBYZERO FRAME
	*	*****************	*****************
	*	*   $0 *  $0f4  *	*    Current	*
	*	*****************	*      PC	*
	*	*    Current    *	*****************
	*	*      PC       *	* $2 *  $014	*
	*	*****************	*****************
	*	*      SR       *	*     Next	*
	*	*****************	*      PC	*
	*	    (4 words)	*****************
	*		*      SR	*
	*		*****************
	*		    (6 words)
	*

	* the divide instruction should take an integer divide by zero trap. so, here
	* we must create a divbyzero stack frame from an unimplemented integer
	* instruction exception frame and jump to the user supplied entry point
	* "_real_divbyzero()".
	*
d572 2
a573 2
	move.b	(EXC_LV+EXC_CC+1,a6),(SFF0_ISR+1,a6) 	* insert new ccodes
	movem.l	(EXC_LV+EXC_DREGS,a6),d0-d7/a0-a5	* restore d0-d7/a0-a5
d575 33
a607 52
	move.w	(SFF0_ISR,a6),(a6)			* put new SR on stack
	move.l	(SFF0_IPC,a6),($8,a6)			* put "Current PC" on stack
	move.l	(EXC_LV+EXC_EXTWPTR,a6),($2,a6) 	* put "Next PC" on stack
	move.w	#$2014,($6,a6)			* put Vector Offset on stack

	move.l	(EXC_LV+EXC_A6,a6),a6			* restore a6
	add.l	#EXC_SIZEOF,sp			* clear stack frame

_real_divbyzero:
	TST.B	(SP)			* bra.l	_real_divbyzero
	BPL.B	real_divbyzero_end
	*
	*	 DIVBYZERO FRAME	   TRACE FRAME
	*	*****************	*****************
	*	*   Current PC  *	*   Current PC	*
	*	*****************	*****************
	*	* $2 *  $014    *	* $2 *  $024	*
	*	*****************	*****************
	*	*     Next      *	*     Next	*
	*	*      PC       *	*      PC	*
	*	*****************	*****************
	*	*      SR       *	*      SR	*
	*	*****************	*****************
	*
	MOVE.B	#$24,(7,SP)
			* BRA.L	_060_real_trace
real_divbyzero_end:	RTE


	*
	*		 DIVBYZERO FRAME
	*		*****************
	*		*    Current	*
	*	   UIEH FRAME	*      PC	*
	*	*****************	*****************
	*	*   $0 *  $0f4  *	* $2 * $014	*
	*	*****************	*****************
	*	*    Current    *	*     Next	*
	*	*      PC       *	*      PC	*
	*	*****************	*****************
	*	*      SR       *	*      SR	*
	*	*****************	*****************
	*	    (4 words)	    (6 words)
	*
	* the divide instruction should take an integer divide by zero trap. so, here
	* we must create a divbyzero stack frame from an unimplemented integer
	* instruction exception frame and jump to the user supplied entry point
	* "_real_divbyzero()".
	*
	* However, we must also deal with the fact that (a7)+ was used from supervisor
	* mode, thereby shifting the stack frame up 4 bytes.
	*
d609 2
a610 2
	move.b	(EXC_LV+EXC_CC+1,a6),(SFF0_ISR+1,a6) 	* insert new ccodes
	movem.l	(EXC_LV+EXC_DREGS,a6),d0-d7/a0-a5	* restore d0-d7/a0-a5
d612 34
a645 34
	move.l	(SFF0_IPC,a6),($c,a6)			* put "Current PC" on stack
	move.w	#$2014,($a,a6)			* put Vector Offset on stack
	move.l	(EXC_LV+EXC_EXTWPTR,a6),($6,a6) 	* put "Next PC" on stack

	move.l	(EXC_LV+EXC_A6,a6),a6			* restore a6
	add.l	#4+EXC_SIZEOF,sp			* clear stack frame

	bra.l	_real_divbyzero

	*
	*		   TRACE FRAME
	*		*****************
	*		*    Current	*
	*	   UIEH FRAME	*      PC	*
	*	*****************	*****************
	*	*   $0 *  $0f4  *	* $2 * $024	*
	*	*****************	*****************
	*	*    Current    *	*     Next	*
	*	*      PC       *	*      PC	*
	*	*****************	*****************
	*	*      SR       *	*      SR	*
	*	*****************	*****************
	*	    (4 words)	    (6 words)
	*
	*
	* The instruction that was just emulated was also being traced. The trace
	* trap for this instruction will be lost unless we jump to the trace handler.
	* So, here we create a Trace Exception format number two exception stack
	* frame from the Unimplemented Integer Intruction Exception stack frame
	* format number zero and jump to the user supplied hook "_real_trace()".
	*
	* However, we must also deal with the fact that (a7)+ was used from supervisor
	* mode, thereby shifting the stack frame up 4 bytes.
	*
d647 2
a648 2
	move.b	(EXC_LV+EXC_CC+1,a6),(SFF0_ISR+1,a6) 	* insert new ccodes
	movem.l	(EXC_LV+EXC_DREGS,a6),d0-d7/a0-a5	* restore d0-d7/a0-a5
d650 23
a672 24
	move.l	(SFF0_IPC,a6),($c,a6)			* put "Current PC" on stack
	move.w	#$2024,($a,a6)			* put Vector Offset on stack
	move.l	(EXC_LV+EXC_EXTWPTR,a6),($6,a6)  	* put "Next PC" on stack

	move.l	(EXC_LV+EXC_A6,a6),a6			* restore a6
	add.l	#4+EXC_SIZEOF,sp			* clear stack frame

	rte				* bra.l	_real_trace


	*
	*		   UIEH FRAME
	*		*****************
	*		* $0 * $0f4	*
	*	   UIEH FRAME	*****************
	*	*****************	*     Next	*
	*	* $0 *  $0f4    *	*      PC	*
	*	*****************	*****************
	*	*    Current    *	*      SR	*
	*	*      PC       *	*****************
	*	*****************	    (4 words)
	*	*      SR       *
	*	*****************
	*	    (4 words)
d674 2
a675 2
	move.b	(EXC_LV+EXC_CC+1,a6),(SFF0_ISR+1,a6) 	* insert new ccodes
	movem.l	(EXC_LV+EXC_DREGS,a6),d0-d7/a0-a5 	* restore d0-d7/a0-a5
d677 13
a689 13
	move.w	#$00f4,($e,a6)			* put Vector Offset on stack
	move.l	(EXC_LV+EXC_EXTWPTR,a6),($a,a6) 	* put "Next PC" on stack
	move.w	(SFF0_ISR,a6),($8,a6)			* put SR on stack

	move.l	(EXC_LV+EXC_A6,a6),a6			* restore a6
	add.l	#8+EXC_SIZEOF,sp			* clear stack frame

	rte				* bra.l	_isp_done

	**********
	* this is the exit point if a data read or write fails.
	* a0 = failing address
	* d0 = fslw
d691 12
a702 2
	move.l	a0,(a6)		* save address
	move.l	d0,(-$4,a6)		* save partial fslw
d704 1
a704 2
	lea	(-64,a6),sp
	movem.l	(sp)+,d0-d7/a0-a6 		* restore d0-d7/a0-a6
d706 7
a712 16
	move.l	$c(sp),-(sp)		* move voff,hi(pc)
	move.l	$4(sp),$10(sp)		* store fslw
	move.l	$c(sp),$4(sp)		* store sr,lo(pc)
	move.l	$8(sp),$c(sp)		* store address
	move.l	(sp)+,$4(sp)		* store voff,hi(pc)
	move.w	#$4008,$6(sp)		* store new voff

	bra.b	isp_acc_exit

	* this is the exit point if an instruction word read fails.
	* FSLW:
	*	misaligned = true
	*	read = true
	* 	size = word
	* 	instruction = true
	* 	software emulation error = true
d714 8
a721 8
	movem.l	(EXC_LV+EXC_DREGS,a6),d0-d7/a0-a5 	* restore d0-d7/a0-a5
	unlk	a6			* unlink frame
	sub.w	#$8,sp			* make room for acc frame
	move.l	$8(sp),(sp)			* store sr,lo(pc)
	move.w	$c(sp),$4(sp)			* store hi(pc)
	move.w	#$4008,$6(sp)			* store new voff
	move.l	$2(sp),$8(sp)			* store address (=pc)
	move.l	#$09428001,$c(sp)			* store fslw
d724 3
a726 3
	btst	#$5,(sp)		* user or supervisor?
	beq.b	isp_acc_exit2		* user
	bset	#$2,$d(sp)		* set supervisor TM bit
d728 1
a728 8
	* The sample routine below simply executes an "rte" instruction which
	* is most likely the incorrect thing to do and could put the system
	* into an infinite loop. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ !!!!!!!!!!!
*
                        XDEF	_real_access
_real_access:				*bra.l	_real_access
	RTE

d730 2
a731 2
	* if the addressing mode was (an)+ or -(an), the address register must
	* be restored to it's pre-exception value before entering _real_access.
d733 5
a737 5
	cmp.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6)	* do we need a restore?
	bne.b	isp_restore_done			* no
	clr.l	d0
	move.b	(EXC_LV+EXC_SAVREG,a6),d0				* regno to restore
	move.l	(EXC_LV+EXC_SAVVAL,a6),(EXC_LV+EXC_AREGS,a6,d0.l*4) 	* restore value
d741 23
a763 26


**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* XDEF :
*	_calc_ea(): routine to calculate effective address
*
* XREF :
* 	_imem_read_word() - read instruction word
* 	_imem_read_long() - read instruction longword
* 	_dmem_read_long() - read data longword (for memory indirect)
* 	isp_iacc() - handle instruction access error exception
*	isp_dacc() - handle data access error exception
*
* INPUT
* 	d0 = number of bytes related to effective address (w,l)
*
* OUTPUT
*	If exiting through isp_dacc...
*		a0 = failing address
*		d0 = FSLW
*	elsif exiting though isp_iacc...
*		none
*	else
*		a0 = effective address
*
d765 31
a795 30
*
* 	The effective address type is decoded from the opword residing
* 	on the stack. A jump table is used to vector to a routine for the
* 	appropriate mode. Since none of the emulated integer instructions
* 	uses byte-sized operands, only handle word and long operations.
*
* 	Dn,An	- shouldn't enter here
*	(An)	- fetch An value from stack
* 	-(An)	- fetch An value from stack; return decr value;
*		  place decr value on stack; store old value in case of
*		  future access error; if -(a7), set mda7_flg in
*		  (EXC_LV+SPCOND_FLG
*	(An)+	- fetch An value from stack; return value;
*	  	  place incr value on stack; store old value in case of
*	  	  future access error; if (a7)+, set mia7_flg in
*		  (EXC_LV+SPCOND_FLG
*	(d16,An) 	- fetch An value from stack; read d16 using
*	 	  _imem_read_word(); fetch may fail -> branch to  isp_iacc()
*	(xxx).w,(xxx).l 	- use _imem_read_{word,long}() to fetch address; fetch may fail
*	*<data> 	- return address of immediate value; set immed_flg in (EXC_LV+SPCOND_FLG
*	(d16,PC) 	- fetch stacked PC value; read d16 using _imem_read_word();
*		  fetch may fail -> branch to isp_iacc()
*	everything else 	- read needed displacements as appropriate w/
*		  _imem_read_{word,long}(); read may fail; if memory
* 		  indirect, read indirect address using
*		  _dmem_read_long() which may also fail
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------

d797 1
a797 1
	xdef  	_calc_ea
d799 1
a799 1
	move.l	d0,a0		* move * bytes to a0
d801 3
a803 1
	* MODE and REG are taken from the (EXC_LV+EXC_OPWORD.
d805 2
a806 2
	move.w	(EXC_LV+EXC_OPWORD,a6),d0	* fetch opcode word
	move.w	d0,d1		* make a copy
d808 1
a808 2
	andi.w	#$3f,d0		* extract mode field
	andi.l	#$7,d1		* extract reg  field
d810 2
a811 4
	* jump to the corresponding function for each {MODE,REG} pair.

	move.w	((tbl_ea_mode).b,pc,d0.w*2),d0 	* fetch jmp distance
	jmp	((tbl_ea_mode).b,pc,d0.w*1) 		* jmp to correct ea mode
d813 2
a814 2
	illegal                         		* illegal opcode
	dc.w	64
d816 75
a890 75
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode

	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode

	dc.w	addr_ind_a0	- 	tbl_ea_mode
	dc.w	addr_ind_a1	- 	tbl_ea_mode
	dc.w	addr_ind_a2	- 	tbl_ea_mode
	dc.w	addr_ind_a3 	- 	tbl_ea_mode
	dc.w	addr_ind_a4 	- 	tbl_ea_mode
	dc.w	addr_ind_a5 	- 	tbl_ea_mode
	dc.w	addr_ind_a6 	- 	tbl_ea_mode
	dc.w	addr_ind_a7 	- 	tbl_ea_mode

	dc.w	addr_ind_p_a0	- 	tbl_ea_mode
	dc.w	addr_ind_p_a1 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a2 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a3 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a4 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a5 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a6 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a7 	- 	tbl_ea_mode

	dc.w	addr_ind_m_a0 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a1 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a2 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a3 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a4 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a5 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a6 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a7 	- 	tbl_ea_mode

	dc.w	addr_ind_disp_a0	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a1 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a2 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a3 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a4 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a5 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a6 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a7	-	tbl_ea_mode

	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode

	dc.w	abs_short	- 	tbl_ea_mode
	dc.w	abs_long	- 	tbl_ea_mode
	dc.w	pc_ind		- 	tbl_ea_mode
	dc.w	pc_ind_ext	- 	tbl_ea_mode
	dc.w	immediate	- 	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	- 	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	- 	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	- 	tbl_ea_mode

	***********************************
	* Address register indirect: (An) *
	***********************************
d892 1
a892 1
	move.l	(EXC_LV+EXC_A0,a6),a0	* Get current a0
d896 1
a896 1
	move.l	(EXC_LV+EXC_A1,a6),a0	* Get current a1
d900 1
a900 1
	move.l	(EXC_LV+EXC_A2,a6),a0	* Get current a2
d904 1
a904 1
	move.l	(EXC_LV+EXC_A3,a6),a0	* Get current a3
d908 1
a908 1
	move.l	(EXC_LV+EXC_A4,a6),a0	* Get current a4
d912 1
a912 1
	move.l	(EXC_LV+EXC_A5,a6),a0	* Get current a5
d916 1
a916 1
	move.l	(EXC_LV+EXC_A6,a6),a0	* Get current a6
d920 1
a920 1
	move.l	(EXC_LV+EXC_A7,a6),a0	* Get current a7
d923 3
a925 3
	*****************************************************
	* Address register indirect w/ postincrement: (An)+ *
	*****************************************************
d927 8
a934 8
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A0,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A0,a6)		* save incremented value

	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$0,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
d938 8
a945 8
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A1,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A1,a6)		* save incremented value

	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$1,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
d949 8
a956 8
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A2,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A2,a6)		* save incremented value

	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$2,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
d960 8
a967 8
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A3,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A3,a6)		* save incremented value

	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$3,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
d971 8
a978 8
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A4,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A4,a6)		* save incremented value

	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$4,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
d982 8
a989 8
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A5,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A5,a6)		* save incremented value

	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$5,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
d993 8
a1000 8
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A6,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A6,a6)		* save incremented value

	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$6,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
d1004 1
a1004 1
	move.b	#mia7_flg,(EXC_LV+SPCOND_FLG,a6) * set "special case" flag
d1006 4
a1009 4
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A7,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A7,a6)		* save incremented value
d1012 3
a1014 4
	****************************************************
	* Address register indirect w/ predecrement: -(An) *
	****************************************************

d1016 5
a1020 5
	move.l	(EXC_LV+EXC_A0,a6),d0		* Get current a0
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A0,a6)		* Save decr value
	move.l	d0,a0
d1022 2
a1023 2
	move.b	#$0,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
d1027 5
a1031 5
	move.l	(EXC_LV+EXC_A1,a6),d0		* Get current a1
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A1,a6)		* Save decr value
	move.l	d0,a0
d1033 2
a1034 2
	move.b	#$1,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
d1038 5
a1042 5
	move.l	(EXC_LV+EXC_A2,a6),d0		* Get current a2
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A2,a6)		* Save decr value
	move.l	d0,a0
d1044 2
a1045 2
	move.b	#$2,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
d1049 5
a1053 5
	move.l	(EXC_LV+EXC_A3,a6),d0		* Get current a3
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A3,a6)		* Save decr value
	move.l	d0,a0
d1055 2
a1056 2
	move.b	#$3,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
d1060 5
a1064 5
	move.l	(EXC_LV+EXC_A4,a6),d0		* Get current a4
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A4,a6)		* Save decr value
	move.l	d0,a0
d1066 2
a1067 2
	move.b	#$4,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
d1071 5
a1075 5
	move.l	(EXC_LV+EXC_A5,a6),d0		* Get current a5
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A5,a6)		* Save decr value
	move.l	d0,a0
d1077 2
a1078 2
	move.b	#$5,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
d1082 5
a1086 5
	move.l	(EXC_LV+EXC_A6,a6),d0		* Get current a6
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A6,a6)		* Save decr value
	move.l	d0,a0
d1088 2
a1089 2
	move.b	#$6,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
d1093 1
a1093 1
	move.b	#mda7_flg,(EXC_LV+SPCOND_FLG,a6) * set "special case" flag
d1095 4
a1098 4
	move.l	(EXC_LV+EXC_A7,a6),d0		* Get current a7
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A7,a6)		* Save decr value
	move.l	d0,a0
d1101 3
a1103 4
	********************************************************
	* Address register indirect w/ displacement: (d16, An) *
	********************************************************

d1105 3
a1107 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(a0),d0
	move.l	#-1,d1
d1109 2
a1110 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1112 2
a1113 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A0,a6),a0		* a0 + d16
d1117 3
a1119 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(a0),d0
	move.l	#-1,d1
d1121 2
a1122 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1124 2
a1125 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A1,a6),a0		* a1 + d16
d1129 3
a1131 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(a0),d0
	move.l	#-1,d1
d1133 2
a1134 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1136 2
a1137 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A2,a6),a0		* a2 + d16
d1141 3
a1143 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(a0),d0
	move.l	#-1,d1
d1145 2
a1146 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1148 2
a1149 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A3,a6),a0		* a3 + d16
d1153 3
a1155 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(a0),d0
	move.l	#-1,d1
d1157 2
a1158 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1160 2
a1161 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A4,a6),a0		* a4 + d16
d1165 3
a1167 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(a0),d0
	move.l	#-1,d1
d1169 2
a1170 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1172 2
a1173 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A5,a6),a0		* a5 + d16
d1177 3
a1179 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(a0),d0
	move.l	#-1,d1
d1181 2
a1182 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1184 2
a1185 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A6,a6),a0		* a6 + d16
d1189 17
a1205 19
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(a0),d0
	move.l	#-1,d1

	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes

	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A7,a6),a0		* a7 + d16
	rts

	************************************************************************
	* Address register indirect w/ index(8-bit displacement): (dn, An, Xn) *
	*    "       "         "    w/   "  (base displacement): (bd, An, Xn)  *
	* Memory indirect postindexed: ([bd, An], Xn, od)	       *
	* Memory indirect preindexed: ([bd, An, Xn], od)	       *
	************************************************************************
d1207 1
a1207 4
	move.l	d1,-(sp)

	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
d1209 3
a1211 3
	*bsr.l	_imem_read_word
	MOVE.W	(A0),D0		* fetch extword in d0
	MOVEQ	#0,D1
d1213 2
a1214 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1216 1
a1216 1
	move.l	(sp)+,d1
d1218 1
a1218 1
	move.l	(EXC_LV+EXC_AREGS,a6,d1.w*4),a0 * put base in a0
d1220 2
a1221 2
	btst	#$8,d0
	beq.b	addr_ind_index_8bit		* for ext word or not?
d1223 1
a1223 1
	movem.l	d2-d5,-(sp)		* save d2-d5
d1225 2
a1226 2
	move.l	d0,d5		* put extword in d5
	move.l	a0,d3		* put base in d3
d1228 1
a1228 1
	bra.l	calc_mem_ind		* calc memory indirect
d1231 1
a1231 1
	move.l	d2,-(sp)		* save old d2
d1233 3
a1235 3
	move.l	d0,d1
	rol.w	#$4,d1
	andi.w	#$f,d1		* extract index regno
d1237 1
a1237 1
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d1 * fetch index reg value
d1239 3
a1241 3
	btst	#$b,d0		* is it word or long?
	bne.b	aii8_long
	ext.l	d1		* sign extend word index
d1243 20
a1262 20
	move.l	d0,d2
	rol.w	#$7,d2
	andi.l	#$3,d2		* extract scale value

	lsl.l	d2,d1		* shift index by scale

	extb.l	d0		* sign extend displacement
	add.l	d1,d0		* index + disp
	add.l	d0,a0		* An + (index + disp)

	move.l	(sp)+,d2		* restore old d2
	rts

	**********************
	* Immediate: *<data> *
	*************************************************************************
	* word, long: <ea> of the data is the current extension word	*
	* 	pointer value. new extension word pointer is simply the old	*
	* 	plus the number of bytes in the data type(2 or 4).	*
	*************************************************************************
d1264 3
a1266 2
	move.b	#immed_flg,(EXC_LV+SPCOND_FLG,a6) * set immediate flag
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch extension word ptr
d1269 3
a1271 3
	***************************
	* Absolute short: (XXX).W *
	***************************
d1273 3
a1275 2
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
d1277 2
a1278 3
	*bsr.l	_imem_read_word		* fetch short address
	MOVE.W	(A0),D0
	MOVEQ	#0,D1
d1280 1
a1280 4
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes

	move.w	d0,a0		* return <ea> in a0
d1283 3
a1285 3
	**************************
	* Absolute long: (XXX).L *
	**************************
d1287 3
a1289 6
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_long		* fetch long address
	MOVE.L	(a0),d0
	move.l	#-1,d1

d1291 2
a1292 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1294 1
a1294 1
	move.l	d0,a0		* return <ea> in a0
d1297 3
a1299 3
	*******************************************************
	* Program counter indirect w/ displacement: (d16, PC) *
	*******************************************************
d1301 3
a1303 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word		* fetch word displacement
	MOVE.W	(A0),D0
	MOVEQ	#0,D1
d1305 2
a1306 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1308 1
a1308 1
	move.w	d0,a0		* sign extend displacement
d1310 1
a1310 1
	add.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* pc + d16
d1312 3
a1314 1
	* _imem_read_word() increased the extwptr by 2. need to adjust here.
a1315 1
	subq.l	#$2,a0		* adjust <ea>
d1318 6
a1323 6
	**********************************************************
	* PC indirect w/ index(8-bit displacement): (d8, PC, An) *
	* "     "     w/   "  (base displacement): (bd, PC, An)  *
	* PC memory indirect postindexed: ([bd, PC], Xn, od)     *
	* PC memory indirect preindexed: ([bd, PC, Xn], od)      *
	**********************************************************
d1325 3
a1327 8
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word		* fetch ext word
	MOVE.W	(A0),D0
	MOVEQ	#0,D1

	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1329 2
a1330 2
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* put base in a0
	subq.l	#$2,a0		* adjust base
d1332 2
a1333 2
	btst	#$8,d0		* is disp only 8 bits?
	beq.b	pc_ind_index_8bit		* yes
d1335 2
a1336 2
	* the indexed addressing mode uses a base displacement of size
	* word or long
d1338 3
a1340 1
	movem.l	d2-d5,-(sp)		* save d2-d5
d1342 2
a1343 2
	move.l	d0,d5		* put extword in d5
	move.l	a0,d3		* put base in d3
d1345 1
a1345 1
	bra.l	calc_mem_ind		* calc memory indirect
d1348 1
a1348 1
 	move.l	d2,-(sp)		* create a temp register
d1350 3
a1352 3
	move.l	d0,d1		* make extword copy
	rol.w	#$4,d1		* rotate reg num into place
	andi.w	#$f,d1		* extract register number
d1354 1
a1354 1
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d1 * fetch index reg value
d1356 3
a1358 3
	btst	#$b,d0		* is index word or long?
	bne.b	pii8_long	* long
	ext.l	d1		* sign extend word index
d1360 3
a1362 3
	move.l	d0,d2		* make extword copy
	rol.w	#$7,d2		* rotate scale value into place
	andi.l	#$3,d2		* extract scale value
d1364 1
a1364 1
	lsl.l	d2,d1		* shift index by scale
d1366 3
a1368 3
	extb.l	d0		* sign extend displacement
	add.l	d1,d0		* index + disp
	add.l	d0,a0		* An + (index + disp)
d1370 1
a1370 1
	move.l	(sp)+,d2	* restore temp register
d1374 3
a1376 8
	* a5 = (EXC_LV+EXC_extwptr	(xdef   to uaeh)
	* a4 = (EXC_LV+EXC_opword	(xdef   to uaeh)
	* a3 = (EXC_LV+EXC_dregs	(xdef   to uaeh)

	* d2 = index	(internal "     "    )
	* d3 = base	(internal "     "    )
	* d4 = od	(internal "     "    )
	* d5 = extword	(internal "     "    )
d1378 4
d1383 4
a1386 4
	btst	#$6,d5		* is the index suppressed?
	beq.b	calc_index
	clr.l	d2		* yes, so index = 0
	bra.b	base_supp_ck
d1388 5
a1392 5
	bfextu	d5{16:4},d2
	move.l	(EXC_LV+EXC_DREGS,a6,d2.w*4),d2
	btst	#$b,d5		* is index word or long?
	bne.b	no_ext
	ext.l	d2
d1394 2
a1395 2
	bfextu	d5{21:2},d0
	lsl.l	d0,d2
d1397 3
a1399 3
	btst	#$7,d5		* is the bd suppressed?
	beq.b	no_base_sup
	clr.l	d3
d1401 9
a1409 11
	bfextu	d5{26:2},d0		* get bd size
*	beq.l	_error		* if (size == 0) it's reserved
	cmp.b	#2,d0
	blt.b	no_bd
	beq.b	get_word_bd

	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_long
	MOVE.L	(A0),D0
	MOVEQ	#0,D1
d1411 2
a1412 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1414 1
a1414 1
	bra.b	chk_ind
d1416 3
a1418 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(A0),D0
	MOVEQ	#0,D1
d1420 2
a1421 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1423 1
a1423 1
	ext.l	d0		* sign extend bd
d1426 1
a1426 1
	add.l	d0,d3		* base += bd
d1428 9
a1436 11
	bfextu	d5{30:2},d0		* is od suppressed?
	beq.w	aii_bd
	cmp.b	#2,d0
	blt.b	null_od
	beq.b	word_od

	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_long
	MOVE.L	(A0),D0
	MOVEQ	#0,D1
d1438 2
a1439 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1441 1
a1441 1
	bra.b 	add_them
d1444 3
a1446 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_word
	MOVE.W	(A0),D0
	MOVEQ	#0,D1
d1448 2
a1449 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d1451 2
a1452 2
	ext.l	d0		* sign extend od
	bra.b	add_them
d1455 1
a1455 1
	clr.l	d0
d1457 13
a1469 15
	move.l	d0,d4
	btst	#$2,d5		* pre or post indexing?
	beq.b	pre_indexed

	move.l	d3,a0
	*bsr.l	_dmem_read_long
	MOVE.L	(A0),D0
	MOVEQ	#0,D1

	tst.l	d1		* dfetch error?
	bne.b	calc_ea_err	* yes

	add.l	d2,d0		* <ea> += index
	add.l	d4,d0		* <ea> += od
	bra.b	done_ea
d1472 3
a1474 5
	add.l	d2,d3		* preindexing
	move.l	d3,a0
	*bsr.l	_dmem_read_long
	MOVE.W	(A0),D0
	MOVEQ	#0,D1
d1476 2
a1477 2
	tst.l	d1		* ifetch error?
	bne.b	calc_ea_err		* yes
d1479 2
a1480 2
	add.l	d4,d0		* ea += od
	bra.b	done_ea
d1483 6
a1488 4
	add.l	d2,d3		* ea = (base + bd) + index
	move.l	d3,d0
done_ea:	move.l	d0,a0
	movem.l	(sp)+,d2-d5		* restore d2-d5
d1491 8
a1498 8
	* if dmem_read_long() returns a fail message in d1, the package
	* must create an access error frame. here, we pass a skeleton fslw
	* and the failing address to the routine that creates the new frame.
	* FSLW:
	* 	read = true
	* 	size = longword
	*	TM = data
	* 	software emulation error = true
d1500 39
a1538 43
	move.l	d3,a0		* pass failing address
	move.l	#$01010001,d0		* pass fslw
	bra.l	isp_dacc


**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* XDEF
* 	_moveperipheral(): routine to emulate movep instruction
*
* XREF
*	_dmem_read_byte() - read byte from memory
*	_dmem_write_byte() - write byte to memory
*	isp_dacc() - handle data access error exception
*
* INPUT
*	none
*
* OUTPUT
*	If exiting through isp_dacc...
*	a0 = failing address
*	d0 = FSLW
*	else
*	none
*
* ALGORITHM
*
* Decode  the  movep  instruction  words  stored  at (EXC_LV+EXC_OPWORD and either read or write the
* required  bytes from/to memory.  Use the _dmem_{read,write}_byte() routines.  If one of the memory
* routines  returns  a failing value, we must pass the failing address and a FSLW to the _isp_dacc()
* routine.
*
* Since this instruction is used to access peripherals, make sure
* to only access the required bytes.
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------

	***************************
	* movep.(w,l)	Dx,(d,Ay) *
	* movep.(w,l)	(d,Ay),Dx *
	***************************
	xdef   	_moveperipheral
d1540 1
a1540 1
	move.w	(EXC_LV+EXC_OPWORD,a6),d1	* fetch the opcode word
d1542 2
a1543 2
	move.b	d1,d0
	and.w	#$7,d0		* extract Ay from opcode word
d1545 1
a1545 1
	move.l	(EXC_LV+EXC_AREGS,a6,d0.w*4),a0 * fetch ay
d1547 1
a1547 1
	add.w	(EXC_LV+EXC_EXTWORD,a6),a0	* add: an + sgn_ext(disp)
d1549 2
a1550 2
	btst	#$7,d1		* (reg 2 mem) or (mem 2 reg)
	beq.w	mem2reg
d1552 1
a1552 1
	* reg2mem: fetch dx, then write it to memory
d1554 3
a1556 3
	move.w	d1,d0
	rol.w	#$7,d0
	and.w	#$7,d0		* extract Dx from opcode word
d1558 1
a1558 1
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4), d0 * fetch dx
d1560 2
a1561 2
	btst	#$6,d1		* word or long operation?
	beq.b	r2mwtrans
d1563 2
a1564 2
	* a0 = dst addr
	* d0 = Dx
d1566 4
a1569 4
	move.l	d0,d2		* store data
	move.l	a0,a2		* store addr
	rol.l	#$8,d2
	move.l	d2,d0
d1571 1
a1571 3
	*bsr.l	_dmem_write_byte		* os  : write hi
	MOVE.B	D0,(A0)
	MOVEQ	#0,D1
d1573 2
a1574 2
	tst.l	d1		* dfetch error?
	bne.w	movp_write_err		* yes
d1576 4
a1579 4
	add.w	#$2,a2		* incr addr
	move.l	a2,a0
	rol.l	#$8,d2
	move.l	d2,d0
d1581 1
a1581 3
	*bsr.l	_dmem_write_byte		* os  : write lo
	MOVE.B	D0,(A0)
	MOVEQ	#0,D1
d1583 2
a1584 2
	tst.l	d1		* dfetch error?
	bne.w	movp_write_err		* yes
d1586 4
a1589 4
	add.w	#$2,a2		* incr addr
	move.l	a2,a0
	rol.l	#$8,d2
	move.l	d2,d0
d1591 1
a1591 3
	*bsr.l	_dmem_write_byte		* os  : write lo
	MOVE.B	D0,(A0)
	MOVEQ	#0,D1
d1593 2
a1594 2
	tst.l	d1		* dfetch error?
	bne.w	movp_write_err		* yes
d1596 4
a1599 4
	add.w	#$2,a2		* incr addr
	move.l	a2,a0
	rol.l	#$8,d2
	move.l	d2,d0
d1601 1
a1601 3
	*bsr.l	_dmem_write_byte		* os  : write lo
	MOVE.B	D0,(A0)
	MOVEQ	#0,D1
d1603 2
a1604 2
	tst.l	d1		* dfetch error?
	bne.w	movp_write_err		* yes
d1608 2
a1609 2
	* a0 = dst addr
	* d0 = Dx
d1611 3
a1613 3
	move.l	d0,d2		* store data
	move.l	a0,a2		* store addr
	lsr.w	#$8,d0
d1615 1
a1615 3
	*bsr.l	_dmem_write_byte		* os  : write hi
	MOVE.B	D0,(A0)
	MOVEQ	#0,D1
d1617 2
a1618 2
	tst.l	d1		* dfetch error?
	bne.w	movp_write_err		* yes
d1620 3
a1622 3
	add.w	#$2,a2
	move.l	a2,a0
	move.l	d2,d0
d1624 1
a1624 3
	*bsr.l	_dmem_write_byte		* os  : write lo
	MOVE.B	D0,(A0)
	MOVEQ	#0,D1
d1626 2
a1627 2
	tst.l	d1		* dfetch error?
	bne.w	movp_write_err		* yes
d1631 2
a1632 2
	* mem2reg: read bytes from memory.
	* determines the dest register, and then writes the bytes into it.
d1634 2
a1635 2
	btst	#$6,d1		* word or long operation?
	beq.b	m2rwtrans
d1639 1
a1639 1
	move.l	a0,a2		* store addr
d1641 1
a1641 3
	*bsr.l	_dmem_read_byte		* read first byte
	MOVE.B	(A0),d0
	MOVEQ	#0,D1
d1643 2
a1644 2
	tst.l	d1		* dfetch error?
	bne.w	movp_read_err		* yes
d1646 1
a1646 1
	move.l	d0,d2
d1648 2
a1649 2
	add.w	#$2,a2		* incr addr by 2 bytes
	move.l	a2,a0
d1651 1
a1651 3
	*bsr.l	_dmem_read_byte		* read second byte
	MOVE.B	(A0),d0
	MOVEQ	#0,D1
d1653 2
a1654 2
	tst.l	d1		* dfetch error?
	bne.w	movp_read_err		* yes
d1656 2
a1657 2
	lsl.w	#$8,d2
	move.b	d0,d2		* append bytes
d1659 2
a1660 2
	add.w	#$2,a2		* incr addr by 2 bytes
	move.l	a2,a0
d1662 1
a1662 3
	*bsr.l	_dmem_read_byte		* read second byte
	MOVE.B	(A0),d0
	MOVEQ	#0,D1
d1664 2
a1665 2
	tst.l	d1		* dfetch error?
	bne.w	movp_read_err		* yes
d1667 2
a1668 2
	lsl.l	#$8,d2
	move.b	d0,d2		* append bytes
d1670 2
a1671 2
	add.w	#$2,a2		* incr addr by 2 bytes
	move.l	a2,a0
d1673 1
a1673 3
	*bsr.l	_dmem_read_byte		* read second byte
	MOVE.B	(A0),d0
	MOVEQ	#0,D1
d1675 2
a1676 2
	tst.l	d1		* dfetch error?
	bne.w	movp_read_err		* yes
d1678 2
a1679 2
	lsl.l	#$8,d2
	move.b	d0,d2		* append bytes
d1681 3
a1683 3
	move.b	(EXC_LV+EXC_OPWORD,a6),d1
	lsr.b	#$1,d1
	and.w	#$7,d1		* extract Dx from opcode word
d1685 1
a1685 1
	move.l	d2,(EXC_LV+EXC_DREGS,a6,d1.w*4) * store dx
d1689 1
a1689 1
	* a0 = dst addr
d1691 1
a1691 1
	move.l	a0,a2		* store addr
d1693 1
a1693 3
	*bsr.l	_dmem_read_byte		* read first byte
	MOVE.B	(A0),d0
	MOVEQ	#0,D1
d1695 2
a1696 2
	tst.l	d1		* dfetch error?
	bne.w	movp_read_err		* yes
d1698 1
a1698 1
	move.l	d0,d2
d1700 2
a1701 2
	add.w	#$2,a2		* incr addr by 2 bytes
	move.l	a2,a0
d1703 1
a1703 3
	*bsr.l	_dmem_read_byte		* read second byte
	MOVE.B	(A0),d0
	MOVEQ	#0,D1
d1705 2
a1706 2
	tst.l	d1		* dfetch error?
	bne.w	movp_read_err		* yes
d1708 2
a1709 2
	lsl.w	#$8,d2
	move.b	d0,d2		* append bytes
d1711 3
a1713 3
	move.b	(EXC_LV+EXC_OPWORD,a6),d1
	lsr.b	#$1,d1
	and.w	#$7,d1		* extract Dx from opcode word
d1715 1
a1715 1
	move.w	d2,(EXC_LV+EXC_DREGS+2,a6,d1.w*4) * store dx
d1719 8
a1726 8
	* if dmem_{read,write}_byte() returns a fail message in d1, the package
	* must create an access error frame. here, we pass a skeleton fslw
	* and the failing address to the routine that creates the new frame.
	* FSLW:
	* 	write = true
	*	size = byte
	*	TM = data
	*	software emulation error = true
d1728 9
a1736 9
	move.l	a2,a0		* pass failing address
	move.l	#$00a10001,d0		* pass fslw
	bra.l	isp_dacc

	* FSLW:
	* 	read = true
	*	size = byte
	*	TM = data
	*	software emulation error = true
d1738 39
a1776 40
	move.l	a2,a0		* pass failing address
	move.l	#$01210001,d0	* pass fslw
	bra.l	isp_dacc


**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* XDEF
* 	_chk2_cmp2(): routine to emulate chk2/cmp2 instructions
*
* XREF
*	_calc_ea(): calculate effective address
*	_dmem_read_long(): read operands
* 	_dmem_read_word(): read operands
*	isp_dacc(): handle data access error exception
*
* INPUT ***************************************************************
*	none
*
* OUTPUT **************************************************************
*	If exiting through isp_dacc...
*	a0 = failing address
*	d0 = FSLW
*	else
* 	none
*
* ALGORITHM ***********************************************************
*
*  First,  calculate  the  effective address, then fetch the byte, word, or longword sized operands.
* Then,  in  the  interest  of  simplicity,  all operands are converted to longword size whether the
* operation  is  byte,  word,  or  long.  The bounds are sign extended accordingly.  If Rn is a data
* regsiter,  Rn  is  also sign extended.  If Rn is an address register, it need not be sign extended
* since the full register is always used.
*
* The  comparisons  are made and the condition codes calculated.  If the instruction is chk2 and the
* Rn  value is out-of-bounds, set the ichk_flg in (EXC_LV+SPCOND_FLG.  If the memory fetch returns a
* failing value, pass the failing address and FSLW to the isp_dacc() routine.
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d1778 1
a1778 1
	xdef   	_chk2_cmp2
d1781 13
a1793 2
	* passing size parameter doesn't matter since chk2 # cmp2 can't do
	* either predecrement, postincrement, or immediate.
d1795 5
a1799 1
	bsr.l	_calc_ea		* calculate <ea>
d1801 2
a1802 3
	move.b	(EXC_LV+EXC_EXTWORD,a6), d0	* fetch hi extension word
	rol.b	#$4, d0		* rotate reg bits into lo
	and.w	#$f, d0		* extract reg bits
d1804 18
a1821 1
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4), d2 * get regval
d1823 2
a1824 3
	cmp.b	#$2,(EXC_LV+EXC_OPWORD,a6)	* what size is operation?
	blt.b	chk2_cmp2_byte		* size == byte
	beq.b	chk2_cmp2_word		* size == word
d1826 2
a1827 33
	* the bounds are longword size. call routine to read the lower
	* bound into d0 and the higher bound into d1.
chk2_cmp2_long:
	move.l	a0,a2		* save copy of <ea>
	*bsr.l	_dmem_read_long		* fetch long lower bound
	MOVE.L	(A0),D0
	MOVEQ	#0,D1

	tst.l	d1		* dfetch error?
	bne.w	chk2_cmp2_err_l		* yes

	move.l	d0,d3		* save long lower bound
	addq.l	#$4,a2
	move.l	a2,a0		* pass <ea> of long upper bound
	*bsr.l	_dmem_read_long		* fetch long upper bound
	MOVE.L	(A0),D0
	MOVEQ	#0,D1

	tst.l	d1		* dfetch error?
	bne.w	chk2_cmp2_err_l		* yes

	move.l	d0,d1		* long upper bound in d1
	move.l	d3,d0		* long lower bound in d0
	bra.w	chk2_cmp2_compare		* go do the compare emulation

	* the bounds are word size. fetch them in one subroutine call by
	* reading a longword. sign extend both. if it's a data operation,
	* sign extend Rn to long, also.
chk2_cmp2_word:
	move.l	a0,a2
	*bsr.l	_dmem_read_long		* fetch 2 word bounds
	MOVE.L	(A0),D0
	MOVEQ	#0,D1
d1829 2
a1830 2
	tst.l	d1		* dfetch error?
	bne.w	chk2_cmp2_err_l		* yes
d1832 2
a1833 2
	move.w	d0, d1		* place hi in d1
	swap	d0		* place lo in d0
d1835 4
a1838 2
	ext.l	d0		* sign extend lo bnd
	ext.l	d1		* sign extend hi bnd
d1840 6
a1845 2
	btst	#$7, (EXC_LV+EXC_EXTWORD,a6)	* address compare?
	bne.w	chk2_cmp2_compare		* yes; don't sign extend
d1847 2
a1848 2
	* operation is a data register compare.
	* sign extend word to long so we can do simple longword compares.
d1850 2
a1851 2
	ext.l	d2		* sign extend data word
	bra.w	chk2_cmp2_compare		* go emulate compare
d1853 2
a1854 39
	* the bounds are byte size. fetch them in one subroutine call by
	* reading a word. sign extend both. if it's a data operation,
	* sign extend Rn to long, also.
chk2_cmp2_byte:
	move.l	a0,a2
	*bsr.l	_dmem_read_word		* fetch 2 byte bounds
	MOVE.W	(A0),D0
	MOVEQ	#0,D1

	tst.l	d1		* dfetch error?
	bne.w	chk2_cmp2_err_w		* yes

	move.b	d0, d1		* place hi in d1
	lsr.w	#$8, d0		* place lo in d0

	extb.l	d0		* sign extend lo bnd
	extb.l	d1		* sign extend hi bnd

	btst	#$7, (EXC_LV+EXC_EXTWORD,a6)	* address compare?
	bne.b	chk2_cmp2_compare		* yes; don't sign extend

	* operation is a data register compare.
	* sign extend byte to long so we can do simple longword compares.

	extb.l	d2		* sign extend data byte

	*
	* To set the ccodes correctly:
	* 	(1) save 'Z' bit from (Rn - lo)
	*	(2) save 'Z' and 'N' bits from ((hi - lo) - (Rn - hi))
	*	(3) keep 'X', 'N', and 'V' from before instruction
	*	(4) combine ccodes
	*
chk2_cmp2_compare:
	sub.l	d0, d2		* (Rn - lo)
	move.w	ccr, d3		* fetch resulting ccodes
	andi.b	#$4, d3		* keep 'Z' bit
	sub.l	d0, d1		* (hi - lo)
	cmp.l 	d1,d2		* ((hi - lo) - (Rn - hi))
d1856 2
a1857 3
	move.w	ccr, d4		* fetch resulting ccodes
	or.b	d4, d3		* combine w/ earlier ccodes
	andi.b	#$5, d3		* keep 'Z' and 'N'
d1859 3
a1861 4
	move.w	(EXC_LV+EXC_CC,a6), d4		* fetch old ccodes
	andi.b	#$1a, d4		* keep 'X','N','V' bits
	or.b	d3, d4		* insert new ccodes
	move.w	d4, (EXC_LV+EXC_CC,a6)		* save new ccodes
d1863 25
a1887 2
	btst	#$3, (EXC_LV+EXC_EXTWORD,a6)	* separate chk2,cmp2
	bne.b	chk2_finish		* it's a chk2
d1891 6
a1896 6
	* this code handles the only difference between chk2 and cmp2. chk2 would
	* have trapped out if the value was out of bounds. we check this by seeing
	* if the 'N' bit was set by the operation.

chk2_finish:	btst	#$0, d4		* is 'N' bit set?
	bne.b	chk2_trap		* yes;chk2 should trap
d1899 1
a1899 1
	move.b	#ichk_flg,(EXC_LV+SPCOND_FLG,a6) * set "special case" flag
d1902 8
a1909 8
	* if dmem_read_{long,word}() returns a fail message in d1, the package
	* must create an access error frame. here, we pass a skeleton fslw
	* and the failing address to the routine that creates the new frame.
	* FSLW:
	*	read = true
	*	size = longword
	*	TM = data
	* 	software emulation error = true
d1911 9
a1919 9
	move.l	a2,a0		* pass failing address
	move.l	#$01010001,d0		* pass fslw
	bra.l	isp_dacc

	* FSLW:
	*	read = true
	*	size = word
	*	TM = data
	* 	software emulation error = true
d1921 53
a1973 56
	move.l	a2,a0		* pass failing address
	move.l	#$01410001,d0		* pass fslw
	bra.l	isp_dacc

**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* XDEF
* 	_div64(): routine to emulate div{u,s}.l <ea>,Dr:Dq
*				64/32->32r:32q
* XREF
*	_calc_ea() - calculate effective address
* 	isp_iacc() - handle instruction access error exception
*	isp_dacc() - handle data access error exception
*	isp_restore() - restore An on access error w/ -() or ()+
*
* INPUT
*	none
*
* OUTPUT
* 	If exiting through isp_dacc...
*	a0 = failing address
* 	d0 = FSLW
*	else
*	none
*
* ALGORITHM
* 	First, decode the operand location. If it's in Dn, fetch from
* the stack. If it's in memory, use _calc_ea() to calculate the
* effective address. Use _dmem_read_long() to fetch at that address.
* Unless the operand is immediate data. Then use _imem_read_long().
* Send failures to isp_dacc() or isp_iacc() as appropriate.
*
*	If the operands are signed, make them unsigned and save	the
* sign info for later. Separate out special cases like divide-by-zero
* or 32-bit divides if possible. Else, use a special math algorithm
* to calculate the result.
*
*	Restore sign info if signed instruction. Set the condition
* codes. Set idbyz_flg in (EXC_LV+SPCOND_FLG if divisor was zero. Store the
* quotient and remainder in the appropriate data registers on the stack.
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------

NDIVISOR	equ	(EXC_LV+EXC_TEMP+$0)
NDIVIDEND	equ	(EXC_LV+EXC_TEMP+$1)
NDRSAVE	equ	(EXC_LV+EXC_TEMP+$2)
NDQSAVE	equ	(EXC_LV+EXC_TEMP+$4)
DDSECOND	equ	(EXC_LV+EXC_TEMP+$6)
DDQUOTIENT	equ	(EXC_LV+EXC_TEMP+$8)
DDNORMAL	equ	(EXC_LV+EXC_TEMP+$c)

	xdef  	_div64
	*************
	* div(u,s)l *
	*************
d1975 2
a1976 2
	move.b	(EXC_LV+EXC_OPWORD+1,a6), d0
	andi.b	#$38, d0			* extract src mode
d1978 1
a1978 1
	bne.w	dcontrolmodel_s			* dn dest or control mode?
d1980 3
a1982 3
	move.b	(EXC_LV+EXC_OPWORD+1,a6), d0		* extract Dn from opcode
	andi.w	#$7, d0
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4), d7 	* fetch divisor from register
d1985 1
a1985 11
	beq.w	div64eq0			* divisor is = 0!!!

	move.b	(EXC_LV+EXC_EXTWORD+1,a6), d0		* extract Dr from extword
	move.b	(EXC_LV+EXC_EXTWORD,a6), d1		* extract Dq from extword
	and.w	#$7, d0
	lsr.b	#$4, d1
	and.w	#$7, d1
	move.w	d0, (NDRSAVE,a6)			* save Dr for later
	move.w	d1, (NDQSAVE,a6)			* save Dq for later

	* fetch dr and dq directly off stack since all regs are saved there
d1987 22
a2008 2
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4), d5 	* get dividend hi
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4), d6 	* get dividend lo
d2010 2
a2011 15
	* separate signed and unsigned divide

	btst	#$3, (EXC_LV+EXC_EXTWORD,a6)		* signed or unsigned?
	beq.b	dspecialcases			* use positive divide

	* save the sign of the divisor
	* make divisor unsigned if it's negative

	tst.l	d7		* chk sign of divisor
	slt	(NDIVISOR,a6)		* save sign of divisor
	bpl.b	dsgndividend
	neg.l	d7		* complement negative divisor

	* save the sign of the dividend
	* make dividend unsigned if it's negative
d2013 7
a2019 7
	tst.l	d5		* chk sign of hi(dividend)
	slt	(NDIVIDEND,a6)		* save sign of dividend
	bpl.b	dspecialcases

	move.w	#$0, ccr		* clear 'X' cc bit
	negx.l	d6		* complement signed dividend
	negx.l	d5
d2025 5
a2029 2
	tst.l	d5		* is (hi(dividend) == 0)
	bne.b	dnormaldivide		* no, so try it the long way
d2031 2
a2032 2
	tst.l	d6		* is (lo(dividend) == 0), too
	beq.w	ddone		* yes, so (dividend == 0)
d2034 2
a2035 2
	cmp.l	d7,d6		* is (divisor <= lo(dividend))
	bls.b	d32bitdivide		* yes, so use 32 bit divide
a2036 2
	exg	d5,d6		* q = 0, r = dividend
	bra.w	divfinish		* can't divide, we're done.
d2038 1
a2038 1
	divu.l	d7, d5:d6		* it's only a 32/32 bit div!
d2040 1
a2040 1
	bra.b	divfinish
d2043 4
a2046 2
	* last special case:
	* 	- is hi(dividend) >= divisor ? if yes, then overflow
d2048 2
a2049 2
	cmp.l	d7,d5
	bls.b	ddovf		* answer won't fit in 32 bits
d2051 1
a2051 5
	* perform the divide algorithm:

	bsr.l	dclassical		* do int divide

	* separate into signed and unsigned finishes.
d2053 2
a2054 2
	btst	#$3, (EXC_LV+EXC_EXTWORD,a6)	* do divs, divu separately
	beq.b	ddone		* divu has no processing!!!
d2056 4
a2059 5
	* it was a divs.l, so ccode setting is a little more complicated...

	tst.b	(NDIVIDEND,a6)		* remainder has same sign
	beq.b	dcc		* as dividend.
	neg.l	d5		* sgn(rem) = sgn(dividend)
d2061 8
a2068 6
	move.b	(NDIVISOR,a6), d0
	eor.b	d0, (NDIVIDEND,a6)		* chk if quotient is negative
	beq.b	dqpos		* branch to quot positive

	* $80000000 is the largest number representable as a 32-bit negative
	* number. the negative of $80000000 is $80000000.
d2070 1
a2070 2
	cmp.l	#$80000000,d6		* will (-quot) fit in 32 bits?
	bhi.b	ddovf
d2072 1
a2072 3
	neg.l	d6		* make (-quot) 2's comp

	bra.b	ddone
d2075 2
a2076 2
	btst	#$1f, d6		* will (+quot) fit in 32 bits?
	bne.b	ddovf
d2079 4
a2082 1
	* at this point, result is normal so ccodes are set based on result.
d2084 2
a2085 3
	move.w	(EXC_LV+EXC_CC,a6), ccr
	tst.l	d6		* set ccrode bits
	move.w	ccr, (EXC_LV+EXC_CC,a6)
d2087 4
a2090 2
	move.w	(NDRSAVE,a6), d0		* get Dr off stack
	move.w	(NDQSAVE,a6), d1		* get Dq off stack
d2092 1
a2092 2
	* if the register numbers are the same, only the quotient gets saved.
	* so, if we always save the quotient second, we save ourselves a cmp#beq
d2094 3
a2096 3
	move.l	d5, (EXC_LV+EXC_DREGS,a6,d0.w*4) * save remainder
	move.l	d6, (EXC_LV+EXC_DREGS,a6,d1.w*4) * save quotient
	rts
a2097 2
ddovf:	bset	#$1, (EXC_LV+EXC_CC+1,a6)	* 'V' set on overflow
	bclr	#$0, (EXC_LV+EXC_CC+1,a6)	* 'C' cleared on overflow
d2101 2
a2102 2
	andi.b	#$1e, (EXC_LV+EXC_CC+1,a6)		* clear 'C' bit on divbyzero
	ori.b	#idbyz_flg,(EXC_LV+SPCOND_FLG,a6) 	* set "special case" flag
d2105 15
a2119 16
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* This routine uses the 'classical' Algorithm D from Donald Knuth's
* Art of Computer Programming, vol II, Seminumerical Algorithms.
* For this implementation b=2**16, and the target is U1U2U3U4/V1V2,
* where U,V are words of the quadword dividend and longword divisor,
* and U1, V1 are the most significant words.
*
* The most sig. longword of the 64 bit dividend must be in d5, least
* in d6. The divisor must be in the variable ddivisor, and the
* signed/unsigned flag ddusign must be set (0=unsigned,1=signed).
* The quotient is returned in d6, remainder in d5, unless the
* v (overflow) bit is set in the saved ccrr. If overflow, the dividend
* is unchanged.
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d2121 2
a2122 2
	* if the divisor msw is 0, use simpler algorithm then the full blown
	* one at ddknuth:
d2124 2
a2125 2
	cmp.l	 #$ffff,d7
	bhi.b	ddknuth		* go use D. Knuth algorithm
d2127 27
a2153 27
	* Since the divisor is only a word (and larger than the mslw of the dividend),
	* a simpler algorithm may be used :
	* In the general case, four quotient words would be created by
	* dividing the divisor word into each dividend word. In this case,
	* the first two quotient words must be zero, or overflow would occur.
	* Since we already checked this case above, we can treat the most significant
	* longword of the dividend as (0) remainder (see Knuth) and merely complete
	* the last two divisions to get a quotient longword and word remainder:

	clr.l	d1
	swap	d5		* same as r*b if previous step rqd
	swap	d6		* get u3 to lsw position
	move.w	d6, d5		* rb + u3

	divu.w	d7, d5

	move.w	d5, d1		* first quotient word
	swap	d6		* get u4
	move.w	d6, d5		* rb + u4

	divu.w	d7, d5

	swap	d1
	move.w	d5, d1		* 2nd quotient 'digit'
	clr.w	d5
	swap	d5		* now remainder
	move.l	d1, d6		* and quotient
d2158 10
a2167 10
	* In this algorithm, the divisor is treated as a 2 digit (word) number
	* which is divided into a 3 digit (word) dividend to get one quotient
	* digit (word). After subtraction, the dividend is shifted and the
	* process repeated. Before beginning, the divisor and quotient are
	* 'normalized' so that the process of estimating the quotient digit
	* will yield verifiably correct results..

	clr.l	(DDNORMAL,a6)		* count of shifts for normalization
	clr.b	(DDSECOND,a6)		* clear flag for quotient digits
	clr.l	d1		* d1 will hold trial quotient
d2169 7
a2175 7
	btst	#31, d7		* must we normalize? first word of
	bne.b	ddnormalized		* divisor (V1) must be >= 65536/2
	addq.l	#$1, (DDNORMAL,a6)		* count normalization shifts
	lsl.l	#$1, d7		* shift the divisor
	lsl.l	#$1, d6		* shift u4,u3 with overflow to u2
	roxl.l	#$1, d5		* shift u1,u2
	bra.w	ddnchk
d2178 10
a2187 11
	* Now calculate an estimate of the quotient words (msw first, then lsw).
	* The comments use subscripts for the first quotient digit determination.

	move.l	d7, d3		* divisor
	move.l	d5, d2		* dividend mslw
	swap	d2
	swap	d3
	cmp.w 	d2, d3		* V1 = U1 ?
	bne.b	ddqcalc1
	move.w	#$ffff, d1		* use max trial quotient word
	bra.b	ddadj0
d2189 1
a2189 1
	move.l	d5, d1
d2191 1
a2191 1
	divu.w	d3, d1		* use quotient of mslw/msw
d2193 1
a2193 1
	andi.l	#$0000ffff, d1		* zero any remainder
d2196 28
a2223 29
	* now test the trial quotient and adjust. This step plus the
	* normalization assures (according to Knuth) that the trial
	* quotient will be at worst 1 too large.

	move.l	d6, -(sp)
	clr.w	d6		* word u3 left
	swap	d6		* in lsw position
ddadj1: 	move.l	d7, d3
	move.l	d1, d2
	mulu.w	d7, d2		* V2q
	swap	d3
	mulu.w	d1, d3		* V1q
	move.l	d5, d4		* U1U2
	sub.l	d3, d4		* U1U2 - V1q

	swap	d4

	move.w	d4,d0
	move.w	d6,d4		* insert lower word (U3)

	tst.w	d0		* is upper word set?
	bne.w	ddadjd1

*	add.l	d6, d4		* (U1U2 - V1q) + U3

	cmp.l 	d2, d4
	bls.b	ddadjd1		* is V2q > (U1U2-V1q) + U3 ?
	subq.l	#$1, d1		* yes, decrement and recheck
	bra.b	ddadj1
d2225 28
a2252 31
	* now test the word by multiplying it by the divisor (V1V2) and comparing
	* the 3 digit (word) result with the current dividend words

	move.l	d5, -(sp)		* save d5 (d6 already saved)
	move.l	d1, d6
	swap	d6		* shift answer to ms 3 words
	move.l	d7, d5
	bsr.l	dmm2
	move.l	d5, d2		* now d2,d3 are trial*divisor
	move.l	d6, d3
	move.l	(sp)+, d5		* restore dividend
	move.l	(sp)+, d6
	sub.l	d3, d6
	subx.l	d2, d5		* subtract double precision
	bcc	dd2nd		* no carry, do next quotient digit
	subq.l	#$1, d1		* q is one too large

	* need to add back divisor longword to current ms 3 digits of dividend
	* - according to Knuth, this is done only 2 out of 65536 times for random
	* divisor, dividend selection.

	clr.l	d2
	move.l	d7, d3
	swap	d3
	clr.w	d3		* d3 now ls word of divisor
	add.l	d3, d6		* aligned with 3rd word of dividend
	addx.l	d2, d5
	move.l	d7, d3
	clr.w	d3		* d3 now ms word of divisor
	swap	d3		* aligned with 2nd word of dividend
	add.l	d3, d5
d2254 12
a2265 14
	tst.b	(DDSECOND,a6)		* both q words done?
	bne.b	ddremain

	* first quotient digit now correct. store digit and shift the
	* (subtracted) dividend

	move.w	d1, (DDQUOTIENT,a6)
	clr.l	d1
	swap	d5
	swap	d6
	move.w	d6, d5
	clr.w	d6
	st	(DDSECOND,a6)		* second digit
	bra.w	ddnormalized
d2267 9
a2275 12
	* add 2nd word to quotient, get the remainder.

	move.w 	d1,(DDQUOTIENT+2,a6)

	* shift down one word/digit to renormalize remainder.

	move.w	d5, d6
	swap	d6
	swap	d5
	move.l	(DDNORMAL,a6), d7		* get norm shift count
	beq.b	ddrn
	subq.l	#$1, d7		* set for loop count
d2277 3
a2279 3
	lsr.l	#$1, d5		* shift into d6
	roxr.l	#$1, d6
	dbf	d7, ddnlp
d2281 2
a2282 2
	move.l	d6, d5		* remainder
	move.l	(DDQUOTIENT,a6), d6 		* quotient
d2286 28
a2313 31
	* factors for the 32X32->64 multiplication are in d5 and d6.
	* returns 64 bit result in d5 (hi) d6(lo).
	* destroys d2,d3,d4.

	* multiply hi,lo words of each factor to get 4 intermediate products

	move.l	d6, d2
	move.l	d6, d3
	move.l	d5, d4
	swap	d3
	swap	d4
	mulu.w	d5, d6		* d6 <- lsw*lsw
	mulu.w	d3, d5		* d5 <- msw-dest*lsw-source
	mulu.w	d4, d2		* d2 <- msw-source*lsw-dest
	mulu.w	d4, d3		* d3 <- msw*msw

	* now use swap and addx to consolidate to two longwords

	clr.l	d4
	swap	d6
	add.w	d5, d6		* add msw of l*l to lsw of m*l product
	addx.w	d4, d3		* add any carry to m*m product
	add.w	d2, d6		* add in lsw of other m*l product
	addx.w	d4, d3		* add any carry to m*m product
	swap	d6		* d6 is low 32 bits of final product
	clr.w	d5
	clr.w	d2		* lsw of two mixed products used,
	swap	d5		* now use msws of longwords
	swap	d2
	add.l	d2, d5
	add.l	d3, d5		* d5 now ms 32 bits of final product
d2316 1
a2316 1
	**********
d2318 8
a2325 2
	moveq.l	#size_LONG,d0
	bsr.l	_calc_ea		* calc <ea>
d2327 2
a2328 2
	cmp.b	#immed_flg,(EXC_LV+SPCOND_FLG,a6) * immediate addressing mode?
	beq.b	dimmed		* yes
d2330 6
a2335 14
	move.l	a0,a2
	*bsr.l	_dmem_read_long		* fetch divisor from <ea>
	MOVE.L	(A0),D0
	MOVEQ	#0,D1

	tst.l	d1		* dfetch error?
	bne.b	div64_err		* yes

	move.l	d0, d7
	bra.w	dgotsrcl

	* we have to split out immediate data here because it must be read using
	* imem_read() instead of dmem_read(). this becomes especially important
	* if the fetch runs into some deadly fault.
d2337 5
a2341 4
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)
	*bsr.l	_imem_read_long		* read immediate value
	MOVE.L	(A0),D0
	MOVEQ	#0,D1
d2343 2
a2344 2
	tst.l	d1		* ifetch error?
	bne.l	isp_iacc		* yes
d2346 1
a2346 2
	move.l	d0,d7
	bra.w	dgotsrcl
a2347 1
**------------------------------------------------------------------------------------------------------
d2359 43
a2401 47
	bsr.l	isp_restore	* restore addr reg
	move.l	a2,a0	* pass failing address
	move.l	#$01010001,d0	* pass fslw
	bra.l	isp_dacc


**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* XDEF
*	_mul64(): routine to emulate mul{u,s}.l <ea>,Dh:Dl 32x32->64
*
* XREF
*	_calc_ea() - calculate effective address
*	isp_iacc() - handle instruction access error exception
* 	isp_dacc() - handle data access error exception
*	isp_restore() - restore An on access error w/ -() or ()+
*
* INPUT
*	none
*
* OUTPUT
* 	If exiting through isp_dacc...
*	a0 = failing address
*	d0 = FSLW
* 	else
*	none
*
* ALGORITHM
*	First, decode the operand location. If it's in Dn, fetch from
* the stack. If it's in memory, use _calc_ea() to calculate the
* effective address. Use _dmem_read_long() to fetch at that address.
* Unless the operand is immediate data. Then use _imem_read_long().
* Send failures to isp_dacc() or isp_iacc() as appropriate.
*
*	If the operands are signed, make them unsigned and save the
* sign info for later. Perform the multiplication using 16x16->32
* unsigned multiplies and "add" instructions. Store the high and low
* portions of the result in the appropriate data registers on the
* stack. Calculate the condition codes, also.
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------

	*************
	* mul(u,s)l *
	*************
	xdef  	_mul64
d2403 3
a2405 3
	move.b	(EXC_LV+EXC_OPWORD+1,a6), d0	* extract src {mode,reg}
	cmp.b	#$7,d0		* is src mode Dn or other?
	bgt.w	mul64_memop		* src is in memory
d2407 2
a2408 2
	* multiplier operand in the the data register file.
	* must extract the register number and fetch the operand from the stack.
d2410 2
a2411 2
	andi.w	#$7, d0		* extract Dn
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4), d3 * fetch multiplier
d2413 2
a2414 2
	* multiplier is in d3. now, extract Dl and Dh fields and fetch the
	* multiplicand from the data register specified by Dl.
d2416 25
a2440 27
	move.w	(EXC_LV+EXC_EXTWORD,a6), d2	* fetch ext word
	clr.w	d1		* clear Dh reg
	move.b	d2, d1		* grab Dh
	rol.w	#$4, d2		* align Dl byte
	andi.w	#$7, d2		* extract Dl

	move.l	(EXC_LV+EXC_DREGS,a6,d2.w*4), d4 * get multiplicand

	* check for the case of "zero" result early

	tst.l	d4		* test multiplicand
	beq.w	mul64_zero		* handle zero separately
	tst.l	d3		* test multiplier
	beq.w	mul64_zero		* handle zero separately

	* multiplier is in d3 and multiplicand is in d4.
	* if the operation is to be signed, then the operands are converted
	* to unsigned and the result sign is saved for the end.

	clr.b	(EXC_LV+EXC_TEMP,a6)		* clear temp space
	btst	#$3, (EXC_LV+EXC_EXTWORD,a6)	* signed or unsigned?
	beq.b	mul64_alg		* unsigned; skip sgn calc

	tst.l	d3		* is multiplier negative?
	bge.b	mul64_chk_md_sgn		* no
	neg.l	d3		* make multiplier positive
	ori.b	#$1, (EXC_LV+EXC_TEMP,a6)	* save multiplier sgn
d2442 1
a2442 1
	* the result sign is the exclusive or of the operand sign bits.
d2444 24
a2467 24
	tst.l	d4		* is multiplicand negative?
	bge.b	mul64_alg		* no
	neg.l	d4		* make multiplicand positive
	eori.b	#$1, (EXC_LV+EXC_TEMP,a6)	* calculate correct sign

	*************************************************************************
	*	63   32				0	*
	* 	----------------------------				*
	* 	| hi(mplier) * hi(mplicand)|				*
	* 	----------------------------				*
	*	     -----------------------------			*
	*	     | hi(mplier) * lo(mplicand) |			*
	*	     -----------------------------			*
	*	     -----------------------------			*
	*	     | lo(mplier) * hi(mplicand) |			*
	*	     -----------------------------			*
	*	  |	-----------------------------	*
	*	--|--	| lo(mplier) * lo(mplicand) |	*
	*	  |	-----------------------------	*
	*	========================================================
	*	--------------------------------------------------------
	*	|	hi(result)	   |	    lo(result)         |	*
	*	--------------------------------------------------------
	*************************************************************************
d2469 41
a2509 45
	* load temp registers with operands

	move.l	d3, d5		* mr in d5
	move.l	d3, d6		* mr in d6
	move.l	d4, d7		* md in d7
	swap	d6		* hi(mr) in lo d6
	swap	d7		* hi(md) in lo d7

	* complete necessary multiplies:

	mulu.w	d4, d3		* [1] lo(mr) * lo(md)
	mulu.w	d6, d4		* [2] hi(mr) * lo(md)
	mulu.w	d7, d5		* [3] lo(mr) * hi(md)
	mulu.w	d7, d6		* [4] hi(mr) * hi(md)

	* add lo portions of [2],[3] to hi portion of [1].
	* add carries produced from these adds to [4].
	* lo([1]) is the final lo 16 bits of the result.

	clr.l	d7		* load d7 w/ zero value
	swap	d3		* hi([1]) <==> lo([1])
	add.w	d4, d3		* hi([1]) + lo([2])
	addx.l	d7, d6		*    [4]  + carry
	add.w	d5, d3		* hi([1]) + lo([3])
	addx.l	d7, d6		*    [4]  + carry
	swap	d3		* lo([1]) <==> hi([1])

	* lo portions of [2],[3] have been added in to final result.
	* now, clear lo, put hi in lo reg, and add to [4]

	clr.w	d4		* clear lo([2])
	clr.w	d5		* clear hi([3])
	swap	d4		* hi([2]) in lo d4
	swap	d5		* hi([3]) in lo d5
	add.l	d5, d4		*    [4]  + hi([2])
	add.l	d6, d4		*    [4]  + hi([3])

	* unsigned result is now in {d4,d3}

	tst.b	(EXC_LV+EXC_TEMP,a6)	* should result be signed?
	beq.b	mul64_done	* no

	* result should be a signed negative number.
	* compute 2's complement of the unsigned number:
	*   -negate all bits and add 1
d2511 9
a2519 9
	not.l	d3		* negate lo(result) bits
	not.l	d4		* negate hi(result) bits
	addq.l	#1, d3		* add 1 to lo(result)
	addx.l	d7, d4		* add carry to hi(result)

	* the result is saved to the register file.
	* for '040 compatability, if Dl == Dh then only the hi(result) is
	* saved. so, saving hi after lo accomplishes this without need to
	* check Dl,Dh equality.
d2521 3
a2523 3
	move.l	d3, (EXC_LV+EXC_DREGS,a6,d2.w*4) * save lo(result)
	move.w	#$0, ccr
	move.l	d4, (EXC_LV+EXC_DREGS,a6,d1.w*4) * save hi(result)
d2525 2
a2526 2
	* now, grab the condition codes. only one that can be set is 'N'.
	* 'N' CAN be set if the operation is unsigned if bit 63 is set.
d2528 2
a2529 2
	move.w	ccr, d7		* fetch ccrr to see if 'N' set
	andi.b	#$8, d7		* extract 'N' bit
d2532 2
a2533 2
	move.b	(EXC_LV+EXC_CC+1,a6), d6 	* fetch previous ccrr
	andi.b	#$10, d6	* all but 'X' bit changes
d2535 2
a2536 2
	or.b	d7, d6		* group 'X' and 'N'
	move.b	d6, (EXC_LV+EXC_CC+1,a6)	* save new ccrr
d2540 2
a2541 3
	* one or both of the operands is zero so the result is also zero.
	* save the zero result to the register file and set the 'Z' ccode bit.

d2543 2
a2544 2
	clr.l	(EXC_LV+EXC_DREGS,a6,d2.w*4) * save lo(result)
	clr.l	(EXC_LV+EXC_DREGS,a6,d1.w*4) * save hi(result)
d2546 2
a2547 2
	moveq.l	#$4, d7		* set 'Z' ccode bit
	bra.b	mul64_ccode_set	* finish ccode set
d2551 2
a2552 2
	* multiplier operand is in memory at the effective address.
	* must calculate the <ea> and go fetch the 32-bit operand.
d2554 2
a2555 2
	moveq.l	#size_LONG, d0			* pass * of bytes
	bsr.l	_calc_ea			* calculate <ea>
d2557 2
a2558 2
	cmp.b	#immed_flg,(EXC_LV+SPCOND_FLG,a6)	* immediate addressing mode?
	beq.b	mul64_immed			* yes
d2560 2
a2561 4
	move.l	a0,a2
	*bsr.l	_dmem_read_long			* fetch src from addr (a0)
	MOVE.L	(a0),d0
	MOVEQ	#0,d1
d2563 2
a2564 2
	tst.l	d1			* dfetch error?
	bne.w	mul64_err			* yes
d2566 1
a2566 1
	move.l	d0, d3			* store multiplier in d3
d2568 1
a2568 1
	bra.w	mul64_multiplicand
d2570 3
a2572 3
	* we have to split out immediate data here because it must be read using
	* imem_read() instead of dmem_read(). this becomes especially important
	* if the fetch runs into some deadly fault.
d2574 5
a2578 27
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)
	*bsr.l	_imem_read_long			* read immediate value
	MOVE.L	(a0),d0
	MOVEQ	#0,d1

	tst.l	d1			* ifetch error?
	bne.l	isp_iacc			* yes

	move.l	d0,d3
	bra.w	mul64_multiplicand

	**********
	* if dmem_read_long() returns a fail message in d1, the package
	* must create an access error frame. here, we pass a skeleton fslw
	* and the failing address to the routine that creates the new frame.
	* also, we call isp_restore in case the effective addressing mode was
	* (an)+ or -(an) in which case the previous "an" value must be restored.
	* FSLW:
	* 	read = true
	* 	size = longword
	*	TM = data
	* 	software emulation error = true
mul64_err:
	bsr.l	isp_restore	* restore addr reg
	move.l	a2,a0		* pass failing address
	move.l	#$01010001,d0	* pass fslw
	bra.l	isp_dacc
d2580 2
d2583 1
d2585 67
a2651 54
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
*
* XDEF
*	_compandset2(): routine to emulate cas2()
*		(internal to package)
*
*	_isp_cas2_finish(): store ccodes, store compare regs
*		    (external to package)
*
* XREF
*	_real_lock_page() - "callout" to lock op's page from page-outs
*	_cas_terminate2() - access error exit
*	_real_cas2() - "callout" to core cas2 emulation code
*	_real_unlock_page() - "callout" to unlock page
*
* INPUT
* _compandset2():
*	d0 = instruction extension word
*
* _isp_cas2_finish():
*	see cas2 core emulation code
*
* OUTPUT
* _compandset2():
*	see cas2 core emulation code
*
* _isp_cas_finish():
*	None (register file or memroy changed as appropriate)
*
* ALGORITHM
* compandset2():
*	Decode the instruction and fetch the appropriate Update and
* Compare operands. Then call the "callout" _real_lock_page() for each
* memory operand address so that the operating system can keep these
* pages from being paged out. If either _real_lock_page() fails, exit
* through _cas_terminate2(). Don't forget to unlock the 1st locked page
* using _real_unlock_paged() if the 2nd lock-page fails.
* Finally, branch to the core cas2 emulation code by calling the
* "callout" _real_cas2().
*
* _isp_cas2_finish():
*	Re-perform the comparison so we can determine the condition
* codes which were too much trouble to keep around during the locked
* emulation. Then unlock each operands page by calling the "callout"
* _real_unlock_page().
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------

ADDR1	equ	(EXC_LV+EXC_TEMP+$c)
ADDR2	equ	(EXC_LV+EXC_TEMP+$0)
DC2	equ	(EXC_LV+EXC_TEMP+$a)
DC1	equ	(EXC_LV+EXC_TEMP+$8)
d2653 1
a2653 1
	xdef  	_compandset2
d2655 2
a2656 20
	move.l	d0,(EXC_LV+EXC_TEMP+$4,a6)	* store for possible restart
	move.l	d0,d1		* extension word in d0

	rol.w	#$4,d0
	andi.w	#$f,d0		* extract Rn2
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),a1 * fetch ADDR2
	move.l	a1,(ADDR2,a6)

	move.l	d1,d0

	lsr.w	#$6,d1
	andi.w	#$7,d1		* extract Du2
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d5 * fetch Update2 Op

	andi.w	#$7,d0		* extract Dc2
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),d3 * fetch Compare2 Op
	move.w	d0,(DC2,a6)

	move.w	(EXC_LV+EXC_EXTWORD,a6),d0
	move.l	d0,d1
d2658 56
a2713 4
	rol.w	#$4,d0
	andi.w	#$f,d0		* extract Rn1
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),a0 * fetch ADDR1
	move.l	a0,(ADDR1,a6)
d2715 2
a2716 1
	move.l	d1,d0
d2718 1
a2718 41
	lsr.w	#$6,d1
	andi.w	#$7,d1		* extract Du1
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d4 * fetch Update1 Op

	andi.w	#$7,d0		* extract Dc1
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),d2 * fetch Compare1 Op
	move.w	d0,(DC1,a6)

	btst	#$1,(EXC_LV+EXC_OPWORD,a6)	* word or long?
	sne	d7

	btst	#$5,(SFF0_ISR,a6)		* user or supervisor?
	sne	d6

	move.l	a0,a2
	move.l	a1,a3

	move.l	d7,d1		* pass size
	move.l	d6,d0		* pass mode

	*bsr.l	_real_lock_page		* lock page
	CLR.L	D0

	move.l	a2,a0
	tst.l	d0		* error?
	bne.l	_cas_terminate2		* yes

	move.l	d7,d1		* pass size
	move.l	d6,d0		* pass mode
	move.l	a3,a0		* pass addr
	*bsr.l	_real_lock_page		* lock page
	CLR.L	D0

	move.l	a3,a0
	tst.l	d0		* error?
	bne.b	cas_preterm		* yes

	move.l	a2,a0
	move.l	a3,a1

	bra.l	_isp_cas2		* _real_cas2
a2721 1

d2723 8
a2730 10
	move.l	d0,-(sp)	* save FSLW
	move.l	d7,d1		* pass size
	move.l	d6,d0		* pass mode
	move.l	a2,a0		* pass ADDR1
	*bsr.l	_real_unlock_page	* unlock first page(s)
	CLR.L	D0

	move.l	(sp)+,d0	* restore FSLW
	move.l	a3,a0		* pass failing addr
	bra.l	_cas_terminate2
d2732 1
a2732 1
	*************************************************************
d2734 1
a2734 1
	xdef  	_isp_cas2_finish
d2736 2
a2737 2
	btst	#$1,(EXC_LV+EXC_OPWORD,a6)
	bne.b	cas2_finish_l
d2739 4
a2742 4
	move.w	(EXC_LV+EXC_CC,a6),ccr	* load old ccodes
	cmp.w	d0,d2
	bne.b	cas2_finish_w_save
	cmp.w	d1,d3
d2744 1
a2744 1
	move.w	ccr,(EXC_LV+EXC_CC,a6)		* save new ccodes
d2746 2
a2747 2
	tst.b	d4		* update compare reg?
	bne.b	cas2_finish_w_done		* no
d2749 2
a2750 2
	move.w	(DC2,a6),d3		* fetch Dc2
	move.w	d1,(2+EXC_LV+EXC_DREGS,a6,d3.w*4) * store new Compare2 Op
d2752 2
a2753 2
	move.w	(DC1,a6),d2		* fetch Dc1
	move.w	d0,(2+EXC_LV+EXC_DREGS,a6,d2.w*4) * store new Compare1 Op
d2756 11
a2766 14
	btst	#$5,(SFF0_ISR,a6)
	sne	d2
	move.l	d2,d0		* pass mode
	sf	d1		* pass size
	move.l	(ADDR1,a6),a0		* pass ADDR1
	*bsr.l	_real_unlock_page		* unlock page
	CLR.L	D0

	move.l	d2,d0		* pass mode
	sf	d1		* pass size
	move.l	(ADDR2,a6),a0		* pass ADDR2
	*bsr.l	_real_unlock_page		* unlock page
	CLR.L	D0

d2770 4
a2773 4
	move.w	(EXC_LV+EXC_CC,a6),ccr		* load old ccodes
	cmp.l	d0,d2
	bne.b	cas2_finish_l_save
	cmp.l	d1,d3
d2775 1
a2775 1
	move.w	ccr,(EXC_LV+EXC_CC,a6)		* save new ccodes
d2777 2
a2778 2
	tst.b	d4		* update compare reg?
	bne.b	cas2_finish_l_done		* no
d2780 2
a2781 2
	move.w	(DC2,a6),d3		* fetch Dc2
	move.l	d1,(EXC_LV+EXC_DREGS,a6,d3.w*4) * store new Compare2 Op
d2783 2
a2784 2
	move.w	(DC1,a6),d2		* fetch Dc1
	move.l	d0,(EXC_LV+EXC_DREGS,a6,d2.w*4) * store new Compare1 Op
d2787 11
a2797 13
	btst	#$5,(SFF0_ISR,a6)
	sne	d2
	move.l	d2,d0		* pass mode
	st	d1		* pass size
	move.l	(ADDR1,a6),a0		* pass ADDR1
	*bsr.l	_real_unlock_page		* unlock page
	CLR.L	D0

	move.l	d2,d0		* pass mode
	st	d1		* pass size
	move.l	(ADDR2,a6),a0		* pass ADDR2
	*bsr.l	_real_unlock_page		* unlock page
	CLR.L	D0
d2801 1
a2801 1
	xdef  	cr_cas2
d2803 2
a2804 2
	move.l	(EXC_LV+EXC_TEMP+$4,a6),d0
	bra.w	_compandset2
d2806 83
a2888 86
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* XDEF
*	_compandset(): routine to emulate cas w/ misaligned <ea>
*	       (internal to package)
*	_isp_cas_finish(): routine called when cas emulation completes
*		   (external and internal to package)
*	_isp_cas_restart(): restart cas emulation after a fault
*		    (external to package)
*	_isp_cas_terminate(): create access error stack frame on fault
*		      (external and internal to package)
*	_isp_cas_inrange(): checks whether instr addess is within range
*		    of core cas/cas2emulation code
*		    (external to package)
*
* XREF
* 	_calc_ea(): calculate effective address
*
* INPUT
* compandset():
* 	none
* _isp_cas_restart():
*	d6 = previous sfc/dfc
* _isp_cas_finish():
* _isp_cas_terminate():
*	a0 = failing address
*	d0 = FSLW
*	d6 = previous sfc/dfc
* _isp_cas_inrange():
*	a0 = instruction address to be checked
*
* OUTPUT
* compandset():
*	none
* _isp_cas_restart():
*	a0 = effective address
*	d7 = word or longword flag
* _isp_cas_finish():
*	a0 = effective address
* _isp_cas_terminate():
*	initial register set before emulation exception
* _isp_cas_inrange():
*	d0 = 0 => in range; -1 => out of range
*
* ALGORITHM
*
* compandset():
*	First, calculate the effective address. Then, decode the
* instruction word and fetch the "compare" (DC) and "update" (Du)
* operands.
* 	Next, call the external routine _real_lock_page() so that the
* operating system can keep this page from being paged out while we're
* in this routine. If this call fails, jump to _cas_terminate2().
*	The routine then branches to _real_cas(). This external routine
* that actually emulates cas can be supplied by the external os or
* made to point directly back into the 060ISP which has a routine for
* this purpose.
*
* _isp_cas_finish():
* 	Either way, after emulation, the package is re-entered at
* _isp_cas_finish(). This routine re-compares the operands in order to
* set the condition codes. Finally, these routines will call
* _real_unlock_page() in order to unlock the pages that were previously
* locked.
*
* _isp_cas_restart():
*	This routine can be entered from an access error handler where
* the emulation sequence should be re-started from the beginning.
*
* _isp_cas_terminate():
*	This routine can be entered from an access error handler where
* an emulation operand access failed and the operating system would
* like an access error stack frame created instead of the current
* unimplemented integer instruction frame.
* 	Also, the package enters here if a call to _real_lock_page()
* fails.
*
* _isp_cas_inrange():
* 	Checks to see whether the instruction address passed to it in
* a0 is within the software package cas/cas2 emulation routines. This
* can be helpful for an operating system to determine whether an access
* error during emulation was due to a cas/cas2 emulation access.
*
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d2890 2
a2891 2
DC	equ	(EXC_LV+EXC_TEMP+$8)
ADDR	equ	(EXC_LV+EXC_TEMP+$4)
d2893 1
a2893 1
	xdef  	_compandset
d2895 2
a2896 2
	btst	#$1,(EXC_LV+EXC_OPWORD,a6)	* word or long operation?
	bne.b	compandsetl		* long
d2899 5
a2903 5
	moveq.l	#$2,d0		* size = 2 bytes
	bsr.l	_calc_ea		* a0 = calculated <ea>
	move.l	a0,(ADDR,a6)		* save <ea> for possible restart
	sf	d7		* clear d7 for word size
	bra.b	compandsetfetch
d2906 4
a2909 4
	moveq.l	#$4,d0		* size = 4 bytes
	bsr.l	_calc_ea		* a0 = calculated <ea>
	move.l	a0,(ADDR,a6)		* save <ea> for possible restart
	st	d7		* set d7 for longword size
d2912 2
a2913 2
	move.w	(EXC_LV+EXC_EXTWORD,a6),d0	* fetch cas extension word
	move.l	d0,d1		* make a copy
d2915 18
a2932 3
	lsr.w	#$6,d0
	andi.w	#$7,d0			* extract Du
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),d2 	* get update operand
d2934 1
a2934 3
	andi.w	#$7,d1			* extract Dc
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d4 	* get compare operand
	move.w	d1,(DC,a6)		* save Dc
d2936 2
a2937 18
	btst	#$5,(SFF0_ISR,a6)		* which mode for exception?
	sne	d6		* set on supervisor mode

	move.l	a0,a2		* save temporarily
	move.l	d7,d1		* pass size
	move.l	d6,d0		* pass mode
	*bsr.l	_real_lock_page		* lock page
	CLR.L	d0
	tst.l	d0		* did error occur?
	bne.w	_cas_terminate2		* yes, clean up the mess
	move.l	a2,a0		* pass addr in a0

	bra.l	_isp_cas		* _real_cas

**------------------------------------------------------------------------------------------------------


	xdef  	_isp_cas_finish
d2939 2
a2940 2
	btst	#$1,(EXC_LV+EXC_OPWORD,a6)
	bne.b	cas_finish_l
d2942 2
a2943 2
	* just do the compare again since it's faster than saving the ccodes
	* from the locked routine...
d2945 3
a2947 3
	move.w	(EXC_LV+EXC_CC,a6),ccr		* restore cc
	cmp.w	d0,d4		* do word compare
	move.w	ccr,(EXC_LV+EXC_CC,a6)		* save cc
d2949 2
a2950 2
	tst.b	d1		* update compare reg?
	bne.b	cas_finish_w_done		* no
d2952 2
a2953 2
	move.w	(DC,a6),d3
	move.w	d0,(EXC_LV+EXC_DREGS+2,a6,d3.w*4) * Dc = destination
d2956 5
a2960 6
	move.l	(ADDR,a6),a0		* pass addr
	sf	d1		* pass size
	btst	#$5,(SFF0_ISR,a6)
	sne	d0		* pass mode
	*bsr.l	_real_unlock_page		* unlock page
                        CLR.L	d0
d2963 2
a2964 2
	* just do the compare again since it's faster than saving the ccodes
	* from the locked routine...
d2966 3
a2968 3
	move.w	(EXC_LV+EXC_CC,a6),ccr		* restore cc
	cmp.l	d0,d4		* do longword compare
	move.w	ccr,(EXC_LV+EXC_CC,a6)		* save cc
d2970 2
a2971 2
	tst.b	d1		* update compare reg?
	bne.b	cas_finish_l_done		* no
d2973 2
a2974 2
	move.w	(DC,a6),d3
	move.l	d0,(EXC_LV+EXC_DREGS,a6,d3.w*4) * Dc = destination
d2977 5
a2981 6
	move.l	(ADDR,a6),a0		* pass addr
	st	d1		* pass size
	btst	#$5,(SFF0_ISR,a6)
	sne	d0		* pass mode
	*bsr.l	_real_unlock_page		* unlock page
                        CLR.L	D0
d2984 1
a2984 1
**------------------------------------------------------------------------------------------------------
d2986 1
a2986 1
	xdef  	_isp_cas_restart
d2988 2
a2989 2
	movec.l	d6,sfc		* restore previous sfc
	movec.l	d6,dfc		* restore previous dfc
d2991 2
a2992 2
	cmp.b	#$fc,(EXC_LV+EXC_OPWORD+1,a6)	* cas or cas2?
	beq.l	cr_cas2		* cas2
d2994 4
a2997 4
	move.l	(ADDR,a6),a0		* load <ea>
	btst	#$1,(EXC_LV+EXC_OPWORD,a6)	* word or long operation?
	sne	d7		* set d7 accordingly
	bra.w	compandsetfetch
d2999 1
a3000 1
**------------------------------------------------------------------------------------------------------
d3002 1
a3002 2

	xdef  	_isp_cas_terminate
d3004 2
a3005 2
	movec.l	d6,sfc		* restore previous sfc
	movec.l	d6,dfc		* restore previous dfc
d3007 1
a3007 4

**------------------------------------------------------------------------------------------------------

	xdef  	_cas_terminate2
d3009 1
a3009 1
	move.l	a0,a2		* copy failing addr to a2
d3011 10
a3020 10
	move.l	d0,-(sp)
	bsr.l	isp_restore		* restore An (if ()+ or -())
	move.l	(sp)+,d0

	addq.l	#$4,sp		* remove sub return addr
	subq.l	#$8,sp		* make room for bigger stack
	subq.l	#$8,a6		* shift frame ptr down, too
	move.l	#26,d1		* want to move 51 longwords
	lea	$8(sp),a0		* get address of old stack
	lea	$0(sp),a1		* get address of new stack
d3022 2
a3023 2
	move.l	(a0)+,(a1)+		* move a longword
	dbra.w	d1,cas_term_cont		* keep going
d3025 6
a3030 6
	move.w	#$4008,(SFF0_IVOFF,a6)		* put new stk fmt, voff
	move.l	a2,(SFF0_IVOFF+$2,a6)		* put faulting addr on stack
	move.l	d0,(SFF0_IVOFF+$6,a6)		* put FSLW on stack
	movem.l	(EXC_LV+EXC_DREGS,a6),d0-d7/a0-a5	* restore user regs
	unlk	a6		* unlink stack frame
	bra.l	_real_access
d3032 1
a3032 1
**------------------------------------------------------------------------------------------------------
d3034 1
a3034 1
	xdef  	_isp_cas_inrange
d3036 8
a3043 8
	clr.l	d0		* clear return result
	lea	_CASHI(pc),a1		* load end of CAS core code
	cmp.l	a1,a0		* is PC in range?
	blt.b	cin_no		* no
	lea	_CASLO(pc),a1		* load begin of CAS core code
	cmp.l	a0,a1		* is PC in range?
	blt.b	cin_no		* no
	rts			* yes; return d0 = 0
d3045 1
a3045 1
	move.l	#-$1,d0		* out of range; return d0 = -1
d3048 2
d3051 3
a3053 4

**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d3056 1
a3056 1
* OS if it is too operating system-specific.		*
d3058 113
a3170 1
* "replace" this section, if necessary.		*
d3172 1
a3172 1
**------------------------------------------------------------------------------------------------------
d3174 2
a3175 73
	*************************************************************************
	* XDEF ****************************************************************	*
	*	_isp_cas2(): "core" emulation code for the cas2 instruction	*
	*					*
	* XREF ****************************************************************	*
	*	_isp_cas2_finish() - only exit point for this emulation code;	*
	*		     do clean-up; calculate ccodes; store 	*
	*		     Compare Ops if appropriate.	*
	*					*
	* INPUT ***************************************************************	*
	*	*see chart below*			*
	* 					*
	* OUTPUT **************************************************************	*
	*	*see chart below*			*
	*					*
	* ALGORITHM ***********************************************************	*
	*	(1) Make several copies of the effective address.	*
	*	(2) Save current SR; Then mask off all maskable interrupts.	*
	*	(3) Save current SFC/DFC (ASSUMED TO BE EQUAL!!!); Then set 	*
	*	    according to whether exception occurred in user or 	*
	*	    supervisor mode.			*
	*	(4) Use "plpaw" instruction to pre-load ATC with effective	*
	*	    address pages(s). THIS SHOULD NOT FAULT!!! The relevant	*
	*	    page(s) should have already been made resident prior to	*
	* 	    entering this routine.			*
	*	(5) Push the operand lines from the cache w/ "cpushl". 	*
	*	    In the 68040, this was done within the locked region. In	*
	* 	    the 68060, it is done outside of the locked region.	*
	*	(6) Use "plpar" instruction to do a re-load of ATC entries for	*
	*	    ADDR1 since ADDR2 entries may have pushed ADDR1 out of the	*
	*	    ATC.				*
	*	(7) Pre-fetch the core emulation instructions by executing	*
	*	    one branch within each physical line (16 bytes) of the code	*
	*	    before actually executing the code.		*
	*	(8) Load the BUSCR w/ the bus lock value.		*
	*	(9) Fetch the source operands using "moves".		*
	*	(10)Do the compares. If both equal, go to step (13).	*
	*	(11)Unequal. No update occurs. But, we do write the DST1 op	*
	*	    back to itself (as w/ the '040) so we can gracefully unlock	*
	*	    the bus (and assert LOCKE*) using BUSCR and the final move.	*
	*	(12)Exit.				*
	*	(13)Write update operand to the DST locations. Use BUSCR to 	*
	*	    assert LOCKE* for the final write operation.	*
	*	(14)Exit.				*
	*					*
	* 	The algorithm is actually implemented slightly differently	*
	* depending on the size of the operation and the misalignment of the 	*
	* operands. A misaligned operand must be written in aligned chunks or	*
	* else the BUSCR register control gets confused.		*
	*					*
	*************************************************************************

	*****************************************************************
	* THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON	*
	* ENTERING _isp_cas2().			*
	*				*
	* D0 = xxxxxxxx				*
	* D1 = xxxxxxxx				*
	* D2 = cmp operand 1			*
	* D3 = cmp operand 2			*
	* D4 = update oper 1			*
	* D5 = update oper 2			*
	* D6 = 'xxxxxxff if supervisor mode; 'xxxxxx00 if user mode	*
	* D7 = 'xxxxxxff if longword operation; 'xxxxxx00 if word 	*
	* A0 = ADDR1				*
	* A1 = ADDR2				*
	* A2 = xxxxxxxx				*
	* A3 = xxxxxxxx				*
	* A4 = xxxxxxxx				*
	* A5 = xxxxxxxx				*
	* A6 = frame pointer			*
	* A7 = stack pointer			*
	*****************************************************************
d3177 1
a3177 2
	*	align	$1000
	* beginning label used by _isp_cas_inrange()
d3179 30
a3208 2
	xdef  	_CASLO
_CASLO:
d3210 4
a3213 11
	xdef  	_isp_cas2
_isp_cas2:	tst.b	d6	* user or supervisor mode?
	bne.b	cas2_supervisor	* supervisor
cas2_user:
	moveq.l	#$1,d0	* load user data fc
	bra.b	cas2_cont
cas2_supervisor:
	moveq.l	#$5,d0	* load supervisor data fc
cas2_cont:
	tst.b	d7	* word or longword?
	beq.w	cas2w	* word
d3215 9
a3223 2
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d3225 16
a3240 83
cas2l:
	move.l	a0,a2	* copy ADDR1
	move.l	a1,a3	* copy ADDR2
	move.l	a0,a4	* copy ADDR1
	move.l	a1,a5	* copy ADDR2

	addq.l	#$3,a4	* ADDR1+3
	addq.l	#$3,a5	* ADDR2+3
	move.l	a2,d1	* ADDR1

	* mask interrupts levels 0-6. save old mask value.

	move.w	sr,d7	* save current SR
	ori.w	#$0700,sr	* inhibit interrupts

	* load the SFC and DFC with the appropriate mode.

	movec	sfc,d6	* save old SFC/DFC
	movec	d0,sfc	* store new SFC
	movec	d0,dfc	* store new DFC

	* pre-load the operand ATC. no page faults should occur here because
	* _real_lock_page() should have taken care of this.

	plpaw	(a2)	* load atc for ADDR1
	plpaw	(a4)	* load atc for ADDR1+3
	plpaw	(a3)	* load atc for ADDR2
	plpaw	(a5)	* load atc for ADDR2+3

	* push the operand lines from the cache if they exist.

	cpushl	dc,(a2)	* push line for ADDR1
	cpushl	dc,(a4)	* push line for ADDR1+3
	cpushl	dc,(a3)	* push line for ADDR2
	cpushl	dc,(a5)	* push line for ADDR2+2

	move.l	d1,a2	* ADDR1
	addq.l	#$3,d1
	move.l	d1,a4	* ADDR1+3

	* if ADDR1 was ATC resident before the above "plpaw" and was executed
	* and it was the next entry scheduled for replacement and ADDR2
	* shares the same set, then the "plpaw" for ADDR2 can push the ADDR1
	* entries from the ATC. so, we do a second set of "plpa"s.

	plpar	(a2)	* load atc for ADDR1
	plpar	(a4)	* load atc for ADDR1+3

	* load the BUSCR values.

	move.l	#$80000000,a2	* assert LOCK* buscr value
	move.l	#$a0000000,a3	* assert LOCKE* buscr value
	move.l	#$00000000,a4	* buscr unlock value

	* there are three possible mis-aligned cases for longword cas. they
	* are separated because the final write which asserts LOCKE* must
	* be aligned.

	move.l	a0,d0	* is ADDR1 misaligned?
	andi.b	#$3,d0
	beq.b	CAS2L_ENTER	* no
	cmp.b	#$2,d0
	beq.w	CAS2L2_ENTER	* yes; word misaligned
	bra.w	CAS2L3_ENTER	* yes; byte misaligned

**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
	*
	* D0 = dst operand 1 <-
	* D1 = dst operand 2 <-
	* D2 = cmp operand 1
	* D3 = cmp operand 2
	* D4 = update oper 1
	* D5 = update oper 2
	* D6 = old SFC/DFC
	* D7 = old SR
	* A0 = ADDR1
	* A1 = ADDR2
	* A2 = bus LOCK*  value
	* A3 = bus LOCKE* value
	* A4 = bus unlock value
	* A5 = xxxxxxxx
	*
d3242 1
a3242 1
	cnop 	0,$10
d3244 4
a3247 4
	movec	a2,buscr	* assert LOCK*
	moves.l	(a1),d1	* fetch Dest2[31:0]
	moves.l	(a0),d0	* fetch Dest1[31:0]
	bra.b 	CAS2L_CONT
d3249 1
a3249 1
	bra.b	*+16
d3252 7
a3258 7
	cmp.l	 d0,d2	* Dest1 - Compare1
	bne.b	CAS2L_NOUPDATE
	cmp.l	 d1,d3	* Dest2 - Compare2
	bne.b	CAS2L_NOUPDATE
	moves.l	d5,(a1)	* Update2[31:0] -> DEST2
	bra.b 	CAS2L_UPDATE
	bra.b	*+16
d3261 5
a3265 5
	movec	a3,buscr	* assert LOCKE*
	moves.l	d4,(a0)	* Update1[31:0] -> DEST1
	movec	a4,buscr	* unlock the bus
	bra.b	cas2l_update_done
	bra.b	*+16
d3268 5
a3272 5
	movec	a3,buscr	* assert LOCKE*
	moves.l	d0,(a0)	* Dest1[31:0] -> DEST1
	movec	a4,buscr	* unlock the bus
	bra.b	cas2l_noupdate_done
	bra.b	*+16
d3282 24
a3305 27
	bra.b	CAS2L_START


**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
	opt !
	*****************************************************************
	* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	*
	* ENTERING _isp_cas2().			*
	*				*
	* D0 = destination[31:0] operand 1		*
	* D1 = destination[31:0] operand 2		*
	* D2 = cmp[31:0] operand 1			*
	* D3 = cmp[31:0] operand 2			*
	* D4 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	*
	* D5 = xxxxxxxx				*
	* D6 = xxxxxxxx				*
	* D7 = xxxxxxxx				*
	* A0 = xxxxxxxx				*
	* A1 = xxxxxxxx				*
	* A2 = xxxxxxxx				*
	* A3 = xxxxxxxx				*
	* A4 = xxxxxxxx				*
	* A5 = xxxxxxxx				*
	* A6 = frame pointer			*
	* A7 = stack pointer			*
	*****************************************************************
d3309 3
a3311 4
	* restore previous SFC/DFC value.

	movec	d6,sfc		* restore old SFC
	movec	d6,dfc		* restore old DFC
d3313 2
a3314 1
	* restore previous interrupt mask level.
d3316 2
a3317 1
	move.w	d7,sr		* restore old SR
a3318 2
	sf	d4		* indicate no update was done
	bra.l	_isp_cas2_finish
d3321 10
a3330 13
	* restore previous SFC/DFC value.

	movec	d6,sfc		* restore old SFC
	movec	d6,dfc		* restore old DFC

	* restore previous interrupt mask level.

	move.w	d7,sr		* restore old SR

	st	d4		* indicate update was done
	bra.l	_isp_cas2_finish

**------------------------------------------------------------------------------------------------------
d3332 1
a3332 1
	cnop 	0,$10
d3334 4
a3337 4
	movec	a2,buscr		* assert LOCK*
	moves.l	(a1),d1		* fetch Dest2[31:0]
	moves.l	(a0),d0		* fetch Dest1[31:0]
	bra.b 	CAS2L2_CONT
d3339 1
a3339 1
	bra.b	*+16
d3342 7
a3348 7
	cmp.l	 d0,d2		* Dest1 - Compare1
	bne.b	CAS2L2_NOUPDATE
	cmp.l	 d1,d3		* Dest2 - Compare2
	bne.b	CAS2L2_NOUPDATE
	moves.l	d5,(a1)		* Update2[31:0] -> Dest2
	bra.b 	CAS2L2_UPDATE
	bra.b	*+16
d3351 6
a3356 6
	swap	d4		* get Update1[31:16]
	moves.w	d4,(a0)+		* Update1[31:16] -> DEST1
	movec	a3,buscr		* assert LOCKE*
	swap	d4		* get Update1[15:0]
	bra.b	CAS2L2_UPDATE2
	bra.b	*+16
d3359 3
a3361 3
	moves.w	d4,(a0)		* Update1[15:0] -> DEST1+$2
	movec	a4,buscr		* unlock the bus
	bra.w	cas2l_update_done
d3363 1
a3363 1
	bra.b	*+16
d3366 6
a3371 6
	swap	d0		* get Dest1[31:16]
	moves.w	d0,(a0)+		* Dest1[31:16] -> DEST1
	movec	a3,buscr		* assert LOCKE*
	swap	d0		* get Dest1[15:0]
	bra.b	CAS2L2_NOUPDATE2
	bra.b	*+16
d3374 3
a3376 3
	moves.w	d0,(a0)		* Dest1[15:0] -> DEST1+$2
	movec	a4,buscr		* unlock the bus
	bra.w	cas2l_noupdate_done
d3378 1
a3378 1
	bra.b	*+16
d3388 1
a3388 1
	bra.b	CAS2L2_START
d3391 1
a3391 2
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d3394 1
a3394 1
	cnop 	0,$10
d3396 4
a3399 4
	movec	a2,buscr	* assert LOCK*
	moves.l	(a1),d1	* fetch Dest2[31:0]
	moves.l	(a0),d0	* fetch Dest1[31:0]
	bra.b 	CAS2L3_CONT
d3401 1
a3401 1
	bra.b	*+16
d3404 7
a3410 7
	cmp.l	 d0,d2	* Dest1 - Compare1
	bne.b	CAS2L3_NOUPDATE
	cmp.l	 d1,d3	* Dest2 - Compare2
	bne.b	CAS2L3_NOUPDATE
	moves.l	d5,(a1)	* Update2[31:0] -> DEST2
	bra.b 	CAS2L3_UPDATE
	bra.b	*+16
d3413 6
a3418 6
	rol.l	#$8,d4	* get Update1[31:24]
	moves.b	d4,(a0)+	* Update1[31:24] -> DEST1
	swap	d4	* get Update1[23:8]
	moves.w	d4,(a0)+	* Update1[23:8] -> DEST1+$1
	bra.b	CAS2L3_UPDATE2
	bra.b	*+16
d3421 4
a3424 4
	rol.l	#$8,d4	* get Update1[7:0]
	movec	a3,buscr	* assert LOCKE*
	moves.b	d4,(a0)	* Update1[7:0] -> DEST1+$3
	bra.b	CAS2L3_UPDATE3
d3426 1
a3426 1
	bra.b	*+16
d3429 2
a3430 2
	movec	a4,buscr	* unlock the bus
	bra.w	cas2l_update_done
d3434 1
a3434 1
	bra.b	*+16
d3437 6
a3442 6
	rol.l	#$8,d0	* get Dest1[31:24]
	moves.b	d0,(a0)+	* Dest1[31:24] -> DEST1
	swap	d0	* get Dest1[23:8]
	moves.w	d0,(a0)+	* Dest1[23:8] -> DEST1+$1
	bra.b	CAS2L3_NOUPDATE2
	bra.b	*+16
d3445 4
a3448 4
	rol.l	#$8,d0	* get Dest1[7:0]
	movec	a3,buscr	* assert LOCKE*
	moves.b	d0,(a0)	* Update1[7:0] -> DEST1+$3
	bra.b	CAS2L3_NOUPDATE3
d3450 1
a3450 1
	bra.b	*+16
d3453 2
a3454 2
	movec	a4,buscr	* unlock the bus
	bra.w	cas2l_noupdate_done
d3458 1
a3458 1
	bra.b	*+14
d3467 1
a3467 1
	bra.w	CAS2L3_START
d3471 2
a3472 2
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d3475 45
a3519 4
	move.l	a0,a2	* copy ADDR1
	move.l	a1,a3	* copy ADDR2
	move.l	a0,a4	* copy ADDR1
	move.l	a1,a5	* copy ADDR2
d3521 7
a3527 3
	addq.l	#$1,a4	* ADDR1+1
	addq.l	#$1,a5	* ADDR2+1
	move.l	a2,d1	* ADDR1
a3528 54
	* mask interrupt levels 0-6. save old mask value.

	move.w	sr,d7	* save current SR
	ori.w	#$0700,sr	* inhibit interrupts

	* load the SFC and DFC with the appropriate mode.

	movec	sfc,d6	* save old SFC/DFC
	movec	d0,sfc	* store new SFC
	movec	d0,dfc	* store new DFC

	* pre-load the operand ATC. no page faults should occur because
	* _real_lock_page() should have taken care of this.

	plpaw	(a2)	* load atc for ADDR1
	plpaw	(a4)	* load atc for ADDR1+1
	plpaw	(a3)	* load atc for ADDR2
	plpaw	(a5)	* load atc for ADDR2+1

	* push the operand cache lines from the cache if they exist.

	cpushl	dc,(a2)	* push line for ADDR1
	cpushl	dc,(a4)	* push line for ADDR1+1
	cpushl	dc,(a3)	* push line for ADDR2
	cpushl	dc,(a5)	* push line for ADDR2+1

	move.l	d1,a2	* ADDR1
	addq.l	#$3,d1
	move.l	d1,a4	* ADDR1+3

	* if ADDR1 was ATC resident before the above "plpaw" and was executed
	* and it was the next entry scheduled for replacement and ADDR2
	* shares the same set, then the "plpaw" for ADDR2 can push the ADDR1
	* entries from the ATC. so, we do a second set of "plpa"s.

	plpar	(a2)	* load atc for ADDR1
	plpar	(a4)	* load atc for ADDR1+3

	* load the BUSCR values.

	move.l	#$80000000,a2	* assert LOCK* buscr value
	move.l	#$a0000000,a3	* assert LOCKE* buscr value
	move.l	#$00000000,a4	* buscr unlock value

	* there are two possible mis-aligned cases for word cas. they
	* are separated because the final write which asserts LOCKE* must
	* be aligned.

	move.l	a0,d0	* is ADDR1 misaligned?
	btst	#$0,d0
	bne.w	CAS2W2_ENTER	* yes
	bra.b	CAS2W_ENTER	* no

**------------------------------------------------------------------------------------------------------
d3546 1
a3546 1
	cnop 	0,$10
d3548 4
a3551 4
	movec	a2,buscr	* assert LOCK*
	moves.w	(a1),d1	* fetch Dest2[15:0]
	moves.w	(a0),d0	* fetch Dest1[15:0]
	bra.b 	CAS2W_CONT2
d3553 1
a3553 1
	bra.b	*+16
d3556 7
a3562 7
	cmp.w	 d0,d2	* Dest1 - Compare1
	bne.b	CAS2W_NOUPDATE
	cmp.w	 d1,d3	* Dest2 - Compare2
	bne.b	CAS2W_NOUPDATE
	moves.w	d5,(a1)	* Update2[15:0] -> DEST2
	bra.b 	CAS2W_UPDATE
	bra.b	*+16
d3565 5
a3569 5
	movec	a3,buscr	* assert LOCKE*
	moves.w	d4,(a0)	* Update1[15:0] -> DEST1
	movec	a4,buscr	* unlock the bus
	bra.b	cas2w_update_done
	bra.b	*+16
d3572 5
a3576 5
	movec	a3,buscr	* assert LOCKE*
	moves.w	d0,(a0)	* Dest1[15:0] -> DEST1
	movec	a4,buscr	* unlock the bus
	bra.b	cas2w_noupdate_done
	bra.b	*+16
d3586 1
a3586 1
	bra.b	CAS2W_START
d3590 1
a3590 1
**------------------------------------------------------------------------------------------------------
d3592 21
a3612 21
	*****************************************************************
	* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON	*
	* ENTERING _isp_cas2().			*
	*				*
	* D0 = destination[15:0] operand 1		*
	* D1 = destination[15:0] operand 2		*
	* D2 = cmp[15:0] operand 1			*
	* D3 = cmp[15:0] operand 2			*
	* D4 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required	*
	* D5 = xxxxxxxx				*
	* D6 = xxxxxxxx				*
	* D7 = xxxxxxxx				*
	* A0 = xxxxxxxx				*
	* A1 = xxxxxxxx				*
	* A2 = xxxxxxxx				*
	* A3 = xxxxxxxx				*
	* A4 = xxxxxxxx				*
	* A5 = xxxxxxxx				*
	* A6 = frame pointer			*
	* A7 = stack pointer			*
	*****************************************************************
d3616 3
a3618 1
	* restore previous SFC/DFC value.
d3620 2
a3621 2
	movec	d6,sfc		* restore old SFC
	movec	d6,dfc		* restore old DFC
d3623 2
a3624 1
	* restore previous interrupt mask level.
a3625 4
	move.w	d7,sr		* restore old SR

	sf	d4		* indicate no update was done
	bra.l	_isp_cas2_finish
d3628 10
a3637 13
	* restore previous SFC/DFC value.

	movec	d6,sfc		* restore old SFC
	movec	d6,dfc		* restore old DFC

	* restore previous interrupt mask level.

	move.w	d7,sr		* restore old SR

	st	d4		* indicate update was done
	bra.l	_isp_cas2_finish

	****
d3640 1
a3640 1
	cnop 	0,$10
d3642 4
a3645 4
	movec	a2,buscr		* assert LOCK*
	moves.w	(a1),d1		* fetch Dest2[15:0]
	moves.w	(a0),d0		* fetch Dest1[15:0]
	bra.b 	CAS2W2_CONT2
d3647 1
a3647 1
	bra.b	*+16
d3650 7
a3656 7
	cmp.w	 	d0,d2	* Dest1 - Compare1
	bne.b	CAS2W2_NOUPDATE
	cmp.w	 	d1,d3	* Dest2 - Compare2
	bne.b	CAS2W2_NOUPDATE
	moves.w	d5,(a1)		* Update2[15:0] -> DEST2
	bra.b 	CAS2W2_UPDATE
	bra.b	*+16
d3659 6
a3664 6
	ror.l	#$8,d4		* get Update1[15:8]
	moves.b	d4,(a0)+		* Update1[15:8] -> DEST1
	movec	a3,buscr		* assert LOCKE*
	rol.l	#$8,d4		* get Update1[7:0]
	bra.b	CAS2W2_UPDATE2
	bra.b	*+16
d3667 3
a3669 3
	moves.b	d4,(a0)		* Update1[7:0] -> DEST1+$1
	movec	a4,buscr		* unlock the bus
	bra.w	cas2w_update_done
d3671 1
a3671 1
	bra.b	*+16
d3674 6
a3679 6
	ror.l	#$8,d0		* get Dest1[15:8]
	moves.b	d0,(a0)+		* Dest1[15:8] -> DEST1
	movec	a3,buscr		* assert LOCKE*
	rol.l	#$8,d0		* get Dest1[7:0]
	bra.b	CAS2W2_NOUPDATE2
	bra.b	*+16
d3682 3
a3684 3
	moves.b	d0,(a0)		* Dest1[7:0] -> DEST1+$1
	movec	a4,buscr		* unlock the bus
	bra.w	cas2w_noupdate_done
d3686 1
a3686 1
	bra.b	*+16
d3696 1
a3696 1
	bra.b	CAS2W2_START
d3700 11
a3710 2
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d3712 69
a3780 68
	* XDEF ****************************************************************
	* 	_isp_cas(): "core" emulation code for the cas instruction
	*
	* XREF ****************************************************************
	*	_isp_cas_finish() - only exit point for this emulation code;
	*		    do clean-up
	*
	* INPUT ***************************************************************
	* see entry chart below*
	*
	* OUTPUT **************************************************************
	*see exit chart below*
	*
	* ALGORITHM ***********************************************************
	* 	(1) Make several copies of the effective address.
	* 	(2) Save current SR; Then mask off all maskable interrupts.
	*	(3) Save current DFC/SFC (ASSUMED TO BE EQUAL!!!); Then set
	*	    SFC/DFC according to whether exception occurred in user or
	*	    supervisor mode.
	*	(4) Use "plpaw" instruction to pre-load ATC with efective
	*	    address page(s). THIS SHOULD NOT FAULT!!! The relevant
	* 	    page(s) should have been made resident prior to entering
	*	    this routine.
	*	(5) Push the operand lines from the cache w/ "cpushl".
	*	    In the 68040, this was done within the locked region. In
	*	    the 68060, it is done outside of the locked region.
	*	(6) Pre-fetch the core emulation instructions by executing one
	*	    branch within each physical line (16 bytes) of the code
	*	    before actually executing the code.
	*	(7) Load the BUSCR with the bus lock value.
	*	(8) Fetch the source operand.
	*	(9) Do the compare. If equal, go to step (12).
	*	(10)Unequal. No update occurs. But, we do write the DST op back
	*	    to itself (as w/ the '040) so we can gracefully unlock
	*	    the bus (and assert LOCKE*) using BUSCR and the final move.
	*	(11)Exit.
	*	(12)Write update operand to the DST location. Use BUSCR to
	*	    assert LOCKE* for the final write operation.
	*	(13)Exit.
	*
	* 	The algorithm is actually implemented slightly diferently
	* depending on the size of the operation and the misalignment of the
	* operand. A misaligned operand must be written in aligned chunks or
	* else the BUSCR register control gets confused.
	*
	*************************************************************************

	*********************************************************
	* THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON
	* ENTERING _isp_cas().
	*
	* D0 = xxxxxxxx
	* D1 = xxxxxxxx
	* D2 = update operand
	* D3 = xxxxxxxx
	* D4 = compare operand
	* D5 = xxxxxxxx
	* D6 = supervisor ('xxxxxxff) or user mode ('xxxxxx00)
	* D7 = longword ('xxxxxxff) or word size ('xxxxxx00)
	* A0 = ADDR
	* A1 = xxxxxxxx
	* A2 = xxxxxxxx
	* A3 = xxxxxxxx
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	* A6 = frame pointer
	* A7 = stack pointer
	*********************************************************
d3782 1
a3782 1
	xdef  	_isp_cas
d3784 2
a3785 2
	tst.b	d6		* user or supervisor mode?
	bne.b	cas_super		* supervisor
d3787 2
a3788 2
	moveq.l	#$1,d0		* load user data fc
	bra.b	cas_cont
d3790 1
a3790 1
	moveq.l	#$5,d0		* load supervisor data fc
d3793 2
a3794 2
	tst.b	d7		* word or longword?
	bne.w	casl		* longword
d3796 1
a3796 1
	****
d3798 33
a3830 34
	move.l	a0,a1		* make copy for plpaw1
	move.l	a0,a2		* make copy for plpaw2
	addq.l	#$1,a2		* plpaw2 points to end of word

	move.l	d2,d3		* d3 = update[7:0]
	lsr.w	#$8,d2		* d2 = update[15:8]

	* mask interrupt levels 0-6. save old mask value.

	move.w	sr,d7		* save current SR
	ori.w	#$0700,sr		* inhibit interrupts

	* load the SFC and DFC with the appropriate mode.

	movec	sfc,d6		* save old SFC/DFC
	movec	d0,sfc		* load new sfc
	movec	d0,dfc		* load new dfc

	* pre-load the operand ATC. no page faults should occur here because
	* _real_lock_page() should have taken care of this.

	plpaw	(a1)		* load atc for ADDR
	plpaw	(a2)		* load atc for ADDR+1

	* push the operand lines from the cache if they exist.

	cpushl	dc,(a1)		* push dirty data
	cpushl	dc,(a2)		* push dirty data

	* load the BUSCR values.

	move.l	#$80000000,a1	* assert LOCK* buscr value
	move.l	#$a0000000,a2	* assert LOCKE* buscr value
	move.l	#$00000000,a3	* buscr unlock value
a3831 8
	* pre-load the instruction cache for the following algorithm.
	* this will minimize the number of cycles that LOCK* will be asserted.

	bra.b	CASW_ENTER	* start pre-loading icache


**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d3849 1
a3849 1
	cnop	0,$10
d3851 5
a3855 5
	movec	a1,buscr	* assert LOCK*
	moves.w	(a0),d0	* fetch Dest[15:0]
	cmp.w	d0,d4	* Dest - Compare
	bne.b	CASW_NOUPDATE
	bra.b 	CASW_UPDATE
d3857 1
a3857 1
	bra.b	*+16
d3860 5
a3864 5
	moves.b	d2,(a0)+	* Update[15:8] -> DEST
	movec	a2,buscr	* assert LOCKE*
	moves.b	d3,(a0)	* Update[7:0] -> DEST+$1
	bra.b	CASW_UPDATE2
	bra.b	*+16
d3867 2
a3868 2
	movec	a3,buscr	* unlock the bus
	bra.b	casw_update_done
d3873 1
a3873 1
	bra.b	*+16
d3876 6
a3881 6
	ror.l	#$8,d0	* get Dest[15:8]
	moves.b	d0,(a0)+	* Dest[15:8] -> DEST
	movec	a2,buscr	* assert LOCKE*
	rol.l	#$8,d0	* get Dest[7:0]
	bra.b 	CASW_NOUPDATE2
	bra.b	*+16
d3884 3
a3886 3
	moves.b	d0,(a0)	* Dest[7:0] -> DEST+$1
	movec	a3,buscr	* unlock the bus
	bra.b	casw_noupdate_done
d3889 1
a3889 1
	bra.b	*+16
d3899 1
a3899 1
	bra.b	CASW_START
d3903 21
a3923 24
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------

	*****************************************************************
	* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON
	* CALLING _isp_cas_finish().
	*
	* D0 = destination[15:0] operand
	* D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required
	* D2 = xxxxxxxx
	* D3 = xxxxxxxx
	* D4 = compare[15:0] operand
	* D5 = xxxxxxxx
	* D6 = xxxxxxxx
	* D7 = xxxxxxxx
	* A0 = xxxxxxxx
	* A1 = xxxxxxxx
	* A2 = xxxxxxxx
	* A3 = xxxxxxxx
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	* A6 = frame pointer
	* A7 = stack pointer
	*****************************************************************
a3925 4
	* restore previous SFC/DFC value.

	movec	d6,sfc		* restore old SFC
	movec	d6,dfc		* restore old DFC
d3927 3
a3929 1
	* restore previous interrupt mask level.
d3931 2
a3932 1
	move.w	d7,sr		* restore old SR
d3934 2
a3935 2
	sf	d1		* indicate no update was done
	bra.l	_isp_cas_finish
a3937 1
	* restore previous SFC/DFC value.
d3939 3
a3941 2
	movec	d6,sfc		* restore old SFC
	movec	d6,dfc		* restore old DFC
d3943 2
a3944 1
	* restore previous interrupt mask level.
d3946 2
a3947 1
	move.w	d7,sr		* restore old SR
d3949 1
a3949 2
	st	d1		* indicate update was done
	bra.l	_isp_cas_finish
a3950 2

**------------------------------------------------------------------------------------------------------
a3953 1

d3955 33
a3987 12
	move.l	a0,a1		* make copy for plpaw1
	move.l	a0,a2		* make copy for plpaw2
	addq.l	#$3,a2		* plpaw2 points to end of longword

	move.l	a0,d1		* byte or word misaligned?
	btst	#$0,d1
	bne.w	casl2		* byte misaligned

	move.l	d2,d3		* d3 = update[15:0]
	swap	d2		* d2 = update[31:16]

	* mask interrupts levels 0-6. save old mask value.
d3989 1
a3989 2
	move.w	sr,d7		* save current SR
	ori.w	#$0700,sr		* inhibit interrupts
a3990 27
	* load the SFC and DFC with the appropriate mode.

	movec	sfc,d6		* save old SFC/DFC
	movec	d0,sfc		* load new sfc
	movec	d0,dfc		* load new dfc

	* pre-load the operand ATC. no page faults should occur here because
	* _real_lock_page() should have taken care of this.

	plpaw	(a1)		* load atc for ADDR
	plpaw	(a2)		* load atc for ADDR+3

	* push the operand lines from the cache if they exist.

	cpushl	dc,(a1)		* push dirty data
	cpushl	dc,(a2)		* push dirty data

	* load the BUSCR values.

	move.l	#$80000000,a1	* assert LOCK* buscr value
	move.l	#$a0000000,a2	* assert LOCKE* buscr value
	move.l	#$00000000,a3	* buscr unlock value

	bra.b	CASL_ENTER	* start pre-loading icache

**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d4008 1
a4008 1
	cnop	0,$10
d4010 5
a4014 5
	movec	a1,buscr	* assert LOCK*
	moves.l	(a0),d0	* fetch Dest[31:0]
	cmp.l	 d0,d4	* Dest - Compare
	bne.b	CASL_NOUPDATE
	bra.b 	CASL_UPDATE
d4016 1
a4016 1
	bra.b	*+16
d4019 5
a4023 5
	moves.w	d2,(a0)+	* Update[31:16] -> DEST
	movec	a2,buscr	* assert LOCKE*
	moves.w	d3,(a0)	* Update[15:0] -> DEST+$2
	bra.b	CASL_UPDATE2
	bra.b	*+16
d4026 2
a4027 2
	movec	a3,buscr	* unlock the bus
	bra.b	casl_update_done
d4032 1
a4032 1
	bra.b	*+16
d4035 6
a4040 6
	swap	d0	* get Dest[31:16]
	moves.w	d0,(a0)+	* Dest[31:16] -> DEST
	swap	d0	* get Dest[15:0]
	movec	a2,buscr	* assert LOCKE*
	bra.b 	CASL_NOUPDATE2
	bra.b	*+16
d4043 3
a4045 3
	moves.w	d0,(a0)	* Dest[15:0] -> DEST+$2
	movec	a3,buscr	* unlock the bus
	bra.b	casl_noupdate_done
d4048 1
a4048 1
	bra.b	*+16
d4058 1
a4058 1
	bra.b	CASL_START
d4062 21
a4082 25

**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------

	*****************************************************************
	* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON
	* CALLING _isp_cas_finish().
	*
	* D0 = destination[31:0] operand
	* D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required
	* D2 = xxxxxxxx
	* D3 = xxxxxxxx
	* D4 = compare[31:0] operand
	* D5 = xxxxxxxx
	* D6 = xxxxxxxx
	* D7 = xxxxxxxx
	* A0 = xxxxxxxx
	* A1 = xxxxxxxx
	* A2 = xxxxxxxx
	* A3 = xxxxxxxx
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	* A6 = frame pointer
	* A7 = stack pointer
	*****************************************************************
a4084 4
	* restore previous SFC/DFC value.

	movec	d6,sfc	* restore old SFC
	movec	d6,dfc	* restore old DFC
d4086 3
a4088 1
	* restore previous interrupt mask level.
d4090 2
a4091 1
	move.w	d7,sr	* restore old SR
d4093 2
a4094 2
	sf	d1	* indicate no update was done
	bra.l	_isp_cas_finish
a4096 4
	* restore previous SFC/DFC value.

	movec	d6,sfc	* restore old SFC
	movec	d6,dfc	* restore old DFC
d4098 3
a4100 1
	* restore previous interrupts mask level.
d4102 2
a4103 1
	move.w	d7,sr	* restore old SR
d4105 2
a4106 2
	st	d1	* indicate update was done
	bra.l	_isp_cas_finish
d4108 1
a4108 1
	***************************************
d4110 27
a4136 2
	move.l	d2,d5	* d5 = Update[7:0]
	lsr.l	#$8,d2
d4138 2
a4139 2
	move.l	d2,d3	* d3 = Update[23:8]
	swap	d2	* d2 = Update[31:24]
d4141 1
a4141 1
	* mask interrupts levels 0-6. save old mask value.
a4142 2
	move.w	sr,d7	* save current SR
	ori.w	#$0700,sr	* inhibit interrupts
d4144 2
a4145 31
	* load the SFC and DFC with the appropriate mode.

	movec	sfc,d6	* save old SFC/DFC
	movec	d0,sfc	* load new sfc
	movec	d0,dfc	* load new dfc

	* pre-load the operand ATC. no page faults should occur here because
	* _real_lock_page() should have taken care of this already.

	plpaw	(a1)	* load atc for ADDR
	plpaw	(a2)	* load atc for ADDR+3

	* puch the operand lines from the cache if they exist.

	cpushl	dc,(a1)	* push dirty data
	cpushl	dc,(a2)	* push dirty data

	* load the BUSCR values.

	move.l	#$80000000,a1	* assert LOCK* buscr value
	move.l	#$a0000000,a2	* assert LOCKE* buscr value
	move.l	#$00000000,a3	* buscr unlock value

	* pre-load the instruction cache for the following algorithm.
	* this will minimize the number of cycles that LOCK* will be asserted.

	bra.b	CASL2_ENTER	* start pre-loading icache


**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d4165 1
a4165 1
	cnop	0,$10
d4167 5
a4171 5
	movec	a1,buscr	* assert LOCK*
	moves.l	(a0),d0	* fetch Dest[31:0]
	cmp.l	 d0,d4	* Dest - Compare
	bne.b	CASL2_NOUPDATE
	bra.b 	CASL2_UPDATE
d4173 1
a4173 1
	bra.b	*+16
d4176 5
a4180 5
	moves.b	d2,(a0)+	* Update[31:24] -> DEST
	moves.w	d3,(a0)+	* Update[23:8] -> DEST+$1
	movec	a2,buscr	* assert LOCKE*
	bra.b	CASL2_UPDATE2
	bra.b	*+16
d4183 3
a4185 3
	moves.b	d5,(a0)	* Update[7:0] -> DEST+$3
	movec	a3,buscr	* unlock the bus
	bra.w	casl_update_done
d4187 1
a4187 1
	bra.b	*+16
d4190 6
a4195 6
	rol.l	#$8,d0	* get Dest[31:24]
	moves.b	d0,(a0)+	* Dest[31:24] -> DEST
	swap	d0	* get Dest[23:8]
	moves.w	d0,(a0)+	* Dest[23:8] -> DEST+$1
	bra.b 	CASL2_NOUPDATE2
	bra.b	*+16
d4198 4
a4201 4
	rol.l	#$8,d0	* get Dest[7:0]
	movec	a2,buscr	* assert LOCKE*
	moves.b	d0,(a0)	* Dest[7:0] -> DEST+$3
	bra.b 	CASL2_NOUPDATE3
d4203 1
a4203 1
	bra.b	*+16
d4206 2
a4207 2
	movec	a3,buscr	* unlock the bus
	bra.w	casl_noupdate_done
d4211 1
a4211 1
	bra.b	*+16
d4221 1
a4221 1
	bra.b	CASL2_START
d4225 4
a4228 1
**------------------------------------------------------------------------------------------------------
d4230 1
a4230 2

	xdef  	_CASHI
a4231 3
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
a4232 1
ISP060_End:	nop
@


1.0.1.6
log
@Difficult. Because of cmp d0,#747 pseudocode, this leds to
spastic code . I have to check all condiconal branches :-(
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.5 1997/03/25 20:42:37 schlote Exp schlote $
a15 1
	NOLIST
a20 4
	include          isp_debug.i
	LIST
_custom	equ	$dff000

a23 2


a27 7
                        bsr	ISP060_Code
                        move.l	4.w,a6
	moveq	#0,d0
	jsr	_LVOWait(a6)
	nop
	rts

d33 1
a33 1
	dc.b	RTF_COLDSTART		; This is a coldstart resident
d48 2
a49 2
ISP060_Code:	PRINT	''
	PRINT	'INSTALLING_MOVEP'
d57 1
a57 1
	PRINT	'MOVEP_INSTALLED'
a180 2
	PRINT	'**** TRAP'

d183 1
a183 1
	movem.l	d0-d7/a0-a5,(EXC_LV+EXC_DREGS,a6)		* store d0-d7/a0-a5
a185 1

d194 1
a194 1
	lea	((SFF0_IVOFF+2),a6),	a0	* Get calc pre except. stack ptr
a246 2
	DBUG	10,'OPCODE=%ld\n',d0

d673 1
a673 1

a749 1
	PRINT	'..CalcEA'
a1536 1
	PRINT	'...MOVEP'
a1801 1
	PRINT	'..CHK2_CMP2'
a2010 1
	PRINT	'..DIV64'
a2464 1
	PRINT	',,MUL64'
a2731 1
	PRINT	'..COMPAND SET2'
a2820 1
	PRINT	'...cas2_fin'
a2987 1
	PRINT	'..COMPANDSET'
d3244 1
a3244 3
_isp_cas2:
	PRINT	'..CAS2'
	tst.b	d6	* user or supervisor mode?
@


1.0.1.7
log
@This first version running
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.6 1997/03/25 21:56:16 schlote Exp schlote $
a21 1
MYDEBUG	SET         1
d62 2
a63 1
ISP060_Code:	DBUG	10,'\nInstalling Isp060 patches to VBR'
d71 1
a71 1
	DBUG	10,' - installed.\n'
d195 1
a195 1
	DBUG	10,'**** TRAP :'
d211 1
a211 1
	lea	((SFF0_IVOFF+2),a6),a0		* Get calc pre except. stack ptr
d226 2
a227 5
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr.l	_imem_read_long		* fetch opword & extword
	MOVE.L	(a0),d0		* load to d0
	MOVE.L	#0,d1
d264 1
a264 1
	DBUG	10,'OPCODE=%lx ',d0
d274 1
a274 1
	btst	#22,d0		* test for div64
d328 1
a328 1
	btst	#24,d0		* test for not movep
d336 1
a336 1
	btst	#27,d0		* test for chk2,cmp2
a352 1
	*bsr.l	_imem_read_word		* read extension word
a400 2
_isp_done:
                        DBUG	10,' (done)\n'
a435 1
	DBUG	10," (Trace)\n"
d486 2
a487 5
	MOVE.B	#$24,(7,SP)
real_chk_end:
	* BRA.L	_060_real_trace
	DBUG	10," (Trace)\n"
	RTE                         		* bra.l	_real_chk
d541 2
a542 5
	
	* BRA.L	_060_real_trace
real_divbyzero_end:
	DBUG	10," (Trace)\n"
	RTE
a616 1
	DBUG	10," (Trace)\n"
d645 1
a645 1
	bra.l	_isp_done	* rte
a694 2
	DBUG	10," (Access)\n"

d769 1
a769 1
	DBUG	15,'CalcEA %08lx',d0
d853 1
a853 1
	dc.w	pc_ind	- 	tbl_ea_mode
d1083 1
a1083 1
	move.l	#0,d1
d1097 1
a1097 1
	move.l	#0,d1
d1111 1
a1111 1
	move.l	#0,d1
d1125 1
a1125 1
	move.l	#0,d1
d1139 1
a1139 1
	move.l	#0,d1
d1153 1
a1153 1
	move.l	#0,d1
d1167 1
a1167 1
	move.l	#0,d1
d1181 1
a1181 1
	move.l	#0,d1
d1286 1
a1286 1
	move.l	#0,d1
d1488 1
a1488 1
	MOVE.L	(A0),D0
d1557 1
a1557 1
	DBUG	10,' -.MOVEP'
d1823 1
a1823 1
	DBUG	10,' - CHK2_CMP2 -'
d1930 1
a1930 2
	*cmp.l 	d1,d2		* ((hi - lo) - (Rn - hi))
	cmp.l 	d2,d1	*@@@@@@@@@@@@	* ((hi - lo) - (Rn - hi))
d2033 1
a2033 1
	DBUG	10,' - DIV64 '
d2042 1
d2093 1
a2093 2
	*cmp.l	d7,d6		* is (divisor <= lo(dividend))
	cmp.l	d6,d7	*@@@@@@@@@@@@@@@@@@@@@@@@@@
d2099 1
a2099 2
	*tdivu.l	d7,d5:d6		* it's only a 32/32 bit div!
                        divul.l	d7,d5:d6
d2107 1
a2107 2
	*cmp.l	d7,d5
	cmp.l	d5,d7
d2204 1
a2204 1
	move.w	d6,d5		* rb + u3
d2206 1
a2206 1
	divu.w	d7,d5
d2208 1
a2208 1
	move.w	d5,d1		* first quotient word
d2210 1
a2210 1
	move.w	d6,d5		* rb + u4
d2212 1
a2212 1
	divu.w	d7,d5
d2215 1
a2215 1
	move.w	d5,d1		* 2nd quotient 'digit'
d2218 1
a2218 1
	move.l	d1,d6		* and quotient
d2250 1
a2250 2
	*cmp.w 	d2, d3		* V1 = U1 ?
	cmp.w 	d3, d2		* V1 = U1 ?
d2269 3
a2271 3
ddadj1: 	move.l	d7,d3
	move.l	d1,d2
	mulu.w	d7,d2		* V2q
d2273 3
a2275 3
	mulu.w	d1,d3		* V1q
	move.l	d5,d4		* U1U2
	sub.l	d3,d4		* U1U2 - V1q
d2287 1
a2287 2
	*cmp.l 	d2,d4
	cmp.l 	d4,d2
d2289 1
a2289 1
	subq.l	#$1,d1		* yes, decrement and recheck
d2295 1
a2295 1
	move.l	d5,-(sp)		* save d5 (d6 already saved)
d2488 1
a2488 2
	DBUG	10,' - MUL64 '

d2491 1
a2491 1
	bgt	mul64_memop		* src is in memory
d2642 1
a2642 1
	**------------------------------------------------------------------------
a2649 2
	DBUG	20, ' - calc_ea back '

d2661 1
a2661 1
	move.l	d0,d3			* store multiplier in d3
d2756 1
a2756 1
	DBUG	10,' - COMPAND SET2 '
d2846 1
a2846 1
	DBUG	20,' - cas2_fin '
d2851 1
a2851 2
	*cmp.w	d0,d2
	cmp.w	d2,d0
d2853 1
a2853 2
	*cmp.w	d1,d3
	cmp.w	d3,d1
d2885 1
a2885 2
	*cmp.l	d0,d2
	cmp.l	d2,d0
d2887 1
a2887 2
	*cmp.l	d1,d3
	cmp.l	d3,d1
d2916 1
a2916 2
**------------------------------------------------------------------------------------------------------

a2921 1

d3014 1
a3014 2
	DBUG	10,' - COMPANDSET '

a3020 1

d3041 1
a3041 1
	move.w	d1,(DC,a6)			* save Dc
d3053 1
a3054 1
	move.l	a2,a0		* pass addr in a0
d3057 1
a3057 1
	**------------------------------------------------------------------------------------------------------
d3069 1
a3069 2
	*cmp.w	d0,d4		* do word compare
	cmp.w	d4,d0		* do word compare
a3074 1
	DBUG 	15,'update2'
d3091 1
a3091 2
	*cmp.l	d0,d4		* do longword compare
	cmp.l	d4,d0		* do longword compare
a3096 1
	DBUG 	15,'update2'
d3167 1
a3167 2
	*cmp.l	a1,a0		* is PC in range?
	cmp.l	a0,a1		* is PC in range?
d3170 1
a3170 2
	*cmp.l	a0,a1		* is PC in range?
	cmp.l	a1,a0		* is PC in range?
d3272 1
a3272 1
	DBUG	10,' - CAS2 '
d3381 1
a3381 2
	*cmp.l	 d0,d2	* Dest1 - Compare1
	cmp.l	 d2,d0	* Dest1 - Compare1
d3383 1
a3383 2
	*cmp.l	 d1,d3	* Dest2 - Compare2
	cmp.l	 d3,d1	* Dest2 - Compare2
d3478 1
a3478 2
	*cmp.l	 d0,d2		* Dest1 - Compare1
	cmp.l	 d2,d0		* Dest1 - Compare1
d3480 1
a3480 2
	*cmp.l	 d1,d3		* Dest2 - Compare2
	cmp.l	 d3,d1		* Dest2 - Compare2
d3541 1
a3541 2
	*cmp.l	 d0,d2	* Dest1 - Compare1
	cmp.l	 d2,d0	* Dest1 - Compare1
d3543 1
a3543 2
	*cmp.l	 d1,d3	* Dest2 - Compare2
	cmp.l	 d3,d1	* Dest2 - Compare2
d3702 1
a3702 2
	*cmp.w	 d0,d2	* Dest1 - Compare1
	cmp.w	 d2,d0	* Dest1 - Compare1
d3704 1
a3704 2
	*cmp.w	 d1,d3	* Dest2 - Compare2
	cmp.w	 d3,d1	* Dest2 - Compare2
d3800 1
a3800 2
	*cmp.w	d0,d2	* Dest1 - Compare1
	cmp.w	d2,d0	* Dest1 - Compare1
d3802 1
a3802 2
	*cmp.w	d1,d3	* Dest2 - Compare2
	cmp.w	d3,d1	* Dest2 - Compare2
a3849 1

d3852 69
a3920 73
**------------------------------------------------------------------------------------------------------
**  CAS
**------------------------------------------------------------------------------------------------------
* XDEF
* 	_isp_cas(): "core" emulation code for the cas instruction
*
* XREF
*	_isp_cas_finish() - only exit point for this emulation code;
*		    do clean-up
*
* INPUT
*
* see entry chart below*
*
* OUTPUT
*
*	see exit chart below*
*
* ALGORITHM * 	(1) Make several copies of the effective address.
* 	(2) Save current SR; Then mask off all maskable interrupts.
*	(3) Save current DFC/SFC (ASSUMED TO BE EQUAL!!!); Then set
*	    SFC/DFC according to whether exception occurred in user or
*	    supervisor mode.
*	(4) Use "plpaw" instruction to pre-load ATC with efective
*	    address page(s). THIS SHOULD NOT FAULT!!! The relevant
* 	    page(s) should have been made resident prior to entering
*	    this routine.
*	(5) Push the operand lines from the cache w/ "cpushl".
*	    In the 68040, this was done within the locked region. In
*	    the 68060, it is done outside of the locked region.
*	(6) Pre-fetch the core emulation instructions by executing one
*	    branch within each physical line (16 bytes) of the code
*	    before actually executing the code.
*	(7) Load the BUSCR with the bus lock value.
*	(8) Fetch the source operand.
*	(9) Do the compare. If equal, go to step (12).
*	(10)Unequal. No update occurs. But, we do write the DST op back
*	    to itself (as w/ the '040) so we can gracefully unlock
*	    the bus (and assert LOCKE*) using BUSCR and the final move.
*	(11)Exit.
*	(12)Write update operand to the DST location. Use BUSCR to
*	    assert LOCKE* for the final write operation.
*	(13)Exit.
*
* The algorithm is actually implemented slightly diferently
* depending on the size of the operation and the misalignment of the
* operand. A misaligned operand must be written in aligned chunks or
* else the BUSCR register control gets confused.
*
*************************************************************************

*********************************************************
* THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON
* ENTERING _isp_cas().
*
* D0 = xxxxxxxx
* D1 = xxxxxxxx
* D2 = update operand
* D3 = xxxxxxxx
* D4 = compare operand
* D5 = xxxxxxxx
* D6 = supervisor ('xxxxxxff) or user mode ('xxxxxx00)
* D7 = longword ('xxxxxxff) or word size ('xxxxxx00)
* A0 = ADDR
* A1 = xxxxxxxx
* A2 = xxxxxxxx
* A3 = xxxxxxxx
* A4 = xxxxxxxx
* A5 = xxxxxxxx
* A6 = frame pointer
* A7 = stack pointer
*
*********************************************************
a3923 1
	DBUG	15,"(cas)"
a3925 1

d3934 1
a3934 2
	*bne.w	casl		* longword
	beq.w	casl		* longword
d3936 1
a3936 1
	**----------------------------------------------**
a3937 1
	DBUG	15,' W'
d3979 18
a3996 18
	**------------------------------------------------------------------------
	**------------------------------------------------------------------------
	*
	* D0 = dst operand <-
	* D1 = update[15:8] operand
	* D2 = update[7:0]  operand
	* D3 = xxxxxxxx
	* D4 = compare[15:0] operand
	* D5 = xxxxxxxx
	* D6 = old SFC/DFC
	* D7 = old SR
	* A0 = ADDR
	* A1 = bus LOCK*  value
	* A2 = bus LOCKE* value
	* A3 = bus unlock value
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	*
a3997 1

d3999 2
a4000 1
CASW_START:	movec	a1,buscr	* assert LOCK*
d4002 1
a4002 2
	*cmp.w	d0,d4	* Dest - Compare
	cmp.w	d4,d0	* Dest - Compare
d4008 2
a4009 1
CASW_UPDATE:	moves.b	d2,(a0)+	* Update[15:8] -> DEST
d4013 1
a4014 1
	bra.b	*+16
d4052 3
a4087 1
	DBUG	15,' noupdate1'
a4100 1
	DBUG	15,' update1 %lx',d1
d4104 4
a4107 4
	**------------------------------------------------------------------------------------------------------
	* there are two possible mis-aligned cases for longword cas. they
	* are separated because the final write which asserts LOCKE* must
	* be an aligned write.
a4109 2
	DBUG	15,' L'

d4151 18
a4168 18
	**------------------------------------------------------------------------------------------------------
	**------------------------------------------------------------------------------------------------------
	*
	* D0 = dst operand <-
	* D1 = xxxxxxxx
	* D2 = update[31:16] operand
	* D3 = update[15:0]  operand
	* D4 = compare[31:0] operand
	* D5 = xxxxxxxx
	* D6 = old SFC/DFC
	* D7 = old SR
	* A0 = ADDR
	* A1 = bus LOCK*  value
	* A2 = bus LOCKE* value
	* A3 = bus unlock value
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	*
d4174 1
a4174 2
	*cmp.l	 d0,d4	* Dest - Compare
	cmp.l	 d4,d0	* Dest - Compare
d4224 4
a4259 1
	DBUG	15,' update'
a4272 1
	DBUG	15,' update'
d4317 21
a4337 20
	**------------------------------------------------------------------------------------------------------
	**------------------------------------------------------------------------------------------------------
	*
	* D0 = dst operand <-
	* D1 = xxxxxxxx
	* D2 = update[31:24] operand
	* D3 = update[23:8]  operand
	* D4 = compare[31:0] operand
	* D5 = update[7:0]  operand
	* D6 = old SFC/DFC
	* D7 = old SR
	* A0 = ADDR
	* A1 = bus LOCK*  value
	* A2 = bus LOCKE* value
	* A3 = bus unlock value
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	**
	** DO NOT TOUCH CODE !!!
	*
d4343 1
a4343 2
	*cmp.l	 d0,d4	* Dest - Compare
	cmp.l	 d4,d0	* Dest - Compare
@


1.0.1.8
log
@It is working ??? It seems to work....... better save it :-)
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.7 1997/03/26 15:28:33 schlote Exp schlote $
d22 1
a23 4

MYDEBUG	SET         	1
DEBUG_DETAIL 	set 	10

d39 1
a39 1
	jsr	_LVOWait(a6)	; Wait forever
d48 4
a51 4
	dc.b	RTF_COLDSTART			; This is a coldstart resident
	dc.b	43                             	; Version 43
	dc.b             NT_UNKNOWN			; Type
	dc.b	115			; Do patches right before diag.init
d80 39
d195 1
a195 1
	DBUG	15,'**** TRAP :'
d267 1
a267 1
	DBUG	15,'OPCODE=%lx ',d0
d358 5
a362 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.w	isp_iacc		* yes
d406 1
a406 1
                        DBUG	15,'isp_done\n'
d442 1
a442 1
	DBUG	15," (Trace)\n"
d496 1
a496 1
	DBUG	15," (Trace)\n"
d554 1
a554 1
	DBUG	15," (Trace)\n"
d630 1
a630 1
	DBUG	15," (Trace)\n"
d709 1
a709 1
	DBUG	15," (Access)\n"
a726 24
























d785 1
a785 1
	DBUG	20,'CalcEA %08lx',d0
a1533 11











d1573 1
a1573 1
	DBUG	20,' -.MOVEP'
a1687 1
	CLR.L	d0
a1699 1
	CLR.L	d0
a1712 1
	CLR.L	d0
a1725 1
	CLR.L	d0
a1747 1
	CLR.L	d0
a1759 1
	CLR.L	d0
a1800 19



















d1839 1
a1839 1
	DBUG	20,' - CHK2_CMP2 '
a1996 19



















d2050 1
a2050 1
	DBUG	20,' - DIV64 '
d2269 2
a2270 2
	cmp.w 	d2, d3		* V1 = U1 ?
	*cmp.w 	d3, d2		* V1 = U1 ?
d2307 2
a2308 2
	cmp.l 	d2,d4
	*cmp.l 	d4,d2
a2466 17

















d2509 1
a2509 1
	DBUG	20,' - MUL64 '
a2722 18


















d2725 1
d2727 4
a2730 10
*	_compandset(): routine to emulate cas w/ misaligned <ea>
*	       (internal to package)
*	_isp_cas_finish(): routine called when cas emulation completes
*		   (external and internal to package)
*	_isp_cas_restart(): restart cas emulation after a fault
*		    (external to package)
*	_isp_cas_terminate(): create access error stack frame on fault
*		      (external and internal to package)
*	_isp_cas_inrange(): checks whether instr addess is within range
*		    of core cas/cas2emulation code
d2734 4
a2737 1
* 	_calc_ea(): calculate effective address
d2740 5
a2744 11
* compandset():
* 	none
* _isp_cas_restart():
*	d6 = previous sfc/dfc
* _isp_cas_finish():
* _isp_cas_terminate():
*	a0 = failing address
*	d0 = FSLW
*	d6 = previous sfc/dfc
* _isp_cas_inrange():
*	a0 = instruction address to be checked
d2747 3
a2749 5
* compandset():
*	none
* _isp_cas_restart():
*	a0 = effective address
*	d7 = word or longword flag
d2751 1
a2751 5
*	a0 = effective address
* _isp_cas_terminate():
*	initial register set before emulation exception
* _isp_cas_inrange():
*	d0 = 0 => in range; -1 => out of range
d2754 9
d2764 5
a2768 30
* compandset():
*	First, calculate the effective address. Then, decode the
* instruction word and fetch the "compare" (DC) and "update" (Du)
* operands.
* 	Next, call the external routine _real_lock_page() so that the
* operating system can keep this page from being paged out while we're
* in this routine. If this call fails, jump to _cas_terminate2().
*	The routine then branches to _real_cas(). This external routine
* that actually emulates cas can be supplied by the external os or
* made to point directly back into the 060ISP which has a routine for
* this purpose.
*
* _isp_cas_finish():
* 	Either way, after emulation, the package is re-entered at
* _isp_cas_finish(). This routine re-compares the operands in order to
* set the condition codes. Finally, these routines will call
* _real_unlock_page() in order to unlock the pages that were previously
* locked.
*
* _isp_cas_restart():
*	This routine can be entered from an access error handler where
* the emulation sequence should be re-started from the beginning.
*
* _isp_cas_terminate():
*	This routine can be entered from an access error handler where
* an emulation operand access failed and the operating system would
* like an access error stack frame created instead of the current
* unimplemented integer instruction frame.
* 	Also, the package enters here if a call to _real_lock_page()
* fails.
a2771 15
**------------------------------------------------------------------------------------------------------
***** Call sequence
* 	bra.l	_isp_cas               	* |  code
* 	dc.w	0
* 	bra.l	_isp_cas2               	* |  code
* 	dc.w	0
* 	bra.l	_isp_cas_finish         	* 	External CAS Handler
* 	dc.w	0                       	* |  exit here !!!
* 	bra.l	_isp_cas2_finish        	* v
* 	dc.w	0
* 	bra.l	_isp_cas_terminate      * Create ACCESS FAULT Frame
* 	dc.w	0
* 	bra.l	_isp_cas_restart        * Restart CAS op !
* 	dc.w	0
* 	ds.b	64
d2773 4
d2778 5
d2784 4
a2787 2
DC	equ	(EXC_LV+EXC_TEMP+$8)           * Number of Compare Register
ADDR	equ	(EXC_LV+EXC_TEMP+$4)		* EA Ptr
d2789 1
a2789 3
	xdef  	_compandset
_compandset:
	DBUG	15,'\nCOMPAND SET 1 :',(EXC_LV+EXC_OPWORD,a6)
d2791 3
a2793 2
	btst	#$1,(EXC_LV+EXC_OPWORD,a6)	* word or long operation?
	bne.b	compandsetl		* long
d2795 3
a2797 3
	**------------------------------------------------
compandsetw:
	DBUG	15,' cas.w'
d2799 2
a2800 2
	moveq.l	#$2,d0		* size = 2 bytes
	bsr.l	_calc_ea		* a0 = calculated <ea>
d2802 4
a2805 3
	move.l	a0,(ADDR,a6)		* save <ea> for possible restart
	move.b	#0,d7		* clear d7 for word size
	bra.b	compandsetfetch
d2807 1
a2807 3
	**------------------------------------------------
compandsetl:
	DBUG	15,' cas.l'
d2809 3
a2811 2
	moveq.l	#$4,d0		* size = 4 bytes
	bsr.l	_calc_ea		* a0 = calculated <ea>
d2813 3
a2815 2
	move.l	a0,(ADDR,a6)		* save <ea> for possible restart
	move.b	#-1,d7		* set d7 for longword size
d2817 2
a2818 1
	**------------------------------------------------
d2820 2
a2821 1
compandsetfetch:
d2823 2
a2824 2
	move.w	(EXC_LV+EXC_EXTWORD,a6),d0	* fetch cas extension word
	move.l	d0,d1		* make a copy
d2826 2
a2827 3
	lsr.w	#$6,d0
	andi.w	#$7,d0			* extract Du
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),d2 	* get update operand
d2829 2
a2830 3
	andi.w	#$7,d1			* extract Dc
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d4 	* get compare operand
	move.w	d1,(DC,a6)			* save Dc
d2832 3
a2834 2
	btst	#$5,(SFF0_ISR,a6)		* which mode for exception?
	sne	d6		* set on supervisor mode
a2835 1
	move.l	a0,a2		* save temporarily
d2838 1
a2838 1

d2840 1
a2840 3
	*CLR.L	d0
	*tst.l	d0		* did error occur?
	*bne.w	_cas_terminate2		* yes, clean up the mess
d2842 3
a2844 1
	move.l	a2,a0		* pass addr in a0
d2846 2
a2847 1
	DBUG	15,' dc:%08lx, du:%08lx,ea:%08lx,d6:%08lx,d7:%08lx',d4,d2,(a0),d6,d7
d2849 1
a2849 22
	*********************************************************
	* THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON
	* ENTERING _isp_cas().
	*
	* D0 = xxxxxxxx
	* D1 = xxxxxxxx
	* D2 = update operand
	* D3 = xxxxxxxx
	* D4 = compare operand
	* D5 = xxxxxxxx
	* D6 = supervisor ('xxxxxxff) or user mode ('xxxxxx00)
	* D7 = longword ('xxxxxxff) or word size ('xxxxxx00)
	* A0 = ADDR
	* A1 = xxxxxxxx
	* A2 = xxxxxxxx
	* A3 = xxxxxxxx
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	* A6 = frame pointer
	* A7 = stack pointer
	*
	*********************************************************
d2851 2
a2852 50
	**------------------------------------------------------------------------------------------------------
	**  CAS
	**------------------------------------------------------------------------------------------------------
	* XDEF
	* 	_isp_cas():	      "core" emulation code for the cas instruction
	*
	* XREF
	*	_isp_cas_finish()    - only exit point for this emulation code;
	*		      do clean-up
	*
	* INPUT
	*
	* see entry chart below*
	*
	* OUTPUT
	*
	*	see exit chart below*
	*
	* ALGORITHM * 	(1) Make several copies of the effective address.
	* 	(2) Save current SR; Then mask off all maskable interrupts.
	*	(3) Save current DFC/SFC (ASSUMED TO BE EQUAL!!!); Then set
	*	    SFC/DFC according to whether exception occurred in user or
	*	    supervisor mode.
	*	(4) Use "plpaw" instruction to pre-load ATC with efective
	*	    address page(s). THIS SHOULD NOT FAULT!!! The relevant
	* 	    page(s) should have been made resident prior to entering
	*	    this routine.
	*	(5) Push the operand lines from the cache w/ "cpushl".
	*	    In the 68040, this was done within the locked region. In
	*	    the 68060, it is done outside of the locked region.
	*	(6) Pre-fetch the core emulation instructions by executing one
	*	    branch within each physical line (16 bytes) of the code
	*	    before actually executing the code.
	*	(7) Load the BUSCR with the bus lock value.
	*	(8) Fetch the source operand.
	*	(9) Do the compare. If equal, go to step (12).
	*	(10)Unequal. No update occurs. But, we do write the DST op back
	*	    to itself (as w/ the '040) so we can gracefully unlock
	*	    the bus (and assert LOCKE*) using BUSCR and the final move.
	*	(11)Exit.
	*	(12)Write update operand to the DST location. Use BUSCR to
	*	    assert LOCKE* for the final write operation.
	*	(13)Exit.
	*
	* The algorithm is actually implemented slightly diferently
	* depending on the size of the operation and the misalignment of the
	* operand. A misaligned operand must be written in aligned chunks or
	* else the BUSCR register control gets confused.
	*
	*************************************************************************
d2854 7
a2860 22
	*********************************************************
	* THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON
	* ENTERING _isp_cas().
	*
	* D0 = xxxxxxxx
	* D1 = xxxxxxxx
	* D2 = update operand
	* D3 = xxxxxxxx
	* D4 = compare operand
	* D5 = xxxxxxxx
	* D6 = supervisor ('xxxxxxff) or user mode ('xxxxxx00)
	* D7 = longword ('xxxxxxff) or word size ('xxxxxx00)
	* A0 = ADDR
	* A1 = xxxxxxxx
	* A2 = xxxxxxxx
	* A3 = xxxxxxxx
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	* A6 = frame pointer
	* A7 = stack pointer
	*
	*********************************************************
d2862 3
a2864 4
_isp_cas:
	DBUG	15,"\n cas_core"
	tst.b	d6		* user or supervisor mode?
	bne.b	cas_super		* supervisor
d2866 1
a2866 5
cas_user:
	moveq.l	#$1,d0		* load user data fc
	bra.b	cas_cont
cas_super:
	moveq.l	#$5,d0		* load supervisor data fc
d2868 5
a2872 3
cas_cont:
	tst.b	d7		* word or longword?
	bne.w	casl		* longword
d2874 8
a2881 7
	**----------------------------------------------**---------------------------------
	**----------------------------------------------**---------------------------------
casw:
	DBUG	15,' WORD'
	move.l	a0,a1		* make copy for plpaw1
	move.l	a0,a2		* make copy for plpaw2
	addq.l	#$1,a2		* plpaw2 points to end of word
d2883 2
a2884 4
	DBUG             15,' a0:%08lx (%08lx)',a0,(a0)
	DBUG             15,' d2:%08lx',d2
	move.l	d2,d3		* d3 = update[7:0]
	lsr.w	#$8,d2		* d2 = update[15:8]
d2886 2
a2887 1
	* mask interrupt levels 0-6. save old mask value.
d2889 2
a2890 2
	move.w	sr,d7		* save current SR
	ori.w	#$0700,sr		* inhibit interrupts
d2892 8
a2899 1
	* load the SFC and DFC with the appropriate mode.
d2901 5
a2905 3
	movec	sfc,d6		* save old SFC/DFC
	movec	d0,sfc		* load new sfc
	movec	d0,dfc		* load new dfc
d2907 1
a2907 2
	* pre-load the operand ATC. no page faults should occur here because
	* _real_lock_page() should have taken care of this.
d2909 9
a2917 2
	plpaw	(a1)		* load atc for ADDR
	plpaw	(a2)		* load atc for ADDR+1
d2919 2
a2920 1
	* push the operand lines from the cache if they exist.
d2922 2
a2923 2
	cpushl	dc,(a1)		* push dirty data
	cpushl	dc,(a2)		* push dirty data
d2925 2
a2926 1
	* load the BUSCR values.
d2928 8
a2935 3
	move.l	#$80000000,a1	* assert LOCK* buscr value
	move.l	#$a0000000,a2	* assert LOCKE* buscr value
	move.l	#$00000000,a3	* buscr unlock value
d2937 6
a2942 21
	**------------------------------------------------------------------------
	* pre-load the instruction cache for the following algorithm.
	* this will minimize the number of cycles that LOCK* will be asserted.
	**------------------------------------------------------------------------
	*
	* D0 = dst operand <-
	* D1 = xxxxxxxx
	* D2 = update[15:8] operand
	* D3 = update[7:0]  operand
	* D4 = compare[15:0] operand
	* D5 = xxxxxxxx
	* D6 = old SFC/DFC
	* D7 = old SR
	* A0 = ADDR
	* A1 = bus LOCK*  value
	* A2 = bus LOCKE* value
	* A3 = bus unlock value
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	*
                        XDEF	CASW_START
d2944 1
a2944 2
	opt 0
	bra.b	CASW_ENTER	* start pre-loading icache
d2946 4
a2949 8
	cnop	0,$10
CASW_START:	movec	a1,buscr	* assert LOCK*
	moves.w	(a0),d0	* fetch Dest[15:0]
	*cmp.w	d0,d4	* Dest - Compare
	cmp.w	d4,d0	* Dest - Compare
	bne.b	CASW_NOUPDATE          * different - copy (a0) -> dc
	bra.b 	CASW_UPDATE            * equal - copy du -> (a0)
CASW_ENTER:  bra.b	*+14
a2950 5
CASW_UPDATE:	moves.b	d2,(a0)+	* Update[15:8] -> DEST
	movec	a2,buscr	* assert LOCKE*
	moves.b	d3,(a0)	* Update[7:0] -> DEST+$1
	bra.b	CASW_UPDATE2
             bra.b	*+14
d2952 86
a3037 7
CASW_UPDATE2:	movec	a3,buscr	* unlock the bus
	bra.b	casw_update_done
	nop
	nop
	nop
	nop
             bra.b	*+14
d3039 2
a3040 7
CASW_NOUPDATE:                            	* Write old EA value back !!!!
	ror.l	#$8,d0	* get Dest[15:8]
	moves.b	d0,(a0)+	* Dest[15:8] -> DEST
	movec	a2,buscr	* assert LOCKE*
	rol.l	#$8,d0	* get Dest[7:0]
	bra.b 	CASW_NOUPDATE2
             bra.b	*+14
d3042 3
a3044 6
CASW_NOUPDATE2:	moves.b	d0,(a0)	* Dest[7:0] -> DEST+$1
	movec	a3,buscr	* unlock the bus
	bra.b	casw_noupdate_done
	nop
	nop
             bra.b	*+14
d3046 2
a3047 8
CASW_FILLER:	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b	CASW_START
d3049 3
a3051 1
	opt !
d3053 3
a3055 5
casw_noupdate_done:
	move.b	#0,d1		* indicate no update was done
     	BRA	casw_end                       * do reg update
casw_update_done:
	move.b	#-1,d1		* indicate update was done
d3057 5
d3063 3
a3065 1
casw_end:	* restore previous SFC/DFC value.
d3067 3
a3069 2
	movec	d6,sfc		* restore old SFC
	movec	d6,dfc		* restore old DFC
d3071 3
a3073 1
	* restore previous interrupt mask level.
d3075 2
a3076 1
	move.w	d7,sr		* restore old SR
d3078 7
a3084 321
	DBUG	15,'\na0:=%08lx d1:=%08lx( 0=Register must be updated',a0,d1
	bra.l	_isp_cas_finish


	*****************************************************************
	* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON
	* CALLING _isp_cas_finish().
	*
	* D0 = destination[15:0] operand
	* D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required
	* D2 = xxxxxxxx
	* D3 = xxxxxxxx
	* D4 = compare[15:0] operand
	* D5 = xxxxxxxx
	* D6 = xxxxxxxx
	* D7 = xxxxxxxx
	* A0 = xxxxxxxx
	* A1 = xxxxxxxx
	* A2 = xxxxxxxx
	* A3 = xxxxxxxx
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	* A6 = frame pointer
	* A7 = stack pointer
	*****************************************************************



	**------------------------------------------------------------------------------------------------------
	**------------------------------------------------------------------------------------------------------
	**------------------------------------------------------------------------------------------------------
	**------------------------------------------------------------------------------------------------------
	* there are two possible mis-aligned cases for longword cas. they
	* are separated because the final write which asserts LOCKE* must
	* be an aligned write.

casl:
	DBUG	15,' #CMP.L'

	move.l	a0,a1		* make copy for plpaw1
	move.l	a0,a2		* make copy for plpaw2
	addq.l	#$3,a2		* plpaw2 points to end of longword

	move.l	a0,d1		* byte or word misaligned?
	btst	#$0,d1
	bne.w	casl2		* byte misaligned

	move.l	d2,d3		* d3 = update[15:0]
	swap	d2		* d2 = update[31:16]

	* mask interrupts levels 0-6. save old mask value.

	move.w	sr,d7		* save current SR
	ori.w	#$0700,sr		* inhibit interrupts

	* load the SFC and DFC with the appropriate mode.

	movec	sfc,d6		* save old SFC/DFC
	movec	d0,sfc		* load new sfc
	movec	d0,dfc		* load new dfc

	* pre-load the operand ATC. no page faults should occur here because
	* _real_lock_page() should have taken care of this.

	plpaw	(a1)		* load atc for ADDR
	plpaw	(a2)		* load atc for ADDR+3

	* push the operand lines from the cache if they exist.

	cpushl	dc,(a1)		* push dirty data
	cpushl	dc,(a2)		* push dirty data

	* load the BUSCR values.

	move.l	#$80000000,a1	* assert LOCK* buscr value
	move.l	#$a0000000,a2	* assert LOCKE* buscr value
	move.l	#$00000000,a3	* buscr unlock value

	bra.b	CASL_ENTER	* start pre-loading icache

	**------------------------------------------------------------------------------------------------------
	**------------------------------------------------------------------------------------------------------
	*
	* D0 = dst operand <-
	* D1 = xxxxxxxx
	* D2 = update[31:16] operand
	* D3 = update[15:0]  operand
	* D4 = compare[31:0] operand
	* D5 = xxxxxxxx
	* D6 = old SFC/DFC
	* D7 = old SR
	* A0 = ADDR
	* A1 = bus LOCK*  value
	* A2 = bus LOCKE* value
	* A3 = bus unlock value
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	*
	opt 0
	cnop	0,$10
CASL_START:
	movec	a1,buscr	* assert LOCK*
	moves.l	(a0),d0	* fetch Dest[31:0]
	*cmp.l	 d0,d4	* Dest - Compare
	cmp.l	 d4,d0	* Dest - Compare
	bne.b	CASL_NOUPDATE
	bra.b 	CASL_UPDATE
CASL_ENTER:
	bra.b	*+14

CASL_UPDATE:
	moves.w	d2,(a0)+	* Update[31:16] -> DEST
	movec	a2,buscr	* assert LOCKE*
	moves.w	d3,(a0)	* Update[15:0] -> DEST+$2
	bra.b	CASL_UPDATE2
	bra.b	*+14

CASL_UPDATE2:
	movec	a3,buscr	* unlock the bus
	bra.b	casl_update_done
	nop
	nop
	nop
	nop
	bra.b	*+14

CASL_NOUPDATE:
	swap	d0	* get Dest[31:16]
	moves.w	d0,(a0)+	* Dest[31:16] -> DEST
	swap	d0	* get Dest[15:0]
	movec	a2,buscr	* assert LOCKE*
	bra.b 	CASL_NOUPDATE2
	bra.b	*+14

CASL_NOUPDATE2:
	moves.w	d0,(a0)	* Dest[15:0] -> DEST+$2
	movec	a3,buscr	* unlock the bus
	bra.b	casl_noupdate_done
	nop
	nop
	bra.b	*+14

CASL_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b	CASL_START

	opt !

	*****************************************************************
	* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON
	* CALLING _isp_cas_finish().
	*
	* D0 = destination[31:0] operand
	* D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required
	* D2 = xxxxxxxx
	* D3 = xxxxxxxx
	* D4 = compare[31:0] operand
	* D5 = xxxxxxxx
	* D6 = xxxxxxxx
	* D7 = xxxxxxxx
	* A0 = xxxxxxxx
	* A1 = xxxxxxxx
	* A2 = xxxxxxxx
	* A3 = xxxxxxxx
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	* A6 = frame pointer
	* A7 = stack pointer
	*****************************************************************

casl_noupdate_done:
	move.b	#0,d1	* indicate no update was done
	bra	casl_end
casl_update_done:
	move.b	#-1,d1
casl_end:

	* restore previous SFC/DFC value.

	movec	d6,sfc	* restore old SFC
	movec	d6,dfc	* restore old DFC

	* restore previous interrupt mask level.

	move.w	d7,sr	* restore old SR

	DBUG	15,'\na0:=%08lx d1:=%08lx( 0=Register must be updated',a0,d1
	bra.l	_isp_cas_finish

	***************************************

casl2:
	move.l	d2,d5	* d5 = Update[7:0]
	lsr.l	#$8,d2

	move.l	d2,d3	* d3 = Update[23:8]
	swap	d2	* d2 = Update[31:24]

	* mask interrupts levels 0-6. save old mask value.

	move.w	sr,d7	* save current SR
	ori.w	#$0700,sr	* inhibit interrupts

	* load the SFC and DFC with the appropriate mode.

	movec	sfc,d6	* save old SFC/DFC
	movec	d0,sfc	* load new sfc
	movec	d0,dfc	* load new dfc

	* pre-load the operand ATC. no page faults should occur here because
	* _real_lock_page() should have taken care of this already.

	plpaw	(a1)	* load atc for ADDR
	plpaw	(a2)	* load atc for ADDR+3

	* puch the operand lines from the cache if they exist.

	cpushl	dc,(a1)	* push dirty data
	cpushl	dc,(a2)	* push dirty data

	* load the BUSCR values.

	move.l	#$80000000,a1	* assert LOCK* buscr value
	move.l	#$a0000000,a2	* assert LOCKE* buscr value
	move.l	#$00000000,a3	* buscr unlock value

	* pre-load the instruction cache for the following algorithm.
	* this will minimize the number of cycles that LOCK* will be asserted.

	bra.b	CASL2_ENTER	* start pre-loading icache


	**------------------------------------------------------------------------------------------------------
	**------------------------------------------------------------------------------------------------------
	*
	* D0 = dst operand <-
	* D1 = xxxxxxxx
	* D2 = update[31:24] operand
	* D3 = update[23:8]  operand
	* D4 = compare[31:0] operand
	* D5 = update[7:0]  operand
	* D6 = old SFC/DFC
	* D7 = old SR
	* A0 = ADDR
	* A1 = bus LOCK*  value
	* A2 = bus LOCKE* value
	* A3 = bus unlock value
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	**
	** DO NOT TOUCH CODE !!!
	*
	opt 0
	cnop	0,$10
CASL2_START:
	movec	a1,buscr	* assert LOCK*
	moves.l	(a0),d0	* fetch Dest[31:0]
	*cmp.l	 d0,d4	* Dest - Compare
	cmp.l	 d4,d0	* Dest - Compare
	bne.b	CASL2_NOUPDATE
	bra.b 	CASL2_UPDATE
CASL2_ENTER:
           bra.b *+14

CASL2_UPDATE:
	moves.b	d2,(a0)+	* Update[31:24] -> DEST
	moves.w	d3,(a0)+	* Update[23:8] -> DEST+$1
	movec	a2,buscr	* assert LOCKE*
	bra.b	CASL2_UPDATE2
           bra.b *+14

CASL2_UPDATE2:
	moves.b	d5,(a0)	* Update[7:0] -> DEST+$3
	movec	a3,buscr	* unlock the bus
	bra.w	casl_update_done
	nop
	bra.b	*+14

CASL2_NOUPDATE:
	rol.l	#$8,d0	* get Dest[31:24]
	moves.b	d0,(a0)+	* Dest[31:24] -> DEST
	swap	d0	* get Dest[23:8]
	moves.w	d0,(a0)+	* Dest[23:8] -> DEST+$1
	bra.b 	CASL2_NOUPDATE2
	bra.b	*+14

CASL2_NOUPDATE2:
	rol.l	#$8,d0	* get Dest[7:0]
	movec	a2,buscr	* assert LOCKE*
	moves.b	d0,(a0)	* Dest[7:0] -> DEST+$3
	bra.b 	CASL2_NOUPDATE3
	nop
	bra.b	*+14

CASL2_NOUPDATE3:
	movec	a3,buscr	* unlock the bus
	bra.w	casl_noupdate_done
	nop
	nop
	nop
	bra.b	*+14

CASL2_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b	CASL2_START

	opt !

**------------------------------------------------------------------------------------------------------
d3086 2
d3092 1
a3092 25
	xdef  	_isp_cas_finish

	*****************************************************************
	* THIS MUST BE THE STATE OF THE INTEGER REGISTER FILE UPON
	* CALLING _isp_cas_finish().
	*
	* D0 = destination[15:0] operand
	* D1 = 'xxxxxx11 -> no reg update; 'xxxxxx00 -> update required
	* D2 = xxxxxxxx
	* D3 = xxxxxxxx
	* D4 = compare[15:0] operand
	* D5 = xxxxxxxx
	* D6 = xxxxxxxx
	* D7 = xxxxxxxx
	* A0 = xxxxxxxx
	* A1 = xxxxxxxx
	* A2 = xxxxxxxx
	* A3 = xxxxxxxx
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	* A6 = frame pointer
	* A7 = stack pointer
	*****************************************************************


a3096 1
	**------------------------------------------------
d3108 1
a3109 1
	DBUG 	15,'\n update_reg.w %lx (%08lx)',d3,d0
d3114 3
a3116 3
	*sf	d1		* pass size
	*btst	#$5,(SFF0_ISR,a6)
	*sne	d0		* pass mode
a3118 1
	DBUG	15,'\ncas_w_fin: dc:%08lx, dest:%08lx,ea:%08lx',d4,d0,(a0)
a3120 1
	**------------------------------------------------
d3132 1
a3133 1
	DBUG 	15,'\n update_reg.l %lx (%08lx)',d3,d0
d3138 3
a3140 3
	*st	d1		* pass size
	*btst	#$5,(SFF0_ISR,a6)
	*sne	d0		* pass mode
a3141 1
	DBUG	15,'\ncas_l_fin: dc:%08lx, dest:%08lx,ea:%08lx',d4,d0,(a0)
a3144 5





d3199 28
d3228 51
d3280 21
d3302 2
d3305 2
d3308 13
d3322 2
d3325 5
d3331 3
d3335 1
d3337 2
d3340 1
d3342 3
d3346 2
d3349 4
d3354 1
d3356 4
d3361 3
d3365 4
d3370 2
d3373 1
d3375 3
d3379 3
d3383 6
d3392 62
d3456 39
a3494 48
**------------------------------------------------------------------------------------------------------
*
* XDEF
*	_compandset2(): routine to emulate cas2()
*		(internal to package)
*
*	_isp_cas2_finish(): store ccodes, store compare regs
*		    (external to package)
*
* XREF
*	_real_lock_page() - "callout" to lock op's page from page-outs
*	_cas_terminate2() - access error exit
*	_real_cas2() - "callout" to core cas2 emulation code
*	_real_unlock_page() - "callout" to unlock page
*
* INPUT
* _compandset2():
*	d0 = instruction extension word
*
* _isp_cas2_finish():
*	see cas2 core emulation code
*
* OUTPUT
* _compandset2():
*	see cas2 core emulation code
*
* _isp_cas_finish():
*	None (register file or memroy changed as appropriate)
*
* ALGORITHM
* compandset2():
*	Decode the instruction and fetch the appropriate Update and
* Compare operands. Then call the "callout" _real_lock_page() for each
* memory operand address so that the operating system can keep these
* pages from being paged out. If either _real_lock_page() fails, exit
* through _cas_terminate2(). Don't forget to unlock the 1st locked page
* using _real_unlock_paged() if the 2nd lock-page fails.
* Finally, branch to the core cas2 emulation code by calling the
* "callout" _real_cas2().
*
* _isp_cas2_finish():
*	Re-perform the comparison so we can determine the condition
* codes which were too much trouble to keep around during the locked
* emulation. Then unlock each operands page by calling the "callout"
* _real_unlock_page().
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d3496 2
a3497 4
ADDR1	equ	(EXC_LV+EXC_TEMP+$c)
ADDR2	equ	(EXC_LV+EXC_TEMP+$0)
DC2	equ	(EXC_LV+EXC_TEMP+$a)
DC1	equ	(EXC_LV+EXC_TEMP+$8)
d3499 1
a3499 3
	xdef  	_compandset2
_compandset2:
	DBUG	10,'\n COMPAND SET2 : '
d3501 1
a3501 2
	move.l	d0,(EXC_LV+EXC_TEMP+$4,a6)	* store for possible restart
	move.l	d0,d1		* extension word in d0
d3503 2
a3504 4
	rol.w	#$4,d0
	andi.w	#$f,d0		* extract Rn2
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),a1 * fetch ADDR2
	move.l	a1,(ADDR2,a6)
d3506 10
a3515 1
	move.l	d1,d0
d3517 10
a3526 3
	lsr.w	#$6,d1
	andi.w	#$7,d1		* extract Du2
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d5 * fetch Update2 Op
d3528 7
a3534 3
	andi.w	#$7,d0		* extract Dc2
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),d3 * fetch Compare2 Op
	move.w	d0,(DC2,a6)
d3536 6
a3541 2
	move.w	(EXC_LV+EXC_EXTWORD,a6),d0
	move.l	d0,d1
d3543 7
a3549 4
	rol.w	#$4,d0
	andi.w	#$f,d0		* extract Rn1
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),a0 * fetch ADDR1
	move.l	a0,(ADDR1,a6)
d3551 6
a3556 1
	move.l	d1,d0
d3558 10
a3567 3
	lsr.w	#$6,d1
	andi.w	#$7,d1		* extract Du1
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d4 * fetch Update1 Op
d3569 2
a3570 3
	andi.w	#$7,d0		* extract Dc1
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4),d2 * fetch Compare1 Op
	move.w	d0,(DC1,a6)
d3572 9
a3580 2
	btst	#$1,(EXC_LV+EXC_OPWORD,a6)	* word or long?
	sne	d7
d3582 10
a3591 2
	btst	#$5,(SFF0_ISR,a6)		* user or supervisor?
	sne	d6
d3593 7
a3599 5
	*move.l	a0,a2
	*move.l	a1,a3
	*move.l	d6,d0		* pass mode
	*bsr.l	_real_lock_page		* lock page
	*CLR.L	D0
d3601 7
a3607 9
	*move.l	a2,a0
	*tst.l	d0		* error?
	*bne.l	_cas_terminate2		* yes

	*move.l	d7,d1		* pass size
	*move.l	d6,d0		* pass mode
	*move.l	a3,a0		* pass addr
	*bsr.l	_real_lock_page		* lock page
	CLR.L	D0
d3609 7
a3615 3
	*move.l	a3,a0
	*tst.l	d0		* error?
	*bne.b	cas_preterm		* yes
d3617 7
a3623 2
	*move.l	a2,a0
	*move.l	a3,a1
d3625 7
a3631 1
	bra.l	_isp_cas2		* _real_cas2
d3633 7
a3639 2
	* if the 2nd lock attempt fails, then we must still unlock the
	* first page(s).
d3641 8
a3648 11
*cas_preterm:
*	move.l	d0,-(sp)		* save FSLW
*	move.l	d7,d1		* pass size
*	move.l	d6,d0		* pass mode
*	move.l	a2,a0		* pass ADDR1
*	*bsr.l	_real_unlock_page		* unlock first page(s)
*	*CLR.L	D0

*	move.l	(sp)+,d0		* restore FSLW
*	move.l	a3,a0		* pass failing addr
*	bra.l	_cas_terminate2
d3650 1
a3652 50
* XDEF
*	_isp_cas2(): "core" emulation code for the cas2 instruction
*
* XREF
*	_isp_cas2_finish() - only exit point for this emulation code;
*		     do clean-up; calculate ccodes; store
*		     Compare Ops if appropriate.
*
* INPUT
*	*see chart below*
*
* OUTPUT
*	*see chart below*
*
* ALGORITHM
*	(1) Make several copies of the effective address.
*	(2) Save current SR; Then mask off all maskable interrupts.
*	(3) Save current SFC/DFC (ASSUMED TO BE EQUAL!!!); Then set
*	    according to whether exception occurred in user or
*	    supervisor mode.
*	(4) Use "plpaw" instruction to pre-load ATC with effective
*	    address pages(s). THIS SHOULD NOT FAULT!!! The relevant
*	    page(s) should have already been made resident prior to
* 	    entering this routine.
*	(5) Push the operand lines from the cache w/ "cpushl".
*	    In the 68040, this was done within the locked region. In
* 	    the 68060, it is done outside of the locked region.
*	(6) Use "plpar" instruction to do a re-load of ATC entries for
*	    ADDR1 since ADDR2 entries may have pushed ADDR1 out of the
*	    ATC.
*	(7) Pre-fetch the core emulation instructions by executing
*	    one branch within each physical line (16 bytes) of the code
*	    before actually executing the code.
*	(8) Load the BUSCR w/ the bus lock value.
*	(9) Fetch the source operands using "moves".
*	(10)Do the compares. If both equal, go to step (13).
*	(11)Unequal. No update occurs. But, we do write the DST1 op
*	    back to itself (as w/ the '040) so we can gracefully unlock
*	    the bus (and assert LOCKE*) using BUSCR and the final move.
*	(12)Exit.
*	(13)Write update operand to the DST locations. Use BUSCR to
*	    assert LOCKE* for the final write operation.
*	(14)Exit.
*
* The algorithm is actually implemented slightly differently
* depending on the size of the operation and the misalignment of the
* operands. A misaligned operand must be written in aligned chunks or
* else the BUSCR register control gets confused.
*
**------------------------------------------------------------------------------------------------------
d3655 1
a3655 42
	************************************************************
	* THIS IS THE STATE OF THE INTEGER REGISTER FILE UPON
	* ENTERING _isp_cas2().
	*
	* D0 = xxxxxxxx
	* D1 = xxxxxxxx
	* D2 = cmp operand 1
	* D3 = cmp operand 2
	* D4 = update oper 1
	* D5 = update oper 2
	* D6 = 'xxxxxxff if supervisor mode; 'xxxxxx00 if user mode
	* D7 = 'xxxxxxff if longword operation; 'xxxxxx00 if word
	* A0 = ADDR1
	* A1 = ADDR2
	* A2 = xxxxxxxx
	* A3 = xxxxxxxx
	* A4 = xxxxxxxx
	* A5 = xxxxxxxx
	* A6 = frame pointer
	* A7 = stack pointer
	************************************************************

	xdef  	_isp_cas2
_isp_cas2:
	DBUG	10,'\n cas2_core'
	tst.b	d6	* user or supervisor mode?
	bne.b	cas2_supervisor	* supervisor
cas2_user:
	moveq.l	#$1,d0	* load user data fc
	bra.b	cas2_cont
cas2_supervisor:
	moveq.l	#$5,d0	* load supervisor data fc
cas2_cont:
	tst.b	d7	* word or longword?
	beq.w	cas2w	* word

	**--------------------------------------------------------------
	**--------------------------------------------------------------

cas2l:
	DBUG	10,' LONG'

a3657 1

d3661 2
a3662 3
	addq.l	#$3,a4	* ADDR1+3
	addq.l	#$3,a5	* ADDR2+3

d3665 1
a3665 1
	* mask interrupts levels 0-6. save old mask value.
d3676 1
a3676 1
	* pre-load the operand ATC. no page faults should occur here because
d3680 1
a3680 1
	plpaw	(a4)	* load atc for ADDR1+3
d3682 1
a3682 1
	plpaw	(a5)	* load atc for ADDR2+3
d3684 1
a3684 1
	* push the operand lines from the cache if they exist.
d3687 1
a3687 1
	cpushl	dc,(a4)	* push line for ADDR1+3
d3689 1
a3689 1
	cpushl	dc,(a5)	* push line for ADDR2+2
d3709 1
a3709 1
	* there are three possible mis-aligned cases for longword cas. they
a3712 1
	DBUG	10,'long aligned'
d3714 3
a3716 28
	andi.b	#$3,d0
	beq.b	CAS2L_ENTER	* no

	DBUG	10,'word aligned'
	cmp.b	#$2,d0
	beq.w	CAS2L2_ENTER	* yes; word misaligned

	DBUG	10,'byte aligned'
	bra.w	CAS2L3_ENTER	* yes; byte misaligned

	**---------------------------------------------------------
	**---------------------------------------------------------
	*
	* D0 = dst operand 1 <-
	* D1 = dst operand 2 <-
	* D2 = cmp operand 1
	* D3 = cmp operand 2
	* D4 = update oper 1
	* D5 = update oper 2
	* D6 = old SFC/DFC
	* D7 = old SR
	* A0 = ADDR1
	* A1 = ADDR2
	* A2 = bus LOCK*  value
	* A3 = bus LOCKE* value
	* A4 = bus unlock value
	* A5 = xxxxxxxx
	*
d3718 17
d3737 1
a3737 1
CAS2L_START:
d3739 5
a3743 4
	moves.l	(a1),d1	* fetch Dest2[31:0]
	moves.l	(a0),d0	* fetch Dest1[31:0]
	bra.b 	CAS2L_CONT
CAS2L_ENTER: 	bra.b	*+14
d3745 10
a3754 10
CAS2L_CONT:
	*cmp.l	 d0,d2	* Dest1 - Compare1
	cmp.l	 d2,d0	* Dest1 - Compare1
	bne.b	CAS2L_NOUPDATE
	*cmp.l	 d1,d3	* Dest2 - Compare2
	cmp.l	 d3,d1	* Dest2 - Compare2
	bne.b	CAS2L_NOUPDATE
	moves.l	d5,(a1)	* Update2[31:0] -> DEST2
	bra.b 	CAS2L_UPDATE
	bra.b	*+14
d3756 1
a3756 1
CAS2L_UPDATE:
d3758 1
a3758 1
	moves.l	d4,(a0)	* Update1[31:0] -> DEST1
d3760 2
a3761 2
	bra.b	cas2l_update_done
	bra.b	*+14
d3763 1
a3763 1
CAS2L_NOUPDATE:
d3765 1
a3765 1
	moves.l	d0,(a0)	* Dest1[31:0] -> DEST1
d3767 2
a3768 2
	bra.b	cas2l_noupdate_done
	bra.b	*+14
d3770 1
a3770 1
CAS2L_FILLER:	nop
d3777 4
a3780 1
	bra.b	CAS2L_START
d3782 1
a3783 3
	**------------------------------------------------------------------------------
	**------------------------------------------------------------------------------
	opt !
d3788 4
a3791 4
	* D0 = destination[31:0] operand 1		*
	* D1 = destination[31:0] operand 2		*
	* D2 = cmp[31:0] operand 1			*
	* D3 = cmp[31:0] operand 2			*
d3806 15
a3820 6
cas2l_noupdate_done:
	move.b	#0,d4		* indicate update was done
          	bra	cas2l_end
cas2l_update_done:
	move.b	#-1,d4
cas2l_end:
d3830 1
d3833 1
a3833 1
	**---------------------------------------------
d3837 1
a3837 1
CAS2L2_START:
d3839 5
a3843 5
	moves.l	(a1),d1		* fetch Dest2[31:0]
	moves.l	(a0),d0		* fetch Dest1[31:0]
	bra.b 	CAS2L2_CONT
CAS2L2_ENTER:
	bra.b	*+14
d3845 10
a3854 10
CAS2L2_CONT:
	*cmp.l	 d0,d2		* Dest1 - Compare1
	cmp.l	 d2,d0		* Dest1 - Compare1
	bne.b	CAS2L2_NOUPDATE
	*cmp.l	 d1,d3		* Dest2 - Compare2
	cmp.l	 d3,d1		* Dest2 - Compare2
	bne.b	CAS2L2_NOUPDATE
	moves.l	d5,(a1)		* Update2[31:0] -> Dest2
	bra.b 	CAS2L2_UPDATE
	bra.b	*+14
d3856 3
a3858 3
CAS2L2_UPDATE:
	swap	d4		* get Update1[31:16]
	moves.w	d4,(a0)+		* Update1[31:16] -> DEST1
d3860 3
a3862 3
	swap	d4		* get Update1[15:0]
	bra.b	CAS2L2_UPDATE2
	bra.b	*+14
d3864 2
a3865 2
CAS2L2_UPDATE2:
	moves.w	d4,(a0)		* Update1[15:0] -> DEST1+$2
d3867 1
a3867 1
	bra.w	cas2l_update_done
d3869 1
a3869 1
	bra.b	*+14
d3871 3
a3873 3
CAS2L2_NOUPDATE:
	swap	d0		* get Dest1[31:16]
	moves.w	d0,(a0)+		* Dest1[31:16] -> DEST1
d3875 3
a3877 3
	swap	d0		* get Dest1[15:0]
	bra.b	CAS2L2_NOUPDATE2
	bra.b	*+14
d3879 2
a3880 2
CAS2L2_NOUPDATE2:
	moves.w	d0,(a0)		* Dest1[15:0] -> DEST1+$2
d3882 1
a3882 1
	bra.w	cas2l_noupdate_done
d3884 1
a3884 1
	bra.b	*+14
d3886 1
a3886 1
CAS2L2_FILLER:
d3894 140
a4033 1
	bra.b	CAS2L2_START
a4034 2
	**------------------------------------------------------------------------------
	**------------------------------------------------------------------------------
d4036 19
a4054 7
	cnop 	0,$10
CAS2L3_START:
	movec	a2,buscr	* assert LOCK*
	moves.l	(a1),d1	* fetch Dest2[31:0]
	moves.l	(a0),d0	* fetch Dest1[31:0]
	bra.b 	CAS2L3_CONT
CAS2L3_ENTER:	bra.b	*+14
d4056 9
a4064 10
CAS2L3_CONT:
	*cmp.l	 d0,d2	* Dest1 - Compare1
	cmp.l	 d2,d0	* Dest1 - Compare1
	bne.b	CAS2L3_NOUPDATE
	*cmp.l	 d1,d3	* Dest2 - Compare2
	cmp.l	 d3,d1	* Dest2 - Compare2
	bne.b	CAS2L3_NOUPDATE
	moves.l	d5,(a1)	* Update2[31:0] -> DEST2
	bra.b 	CAS2L3_UPDATE
	bra.b	*+14
d4066 4
a4069 7
CAS2L3_UPDATE:
	rol.l	#$8,d4	* get Update1[31:24]
	moves.b	d4,(a0)+	* Update1[31:24] -> DEST1
	swap	d4	* get Update1[23:8]
	moves.w	d4,(a0)+	* Update1[23:8] -> DEST1+$1
	bra.b	CAS2L3_UPDATE2
	bra.b	*+14
d4071 4
a4074 5
CAS2L3_UPDATE2:
	rol.l	#$8,d4	* get Update1[7:0]
	movec	a3,buscr	* assert LOCKE*
	moves.b	d4,(a0)	* Update1[7:0] -> DEST1+$3
	bra.b	CAS2L3_UPDATE3
a4075 5
	bra.b	*+14

CAS2L3_UPDATE3:
	movec	a4,buscr	* unlock the bus
	bra.w	cas2l_update_done
d4079 1
a4079 1
	bra.b	*+14
d4081 7
a4087 7
CAS2L3_NOUPDATE:
	rol.l	#$8,d0	* get Dest1[31:24]
	moves.b	d0,(a0)+	* Dest1[31:24] -> DEST1
	swap	d0	* get Dest1[23:8]
	moves.w	d0,(a0)+	* Dest1[23:8] -> DEST1+$1
	bra.b	CAS2L3_NOUPDATE2
	bra.b	*+14
d4089 5
a4093 5
CAS2L3_NOUPDATE2:
	rol.l	#$8,d0	* get Dest1[7:0]
	movec	a3,buscr	* assert LOCKE*
	moves.b	d0,(a0)	* Update1[7:0] -> DEST1+$3
	bra.b	CAS2L3_NOUPDATE3
d4095 1
a4095 1
	bra.b	*+14
d4097 1
a4097 4
CAS2L3_NOUPDATE3:
	movec	a4,buscr	* unlock the bus
	bra.w	cas2l_noupdate_done
	nop
a4099 3
	bra.b	*+(14-2)

CAS2L3_FILLER:
d4105 2
a4106 2
	nop
	bra.w	CAS2L3_START
d4109 49
a4157 2
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
a4158 2
cas2w:
	DBUG            10,' cas2w '
d4160 4
a4163 4
	move.l	a0,a2	* copy ADDR1
	move.l	a1,a3	* copy ADDR2
	move.l	a0,a4	* copy ADDR1
	move.l	a1,a5	* copy ADDR2
d4165 2
a4166 3
	addq.l	#$1,a4	* ADDR1+1
	addq.l	#$1,a5	* ADDR2+1
	move.l	a2,d1	* ADDR1
d4168 3
a4170 1
	* mask interrupt levels 0-6. save old mask value.
d4172 3
a4174 2
	move.w	sr,d7	* save current SR
	ori.w	#$0700,sr	* inhibit interrupts
d4176 2
a4177 1
	* load the SFC and DFC with the appropriate mode.
d4179 1
a4179 3
	movec	sfc,d6	* save old SFC/DFC
	movec	d0,sfc	* store new SFC
	movec	d0,dfc	* store new DFC
d4181 2
a4182 2
	* pre-load the operand ATC. no page faults should occur because
	* _real_lock_page() should have taken care of this.
d4184 1
a4184 4
	plpaw	(a2)	* load atc for ADDR1
	plpaw	(a4)	* load atc for ADDR1+1
	plpaw	(a3)	* load atc for ADDR2
	plpaw	(a5)	* load atc for ADDR2+1
d4186 3
a4188 1
	* push the operand cache lines from the cache if they exist.
d4190 2
a4191 4
	cpushl	dc,(a2)	* push line for ADDR1
	cpushl	dc,(a4)	* push line for ADDR1+1
	cpushl	dc,(a3)	* push line for ADDR2
	cpushl	dc,(a5)	* push line for ADDR2+1
d4193 2
a4194 3
	move.l	d1,a2	* ADDR1
	addq.l	#$3,d1
	move.l	d1,a4	* ADDR1+3
d4196 1
a4196 4
	* if ADDR1 was ATC resident before the above "plpaw" and was executed
	* and it was the next entry scheduled for replacement and ADDR2
	* shares the same set, then the "plpaw" for ADDR2 can push the ADDR1
	* entries from the ATC. so, we do a second set of "plpa"s.
d4198 2
a4199 2
	plpar	(a2)	* load atc for ADDR1
	plpar	(a4)	* load atc for ADDR1+3
d4203 3
a4205 3
	move.l	#$80000000,a2	* assert LOCK* buscr value
	move.l	#$a0000000,a3	* assert LOCKE* buscr value
	move.l	#$00000000,a4	* buscr unlock value
d4207 1
a4207 3
	* there are two possible mis-aligned cases for word cas. they
	* are separated because the final write which asserts LOCKE* must
	* be aligned.
d4209 2
a4210 6
	move.l	a0,d0	* is ADDR1 misaligned?
	btst	#$0,d0
	bne.w	CAS2W2_ENTER	* yes
	bra.b	CAS2W_ENTER	* no

	**--------------------------------------------------------------------------------
d4212 6
a4217 6
	* D0 = dst operand 1 <-
	* D1 = dst operand 2 <-
	* D2 = cmp operand 1
	* D3 = cmp operand 2
	* D4 = update oper 1
	* D5 = update oper 2
d4220 5
a4224 5
	* A0 = ADDR1
	* A1 = ADDR2
	* A2 = bus LOCK*  value
	* A3 = bus LOCKE* value
	* A4 = bus unlock value
d4228 17
a4244 8
	cnop 	0,$10
CAS2W_START:
	movec	a2,buscr	* assert LOCK*
	moves.w	(a1),d1	* fetch Dest2[15:0]
	moves.w	(a0),d0	* fetch Dest1[15:0]
	bra.b 	CAS2W_CONT2
CAS2W_ENTER:
	bra.b	*+14
d4246 8
a4253 10
CAS2W_CONT2:
	cmp.w	 d0,d2	* Dest1 - Compare1
	*cmp.w	 d2,d0	* Dest1 - Compare1
	bne.b	CAS2W_NOUPDATE
	cmp.w	 d1,d3	* Dest2 - Compare2
	*cmp.w	 d3,d1	* Dest2 - Compare2
	bne.b	CAS2W_NOUPDATE
	moves.w	d5,(a1)	* Update2[15:0] -> DEST2
	bra.b 	CAS2W_UPDATE
	bra.b	*+14
d4255 7
a4261 6
CAS2W_UPDATE:
	movec	a3,buscr	* assert LOCKE*
	moves.w	d4,(a0)	* Update1[15:0] -> DEST1
	movec	a4,buscr	* unlock the bus
	bra.b	cas2w_update_done
	bra.b	*+14
d4263 7
a4269 6
CAS2W_NOUPDATE:
	movec	a3,buscr	* assert LOCKE*
	moves.w	d0,(a0)	* Dest1[15:0] -> DEST1
	movec	a4,buscr	* unlock the bus
	bra.b	cas2w_noupdate_done
	bra.b	*+14
d4271 1
a4271 1
CAS2W_FILLER:
d4279 1
a4279 1
	bra.b	CAS2W_START
d4283 21
a4303 3
cas2w_noupdate_done:
	move.b	#0,d4		* indicate no update was done
	bra	cas2w_end
d4305 1
a4305 4
cas2w_update_done:
	move.b	#-1,d4		* indicate update was done

cas2w_end:
d4308 2
a4309 2
	movec	d6,sfc		* restore old SFC
	movec	d6,dfc		* restore old DFC
d4313 1
a4313 1
	move.w	d7,sr		* restore old SR
d4315 3
a4317 1
	bra.l	_isp_cas2_finish
d4319 2
a4320 1
	****-------------------------------------------------------------
d4322 2
a4323 9
	opt 0
	cnop 	0,$10
CAS2W2_START:
	movec	a2,buscr		* assert LOCK*
	moves.w	(a1),d1		* fetch Dest2[15:0]
	moves.w	(a0),d0		* fetch Dest1[15:0]
	bra.b 	CAS2W2_CONT2
CAS2W2_ENTER:
	bra.b	*+14
d4325 1
a4325 10
CAS2W2_CONT2:
	*cmp.w	d0,d2	* Dest1 - Compare1
	cmp.w	d2,d0	* Dest1 - Compare1
	bne.b	CAS2W2_NOUPDATE
	*cmp.w	d1,d3	* Dest2 - Compare2
	cmp.w	d3,d1	* Dest2 - Compare2
	bne.b	CAS2W2_NOUPDATE
	moves.w	d5,(a1)		* Update2[15:0] -> DEST2
	bra.b 	CAS2W2_UPDATE
	bra.b	*+14
d4327 1
a4327 7
CAS2W2_UPDATE:
	ror.l	#$8,d4		* get Update1[15:8]
	moves.b	d4,(a0)+		* Update1[15:8] -> DEST1
	movec	a3,buscr		* assert LOCKE*
	rol.l	#$8,d4		* get Update1[7:0]
	bra.b	CAS2W2_UPDATE2
	bra.b	*+14
d4329 3
a4331 6
CAS2W2_UPDATE2:
	moves.b	d4,(a0)		* Update1[7:0] -> DEST1+$1
	movec	a4,buscr		* unlock the bus
	bra.w	cas2w_update_done
	nop
	bra.b	*+14
d4333 4
a4336 7
CAS2W2_NOUPDATE:
	ror.l	#$8,d0		* get Dest1[15:8]
	moves.b	d0,(a0)+		* Dest1[15:8] -> DEST1
	movec	a3,buscr		* assert LOCKE*
	rol.l	#$8,d0		* get Dest1[7:0]
	bra.b	CAS2W2_NOUPDATE2
	bra.b	*+14
d4338 2
a4339 6
CAS2W2_NOUPDATE2:
	moves.b	d0,(a0)		* Dest1[7:0] -> DEST1+$1
	movec	a4,buscr		* unlock the bus
	bra.w	cas2w_noupdate_done
	nop
	bra.b	*+14
d4341 1
a4341 10
CAS2W2_FILLER:
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	bra.b	CAS2W2_START
	opt !
d4343 2
a4344 2
**----------------------------------------------------------------------------------------------------
**----------------------------------------------------------------------------------------------------
d4346 1
a4346 3
	xdef  	_isp_cas2_finish
_isp_cas2_finish:
	DBUG	10,"cas2_finish"
d4348 3
a4350 2
	btst	#$1,(EXC_LV+EXC_OPWORD,a6)
	bne.b	cas2_finish_l
d4352 2
a4353 7
	move.w	(EXC_LV+EXC_CC,a6),ccr		* load old ccodes
	*cmp.w	d0,d2
	cmp.w	d2,d0
	bne.b	cas2_finish_w_save
	*cmp.w	d1,d3
	cmp.w	d3,d1
cas2_finish_w_save:     move.w	ccr,(EXC_LV+EXC_CC,a6)		* save new ccodes
d4355 2
a4356 2
	tst.b	d4		* update compare reg?
	bne.b	cas2_finish_w_done		* no
d4358 1
a4358 2
	move.w	(DC2,a6),d3		* fetch Dc2
	move.w	d1,(2+EXC_LV+EXC_DREGS,a6,d3.w*4) * store new Compare2 Op
d4360 2
a4361 2
	move.w	(DC1,a6),d2		* fetch Dc1
	move.w	d0,(2+EXC_LV+EXC_DREGS,a6,d2.w*4) * store new Compare1 Op
d4363 1
a4363 3
cas2_finish_w_done:
	btst	#$5,(SFF0_ISR,a6)
	sne	d2
d4365 3
a4367 5
	*move.l	d2,d0		* pass mode
	*sf	d1		* pass size
	*move.l	(ADDR1,a6),a0		* pass ADDR1
	*bsr.l	_real_unlock_page		* unlock page
	*CLR.L	D0
d4369 2
a4370 5
	*move.l	d2,d0		* pass mode
	*sf	d1		* pass size
	*move.l	(ADDR2,a6),a0		* pass ADDR2
	*bsr.l	_real_unlock_page		* unlock page
	CLR.L	D0
d4372 1
a4372 1
	rts
d4374 31
a4404 8
cas2_finish_l:
	move.w	(EXC_LV+EXC_CC,a6),ccr		* load old ccodes
	*cmp.l	d0,d2
	cmp.l	d2,d0
	bne.b	cas2_finish_l_save
	*cmp.l	d1,d3
	cmp.l	d3,d1
cas2_finish_l_save:	move.w	ccr,(EXC_LV+EXC_CC,a6)		* save new ccodes
d4406 6
a4411 2
	tst.b	d4		* update compare reg?
	bne.b	cas2_finish_l_done		* no
d4413 6
a4418 2
	move.w	(DC2,a6),d3		* fetch Dc2
	move.l	d1,(EXC_LV+EXC_DREGS,a6,d3.w*4) * store new Compare2 Op
d4420 7
a4426 2
	move.w	(DC1,a6),d2		* fetch Dc1
	move.l	d0,(EXC_LV+EXC_DREGS,a6,d2.w*4) * store new Compare1 Op
d4428 7
a4434 8
cas2_finish_l_done:
	*btst	#$5,(SFF0_ISR,a6)
	*sne	d2
	*move.l	d2,d0		* pass mode
	*st	d1		* pass size
	*move.l	(ADDR1,a6),a0		* pass ADDR1
	*bsr.l	_real_unlock_page		* unlock page
	*CLR.L	D0
d4436 7
a4442 6
	*move.l	d2,d0		* pass mode
	*st	d1		* pass size
	*move.l	(ADDR2,a6),a0		* pass ADDR2
	*bsr.l	_real_unlock_page		* unlock page
	CLR.L	D0
	rts
d4444 9
a4452 1
**------------------------------------------------------------------------------------------------------
d4454 1
a4454 4
	xdef  	cr_cas2
cr_cas2:
	move.l	(EXC_LV+EXC_TEMP+$4,a6),d0
	bra.w	_compandset2
d4456 2
d4459 4
@


1.0.1.9
log
@Commented out unneeded lines upto 1563
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.8 1997/03/27 14:18:03 schlote beta schlote $
d15 1
a16 2

	incdir	include:
a21 3

**------------------------------------------------------------------------------------------------------

a22 2
MYDEBUG	SET         	0	; Current Debug Level
DEBUG_DETAIL 	set 	10	; Detail Level
d24 2
a25 3
TESTCODE	equ	1	; Add Test Code ?

**------------------------------------------------------------------------------------------------------
d29 2
d33 2
a38 3
**------------------------------------------------------------------------------------------------------

	IFD	TESTCODE	; Some stupid test code
a44 1
                        ENDC
d58 2
a59 2
ISP060_Name:	dc.b	'MC060 Patch',0			; name
ISP060_Info:	dc.b	'MC68060 AmigaISP 43.1 (27.02.96)'   	; give some info
d61 1
a61 1
	dc.b	' Coenobium Developments\r\n',0
d153 1
a153 1
	** CAUTION : Access EXC_ data with negative Offsets EXC_LV+EXC_#?
d159 1
a159 1
	DBUG	15,'\n\nTRAP#61 :'
d233 2
a234 2
	btst	#30,d0			* group1 or group2
	beq	uieh_group2			* go handle group2
d236 1
a236 1
                        **-----------------------------------------------
d241 2
a242 2
	btst	#22,d0			* test for div64
	bne	uieh_div64			* go handle div64
d244 2
a245 2
                        **-----------------------------------------------
uieh_mul64:	* mul64() may use ()+ addressing and may, therefore, alter a7
d247 1
a247 1
	bsr	_mul64			* _mul64()
d259 2
a260 2
                        **-----------------------------------------------
uieh_div64:	* div64() may use ()+ addressing and may, therefore, alter a7.
d263 1
a263 1
	bsr	_div64			* _div64()
d283 1
a289 1
                        **-----------------------------------------------
d298 2
a299 1
	bsr	_moveperipheral		* _movep()
d302 2
a303 2
                        **-----------------------------------------------
uieh_not_movep:	btst	#27,d0		* test for chk2,cmp2
d309 2
d312 1
a312 3

                        **-----------------------------------------------
uieh_cas:	* the cases of "cas Dc,Du,(a7)+" and "cas Dc,Du,-(a7)" used from supervisor
a314 1
	bsr	_compandset		* _cas()
d319 2
d322 3
d326 1
a326 1
	bsr	_compandset2		* _cas2()
a328 1
                        **-----------------------------------------------
d330 3
a334 1
	bsr	_chk2_cmp2		* _chk2_cmp2()
a336 1

d339 1
a339 3
	**--------------------------------------------------------------------------
	** Handler complete
	**--------------------------------------------------------------------------
d345 1
a345 2
                        DBUG	15,'\n(handler_done)'
	move.b	(EXC_LV+EXC_CC+1,a6),(SFF0_ISR+1,a6) 	* insert new ccodes
d348 1
a348 1
	* changed. we don't have to update a7  for supervisor mode because that case
d351 2
a352 2
	btst	#$5,(SFF0_ISR,a6)			* user or supervisor?
	bne.b	uieh_finish			* supervisor
d354 2
a355 2
	move.l	(EXC_LV+EXC_A7,a6),a0			* fetch user stack pointer
	move.l	a0,usp			* restore it
d359 2
a360 2
	btst	#$7,(SFF0_ISR,a6)			* is trace mode on?
	bne.b	uieh_trace			* yes;go handle trace mode
a363 2
	unlk	a6			* unlink stack frame
	rte				* _isp_done
d365 6
a370 3
	**--------------------------------------------------------------------------
	** Exit for traced code
	**--------------------------------------------------------------------------
d397 1
a397 2
uieh_trace:             DBUG	15," (trace_trap)\n"
	move.l	(EXC_LV+EXC_A6,a6),(-$4,a6)
d404 2
a405 1
	rte			*	bra	_real_trace
a406 3
	**--------------------------------------------------------------------------
	** Chk Trap Handler
	**--------------------------------------------------------------------------
d421 1
a428 1
                        DBUG	15," (chk_trap)\n"
a439 1
	* bra	_060_real_trace
a455 1
                        DBUG	15," (traced)\n"
d457 3
a459 1
	RTE                         			* bra	_real_chk
a462 3
	**----------------------------------------------------------------
	** UserMode Div0 Handler
	**----------------------------------------------------------------
d478 1
d496 23
a518 2
	DBUG	10,'(div0_user)'
	bra	uieh_divbyzero_out
a519 3
	**----------------------------------------------------------------
	** SUpervisor Div0 Exit
	**----------------------------------------------------------------
d554 1
a554 24
	DBUG	15," (div0_super)"

	*bra	uieh_divbyzero_out			* Go Std Section
uieh_divbyzero_out:
	TST.B	(SP)
	BPL.B	uieh_divbyzero_end
	*
	*	 DIVBYZERO FRAME	   TRACE FRAME
	*	*****************	*****************
	*	*   Current PC  *	*   Current PC	*
	*	*****************	*****************
	*	* $2 *  $014    *	* $2 *  $024	*
	*	*****************	*****************
	*	*     Next      *	*     Next	*
	*	*      PC       *	*      PC	*
	*	*****************	*****************
	*	*      SR       *	*      SR	*
	*	*****************	*****************
	*
	MOVE.B	#$24,(7,SP)
	DBUG	15," (trace)\n"
uieh_divbyzero_end
	RTE				* bra	_060_real_trace

a555 3
	**----------------------------------------------------------------
	** Supervisor Mode Exit - trace, set a7
	**----------------------------------------------------------------
d592 2
a593 2
	DBUG	15," (super_trace_a7)\n"
	rte				* bra	_real_trace
a595 3
	**----------------------------------------------------------------
	** Supervisor Mode exit - set a7
	**----------------------------------------------------------------
d621 1
a621 2
	DBUG	15," (super_a7)\n"
	rte				* _isp_done
d623 6
a628 20











**-----------------------------------------------------------------------------------------------------
**   These are general exits for ISP Routines with access problems ! - obsolete
**-----------------------------------------------------------------------------------------------------
*
* this is the exit point if a data read or write fails.
* a0 = failing address
* d0 = fslw

isp_dacc:	move.l	a0,(a6)		* save address
d670 3
a672 2
*_real_access:				*bra	_real_access
	DBUG	15," (Access_trap)\n"
d1083 1
a1083 2

	*bsr	_imem_read_word
d1085 1
d1087 2
a1088 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1097 1
a1097 1
	*bsr	_imem_read_word
d1099 1
d1101 2
a1102 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1111 1
a1111 1
	*bsr	_imem_read_word
d1113 1
d1115 2
a1116 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1125 1
a1125 1
	*bsr	_imem_read_word
d1127 1
d1129 2
a1130 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1139 1
a1139 1
	*bsr	_imem_read_word
d1141 1
d1143 2
a1144 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1153 1
a1153 1
	*bsr	_imem_read_word
d1155 1
d1157 2
a1158 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1167 1
a1167 1
	*bsr	_imem_read_word
d1169 1
d1171 2
a1172 3
	*move.l	#0,d1
                        *tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1181 1
a1181 1
	*bsr	_imem_read_word
d1183 1
d1185 2
a1186 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1199 1
a1199 1
	*move.l	d1,-(sp)
d1204 1
a1204 1
	*bsr	_imem_read_word
d1206 4
d1211 1
a1211 4
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
	*move.l	(sp)+,d1
d1223 1
a1223 1
	bra	calc_mem_ind		* calc memory indirect
d1270 1
a1270 1
	*bsr	_imem_read_word		* fetch short address
d1272 1
d1274 2
a1275 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1286 1
a1286 1
	*bsr	_imem_read_long		* fetch long address
d1288 1
d1290 3
a1292 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1303 1
a1303 1
	*bsr	_imem_read_word		* fetch word displacement
d1305 1
d1307 2
a1308 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1311 1
d1319 1
a1319 2
	**----------------------------------------------------------
	**----------------------------------------------------------
d1324 1
a1324 2
	**----------------------------------------------------------
	**----------------------------------------------------------
d1328 1
a1328 1
	*bsr	_imem_read_word		* fetch ext word
d1330 1
d1332 2
a1333 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1349 1
a1349 1
	bra	calc_mem_ind		* calc memory indirect
a1350 1
	**----------------------------------------------------------
a1377 1
	**----------------------------------------------------------
a1407 1

d1414 1
a1414 1
	*bsr	_imem_read_long
d1416 4
a1420 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
a1421 1

d1425 1
a1425 1
	*bsr	_imem_read_word
d1427 1
d1429 2
a1430 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1445 1
a1445 1
	*bsr	_imem_read_long
d1447 1
d1449 2
a1450 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1457 1
a1457 1
	*bsr	_imem_read_word
d1459 1
d1461 2
a1462 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1475 1
a1475 1
	*bsr	_dmem_read_long
d1477 1
d1479 2
a1480 3
	*MOVEQ	#0,D1
	*tst.l	d1		* dfetch error?
	*bne.b	calc_ea_err		* yes
d1489 1
a1489 1
	*bsr	_dmem_read_long
d1491 1
d1493 2
a1494 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.b	calc_ea_err		* yes
d1517 1
a1517 3
	bra	isp_dacc


d1602 1
a1602 1
	*bsr	_dmem_write_byte		* os  : write hi
d1614 1
a1614 1
	*bsr	_dmem_write_byte		* os  : write lo
d1626 1
a1626 1
	*bsr	_dmem_write_byte		* os  : write lo
d1638 1
a1638 1
	*bsr	_dmem_write_byte		* os  : write lo
d1654 1
a1654 1
	*bsr	_dmem_write_byte		* os  : write hi
d1665 1
a1665 1
	*bsr	_dmem_write_byte		* os  : write lo
d1684 1
a1684 1
	*bsr	_dmem_read_byte		* read first byte
d1697 1
a1697 1
	*bsr	_dmem_read_byte		* read second byte
d1711 1
a1711 1
	*bsr	_dmem_read_byte		* read second byte
d1725 1
a1725 1
	*bsr	_dmem_read_byte		* read second byte
d1748 1
a1748 1
	*bsr	_dmem_read_byte		* read first byte
d1761 1
a1761 1
	*bsr	_dmem_read_byte		* read second byte
d1791 1
a1791 1
	bra	isp_dacc
d1801 1
a1801 1
	bra	isp_dacc
d1866 1
a1866 1
	bsr	_calc_ea		* calculate <ea>
d1882 1
a1882 1
	*bsr	_dmem_read_long		* fetch long lower bound
d1892 1
a1892 1
	*bsr	_dmem_read_long		* fetch long upper bound
d1908 1
a1908 1
	*bsr	_dmem_read_long		* fetch 2 word bounds
d1935 1
a1935 1
	*bsr	_dmem_read_word		* fetch 2 byte bounds
d2007 1
a2007 1
	bra	isp_dacc
d2017 1
a2017 1
	bra	isp_dacc
d2172 1
a2172 1
	bsr	dclassical		* do int divide
d2361 1
a2361 1
	bsr	dmm2
d2459 1
a2459 1
	bsr	_calc_ea		* calc <ea>
d2465 1
a2465 1
	*bsr	_dmem_read_long		* fetch divisor from <ea>
d2480 1
a2480 1
	*bsr	_imem_read_long		* read immediate value
d2502 1
a2502 1
	bsr	isp_restore	* restore addr reg
d2505 1
a2505 1
	bra	isp_dacc
d2728 1
a2728 1
	bsr	_calc_ea			* calculate <ea>
d2736 1
a2736 1
	*bsr	_dmem_read_long			* fetch src from addr (a0)
d2752 1
a2752 1
	*bsr	_imem_read_long			* read immediate value
d2774 1
a2774 1
	bsr	isp_restore	* restore addr reg
d2777 1
a2777 1
	bra	isp_dacc
d2911 1
a2911 1
	bsr	_calc_ea		* a0 = calculated <ea>
d2922 1
a2922 1
	bsr	_calc_ea		* a0 = calculated <ea>
d2949 1
a2949 1
	*bsr	_real_lock_page		* lock page
d3202 1
a3202 1
	bra	_isp_cas_finish
d3394 1
a3394 1
	bra	_isp_cas_finish
d3577 1
a3577 1
	*bsr	_real_unlock_page		* unlock page
d3603 1
a3603 1
	*bsr	_real_unlock_page		* unlock page
d3645 1
a3645 1
	bsr	isp_restore		* restore An (if ()+ or -())
d3663 1
a3663 1
	rts			* _real_access @@@@@@@@@@@@@@@@@@@@@@@@@@
d3798 1
a3798 1
	*bsr	_real_lock_page		* lock page
d3808 1
a3808 1
	*bsr	_real_lock_page		* lock page
d3818 1
a3818 1
	bra	_isp_cas2		* _real_cas2
d3828 1
a3828 1
*	*bsr	_real_unlock_page		* unlock first page(s)
d3833 1
a3833 1
*	bra	_cas_terminate2
d4105 1
a4105 1
	bra	_isp_cas2_finish
d4399 1
a4399 1
	bra	_isp_cas2_finish
d4499 1
a4499 1
	*bsr	_real_unlock_page		* unlock page
d4505 1
a4505 1
	*bsr	_real_unlock_page		* unlock page
d4534 1
a4534 1
	*bsr	_real_unlock_page		* unlock page
d4540 1
a4540 1
	*bsr	_real_unlock_page		* unlock page
@


1.0.1.10
log
@Code rearrange and optimized movep and chk
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.9 1997/03/27 16:15:03 schlote Exp schlote $
d704 4
a708 2
	DBUG	15," (Access_trap)\n"
	RTE		:	* bra	_real_access
d745 2
d749 2
a750 2
* XDEF
* 	_moveperipheral(): routine to emulate movep instruction
d752 5
a756 3
* XREF
*	_dmem_read_byte() - read byte from memory
*	_dmem_write_byte() - write byte to memory
d760 1
a760 1
*	none
d764 4
a767 2
*	a0 = failing address
*	d0 = FSLW
d769 1
a769 1
*	none
d771 1
a771 1
* ALGORITHM
d773 4
a776 4
* Decode  the  movep  instruction  words  stored  at (EXC_LV+EXC_OPWORD and either read or write the
* required  bytes from/to memory.  Use the _dmem_{read,write}_byte() routines.  If one of the memory
* routines  returns  a failing value, we must pass the failing address and a FSLW to the _isp_dacc()
* routine.
d778 20
a797 2
* Since this instruction is used to access peripherals, make sure
* to only access the required bytes.
a801 7
	***************************
	* movep.(w,l)	Dx,(d,Ay) *
	* movep.(w,l)	(d,Ay),Dx *
	***************************
	xdef   	_moveperipheral
_moveperipheral:        
	DBUG	20,' -.MOVEP'
d803 6
a808 1
	move.w	(EXC_LV+EXC_OPWORD,a6),d1	* fetch the opcode word
d810 2
a811 2
	move.b	d1,d0
	and.w	#$7,d0		* extract Ay from opcode word
d813 2
a814 1
	move.l	(EXC_LV+EXC_AREGS,a6,d0.w*4),a0 * fetch ay
d816 1
a816 1
	add.w	(EXC_LV+EXC_EXTWORD,a6),a0	* add: an + sgn_ext(disp)
d818 14
a831 2
	btst	#$7,d1		* (reg 2 mem) or (mem 2 reg)
	beq.w	mem2reg
d833 8
a840 5
	* reg2mem: fetch dx, then write it to memory
reg2mem:
	move.w	d1,d0
	rol.w	#$7,d0
	and.w	#$7,d0		* extract Dx from opcode word
d842 8
a849 1
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4), d0 * fetch dx
d851 8
a858 2
	btst	#$6,d1		* word or long operation?
	beq.b	r2mwtrans
d860 8
a867 13
	**----------------------------------------------*
	* a0 = dst addr
	* d0 = Dx
r2mltrans:
	rol.l	#$8,d0
	MOVE.B	D0,(A0)                	* os  : write hi
	rol.l	#$8,d0
	MOVE.B	D0,2(A0)                       * os  : write lo
	rol.l	#$8,d0
	MOVE.B	D0,4(A0)                       * os  : write lo
	rol.l	#$8,d0
	MOVE.B	D0,6(A0)                       * os  : write lo
	rts
d869 8
a876 9
	**----------------------------------------------*
	* a0 = dst addr
	* d0 = Dx
r2mwtrans:
	move.l	d0,d2		* store data
	lsr.w	#$8,d0		* data hi
	MOVE.B	D0,(A0)
	MOVE.B	D2,2(A0)
	rts
d878 8
a885 6
	**----------------------------------------------*
	* mem2reg: read bytes from memory.
	* determines the dest register, and then writes the bytes into it.
mem2reg:
	btst	#$6,d1		* word or long operation?
	beq.b	m2rwtrans
d887 8
a894 3
	* a0 = dst addr
m2rltrans:
	*move.l	a0,a2		* store addr
d896 6
a901 2
	CLR.L	d2		* Read value !
	MOVE.B	(A0),d2                        * incr addr by 2 bytes
d903 3
a905 2
	lsl.l	#$8,d2
	MOVE.B	2(A0),d2		* append bytes
d907 3
a909 2
	lsl.l	#$8,d2
	MOVE.B	4(A0),d2		* append bytes
d911 3
a913 2
	lsl.l	#$8,d2
	MOVE.B	6(A0),d2		* append bytes
d915 3
a917 4
	move.b	(EXC_LV+EXC_OPWORD,a6),d1
	lsr.b	#$1,d1
	and.w	#$7,d1		 * extract Dx from opcode word
	move.l	d2,(EXC_LV+EXC_DREGS,a6,d1.w*4) * store dx
d919 2
d923 3
a925 3
	* a0 = dst addr
m2rwtrans:
	move.l	a0,a2		* store addr
d927 3
a929 4
	CLR.L	d2
	MOVE.B	(A0),d2
	lsl.l	#8,d2
	MOVE.B	(A0),d2
d931 8
a938 4
	move.b	(EXC_LV+EXC_OPWORD,a6),d1
	lsr.b	#$1,d1
	and.w	#$7,d1		* extract Dx from opcode word
	move.w	d2,(EXC_LV+EXC_DREGS+2,a6,d1.w*4) * store dx
d940 3
d945 5
d951 4
d956 5
d962 4
d967 5
d973 4
d978 5
d984 4
a987 35
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* XDEF
* 	_chk2_cmp2(): routine to emulate chk2/cmp2 instructions
*
* XREF
*	_calc_ea(): calculate effective address
*	_dmem_read_long(): read operands
* 	_dmem_read_word(): read operands
*	isp_dacc(): handle data access error exception
*
* INPUT ***************************************************************
*	none
*
* OUTPUT **************************************************************
*	If exiting through isp_dacc...
*	a0 = failing address
*	d0 = FSLW
*	else
* 	none
*
* ALGORITHM ***********************************************************
*
*  First,  calculate  the  effective address, then fetch the byte, word, or longword sized operands.
* Then,  in  the  interest  of  simplicity,  all operands are converted to longword size whether the
* operation  is  byte,  word,  or  long.  The bounds are sign extended accordingly.  If Rn is a data
* regsiter,  Rn  is  also sign extended.  If Rn is an address register, it need not be sign extended
* since the full register is always used.
*
* The  comparisons  are made and the condition codes calculated.  If the instruction is chk2 and the
* Rn  value is out-of-bounds, set the ichk_flg in (EXC_LV+SPCOND_FLG.  If the memory fetch returns a
* failing value, pass the failing address and FSLW to the isp_dacc() routine.
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d989 5
a993 3
	xdef   	_chk2_cmp2
_chk2_cmp2:
	DBUG	20,'\nCHK2_CMP2: '
d995 4
a998 3
	**---------------------------------------------------------------------------
	* passing size parameter doesn't matter since chk2 # cmp2 can't do
	* either predecrement, postincrement, or immediate.
d1000 5
a1004 1
	bsr	_calc_ea		* calculate <ea>  -> a0
d1006 4
a1009 3
	move.b	(EXC_LV+EXC_EXTWORD,a6), d0	* fetch hi extension word
	rol.b	#$4, d0		* rotate reg bits into lo
	and.w	#$f, d0		* extract reg bits
d1011 2
a1012 1
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4), d2 * get regval
d1014 5
a1018 3
	cmp.b	#$2,(EXC_LV+EXC_OPWORD,a6)	* what size is operation?
	blt.b	chk2_cmp2_byte		* size == byte
	beq.b	chk2_cmp2_word		* size == word
d1020 3
a1022 7
	**---------------------------------------------------------------------------
	* the bounds are longword size. call routine to read the lower
	* bound into d0 and the higher bound into d1.
chk2_cmp2_long:
	MOVE.L	(A0),D0                        * long lower bound in d0
	MOVE.L	4(A0),D1               	* long upper bound in d1
	bra.w	chk2_cmp2_compare		* go do the compare emulation
d1024 6
a1029 10
	**---------------------------------------------------------------------------
	* the bounds are word size. fetch them in one subroutine call by
	* reading a longword. sign extend both. if it's a data operation,
	* sign extend Rn to long, also.
chk2_cmp2_word:
	MOVE.L	(A0),D0                	* fetch 2 word bounds
	move.w	d0, d1		* place hi in d1
	swap	d0		* place lo in d0
	ext.l	d0		* sign extend lo bnd
	ext.l	d1		* sign extend hi bnd
d1031 3
a1033 2
	btst	#$7, (EXC_LV+EXC_EXTWORD,a6)	* address compare?
	bne.w	chk2_cmp2_compare		* yes; don't sign extend
d1035 6
a1040 2
	* operation is a data register compare.
	* sign extend word to long so we can do simple longword compares.
d1042 3
a1044 2
	ext.l	d2		* sign extend data word
	bra.w	chk2_cmp2_compare		* go emulate compare
d1046 6
a1051 10
	**---------------------------------------------------------------------------
	* the bounds are byte size. fetch them in one subroutine call by
	* reading a word. sign extend both. if it's a data operation,
	* sign extend Rn to long, also.
chk2_cmp2_byte:
	MOVE.W	(A0),D0                        * fetch 2 byte bounds
	move.b	d0, d1		* place hi in d1
	lsr.w	#$8, d0		* place lo in d0
	extb.l	d0		* sign extend lo bnd
	extb.l	d1		* sign extend hi bnd
d1053 3
a1055 2
	btst	#$7, (EXC_LV+EXC_EXTWORD,a6)	* address compare?
	bne.b	chk2_cmp2_compare		* yes; don't sign extend
d1057 6
a1062 2
	* operation is a data register compare.
	* sign extend byte to long so we can do simple longword compares.
d1064 3
a1066 1
	extb.l	d2		* sign extend data byte
d1068 6
a1073 14
	**---------------------------------------------------------------------------
	*
	* To set the ccodes correctly:
	* 	(1) save 'Z' bit from (Rn - lo)
	*	(2) save 'Z' and 'N' bits from ((hi - lo) - (Rn - hi))
	*	(3) keep 'X', 'N', and 'V' from before instruction
	*	(4) combine ccodes
	*
chk2_cmp2_compare:
	sub.l	d0, d2		* (Rn - lo)
	move.w	ccr, d3		* fetch resulting ccodes
	andi.b	#$4, d3		* keep 'Z' bit
	sub.l	d0, d1		* (hi - lo)
	cmp.l 	d2,d1	       	* ((hi - lo) - (Rn - hi))
d1075 3
a1077 3
	move.w	ccr, d4		* fetch resulting ccodes
	or.b	d4, d3		* combine w/ earlier ccodes
	andi.b	#$5, d3		* keep 'Z' and 'N'
d1079 6
a1084 4
	move.w	(EXC_LV+EXC_CC,a6), d4		* fetch old ccodes
	andi.b	#$1a, d4		* keep 'X','N','V' bits
	or.b	d3, d4		* insert new ccodes
	move.w	d4, (EXC_LV+EXC_CC,a6)		* save new ccodes
d1086 2
a1087 2
	btst	#$3, (EXC_LV+EXC_EXTWORD,a6)	* separate chk2,cmp2
	bne.b	chk2_finish		* it's a chk2
d1090 6
a1095 4
	**---------------------------------------------------------------------------
	* this code handles the only difference between chk2 and cmp2. chk2 would
	* have trapped out if the value was out of bounds. we check this by seeing
	* if the 'N' bit was set by the operation.
d1097 2
a1098 5
chk2_finish:	btst	#$0, d4		* is 'N' bit set?
	bne.b	chk2_trap		* yes;chk2 should trap
	rts
chk2_trap:
	move.b	#ichk_flg,(EXC_LV+SPCOND_FLG,a6) * set "special case" flag
d1101 2
d1104 5
d1110 3
d1114 3
d1118 2
d1121 3
d1125 3
d1129 5
d1135 3
d1139 3
d1143 5
d1149 3
d1153 3
d1157 5
d1163 3
d1167 59
d1227 137
a1363 54
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* XDEF :
*	_calc_ea(): routine to calculate effective address
*
* XREF :
* 	_imem_read_word() - read instruction word
* 	_imem_read_long() - read instruction longword
* 	_dmem_read_long() - read data longword (for memory indirect)
* 	isp_iacc() - handle instruction access error exception
*	isp_dacc() - handle data access error exception
*
* INPUT
* 	d0 = number of bytes related to effective address (w,l)
*
* OUTPUT
*	If exiting through isp_dacc...
*		a0 = failing address
*		d0 = FSLW
*	elsif exiting though isp_iacc...
*		none
*	else
*		a0 = effective address
*
* ALGORITHM ***********************************************************	*
*
* 	The effective address type is decoded from the opword residing
* 	on the stack. A jump table is used to vector to a routine for the
* 	appropriate mode. Since none of the emulated integer instructions
* 	uses byte-sized operands, only handle word and long operations.
*
* 	Dn,An	- shouldn't enter here
*	(An)	- fetch An value from stack
* 	-(An)	- fetch An value from stack; return decr value;
*		  place decr value on stack; store old value in case of
*		  future access error; if -(a7), set mda7_flg in
*		  (EXC_LV+SPCOND_FLG
*	(An)+	- fetch An value from stack; return value;
*	  	  place incr value on stack; store old value in case of
*	  	  future access error; if (a7)+, set mia7_flg in
*		  (EXC_LV+SPCOND_FLG
*	(d16,An) 	- fetch An value from stack; read d16 using
*	 	  _imem_read_word(); fetch may fail -> branch to  isp_iacc()
*	(xxx).w,(xxx).l 	- use _imem_read_{word,long}() to fetch address; fetch may fail
*	*<data> 	- return address of immediate value; set immed_flg in (EXC_LV+SPCOND_FLG
*	(d16,PC) 	- fetch stacked PC value; read d16 using _imem_read_word();
*		  fetch may fail -> branch to isp_iacc()
*	everything else 	- read needed displacements as appropriate w/
*		  _imem_read_{word,long}(); read may fail; if memory
* 		  indirect, read indirect address using
*		  _dmem_read_long() which may also fail
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
d1365 3
d1369 2
a1370 4
	xdef  	_calc_ea
_calc_ea:
	DBUG	20,'CalcEA %08lx',d0
	move.l	d0,a0		* move * bytes to a0
d1372 2
a1373 1
	* MODE and REG are taken from the (EXC_LV+EXC_OPWORD.
d1375 2
a1376 2
	move.w	(EXC_LV+EXC_OPWORD,a6),d0	* fetch opcode word
	move.w	d0,d1		* make a copy
d1378 1
a1378 2
	andi.w	#$3f,d0		* extract mode field
	andi.l	#$7,d1		* extract reg  field
d1380 2
a1381 1
	* jump to the corresponding function for each {MODE,REG} pair.
d1383 1
a1383 14
	move.w	((tbl_ea_mode).b,pc,d0.w*2),d0 	* fetch jmp distance
	jmp	((tbl_ea_mode).b,pc,d0.w*1) 		* jmp to correct ea mode
tbl_ea_mode_ill:
	illegal                         		* illegal opcode
	dc.w	64
tbl_ea_mode:
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
d1385 3
a1387 8
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	-	tbl_ea_mode
d1389 3
a1391 8
	dc.w	addr_ind_a0	- 	tbl_ea_mode
	dc.w	addr_ind_a1	- 	tbl_ea_mode
	dc.w	addr_ind_a2	- 	tbl_ea_mode
	dc.w	addr_ind_a3 	- 	tbl_ea_mode
	dc.w	addr_ind_a4 	- 	tbl_ea_mode
	dc.w	addr_ind_a5 	- 	tbl_ea_mode
	dc.w	addr_ind_a6 	- 	tbl_ea_mode
	dc.w	addr_ind_a7 	- 	tbl_ea_mode
d1393 1
a1393 8
	dc.w	addr_ind_p_a0	- 	tbl_ea_mode
	dc.w	addr_ind_p_a1 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a2 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a3 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a4 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a5 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a6 	- 	tbl_ea_mode
	dc.w	addr_ind_p_a7 	- 	tbl_ea_mode
d1395 7
a1401 8
	dc.w	addr_ind_m_a0 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a1 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a2 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a3 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a4 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a5 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a6 	- 	tbl_ea_mode
	dc.w	addr_ind_m_a7 	- 	tbl_ea_mode
d1403 1
a1403 8
	dc.w	addr_ind_disp_a0	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a1 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a2 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a3 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a4 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a5 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a6 	- 	tbl_ea_mode
	dc.w	addr_ind_disp_a7	-	tbl_ea_mode
d1405 3
a1407 8
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
	dc.w	_addr_ind_ext 	- 	tbl_ea_mode
d1409 1
a1409 8
	dc.w	abs_short	- 	tbl_ea_mode
	dc.w	abs_long	- 	tbl_ea_mode
	dc.w	pc_ind	- 	tbl_ea_mode
	dc.w	pc_ind_ext	- 	tbl_ea_mode
	dc.w	immediate	- 	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	- 	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	- 	tbl_ea_mode
	dc.w	tbl_ea_mode_ill	- 	tbl_ea_mode
a1410 5
	***********************************
	* Address register indirect: (An) *
	***********************************
addr_ind_a0:
	move.l	(EXC_LV+EXC_A0,a6),a0	* Get current a0
d1413 87
a1499 3
addr_ind_a1:
	move.l	(EXC_LV+EXC_A1,a6),a0	* Get current a1
	rts
d1501 2
a1502 3
addr_ind_a2:
	move.l	(EXC_LV+EXC_A2,a6),a0	* Get current a2
	rts
d1504 6
a1509 3
addr_ind_a3:
	move.l	(EXC_LV+EXC_A3,a6),a0	* Get current a3
	rts
d1511 3
a1513 3
addr_ind_a4:
	move.l	(EXC_LV+EXC_A4,a6),a0	* Get current a4
	rts
d1515 3
a1517 3
addr_ind_a5:
	move.l	(EXC_LV+EXC_A5,a6),a0	* Get current a5
	rts
d1519 3
a1521 3
addr_ind_a6:
	move.l	(EXC_LV+EXC_A6,a6),a0	* Get current a6
	rts
d1523 5
a1527 3
addr_ind_a7:
	move.l	(EXC_LV+EXC_A7,a6),a0	* Get current a7
	rts
d1529 3
a1531 8
	*****************************************************
	* Address register indirect w/ postincrement: (An)+ *
	*****************************************************
addr_ind_p_a0:
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A0,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A0,a6)		* save incremented value
d1533 2
a1534 4
	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$0,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
	rts
d1536 5
a1540 9
addr_ind_p_a1:
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A1,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A1,a6)		* save incremented value

	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$1,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
d1543 12
a1554 5
addr_ind_p_a2:
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A2,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A2,a6)		* save incremented value
a1555 4
	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$2,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
	rts
a1556 5
addr_ind_p_a3:
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A3,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A3,a6)		* save incremented value
a1557 4
	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$3,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
	rts
a1558 5
addr_ind_p_a4:
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A4,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A4,a6)		* save incremented value
a1559 4
	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$4,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
	rts
a1560 5
addr_ind_p_a5:
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A5,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A5,a6)		* save incremented value
a1561 4
	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$5,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
	rts
a1562 5
addr_ind_p_a6:
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A6,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A6,a6)		* save incremented value
a1563 4
	move.l	a0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	move.b	#$6,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
	rts
a1564 2
addr_ind_p_a7:
	move.b	#mia7_flg,(EXC_LV+SPCOND_FLG,a6) * set "special case" flag
a1565 5
	move.l	a0,d0		* copy no. bytes
	move.l	(EXC_LV+EXC_A7,a6),a0		* load current value
	add.l	a0,d0		* increment
	move.l	d0,(EXC_LV+EXC_A7,a6)		* save incremented value
	rts
a1566 3
	****************************************************
	* Address register indirect w/ predecrement: -(An) *
	****************************************************
a1567 6
addr_ind_m_a0:
	move.l	(EXC_LV+EXC_A0,a6),d0		* Get current a0
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A0,a6)		* Save decr value
	move.l	d0,a0
a1568 3
	move.b	#$0,(EXC_LV+EXC_SAVREG,a6)	* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) * set flag
	rts
d1570 32
a1601 6
addr_ind_m_a1:
	move.l	(EXC_LV+EXC_A1,a6),d0		* Get current a1
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A1,a6)		* Save decr value
	move.l	d0,a0
d1603 8
a1610 3
	move.b	#$1,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
	rts
d1612 2
a1613 6
addr_ind_m_a2:
	move.l	(EXC_LV+EXC_A2,a6),d0		* Get current a2
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A2,a6)		* Save decr value
	move.l	d0,a0
d1615 1
a1615 3
	move.b	#$2,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
	rts
d1617 1
a1617 6
addr_ind_m_a3:
	move.l	(EXC_LV+EXC_A3,a6),d0		* Get current a3
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A3,a6)		* Save decr value
	move.l	d0,a0
d1619 2
a1620 3
	move.b	#$3,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
	rts
d1622 5
a1626 6
addr_ind_m_a4:
	move.l	(EXC_LV+EXC_A4,a6),d0		* Get current a4
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A4,a6)		* Save decr value
	move.l	d0,a0
d1628 1
a1628 3
	move.b	#$4,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
	rts
d1630 2
a1631 6
addr_ind_m_a5:
	move.l	(EXC_LV+EXC_A5,a6),d0		* Get current a5
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A5,a6)		* Save decr value
	move.l	d0,a0
d1633 7
a1639 3
	move.b	#$5,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
	rts
d1641 3
a1643 6
addr_ind_m_a6:
	move.l	(EXC_LV+EXC_A6,a6),d0		* Get current a6
	move.l	d0,(EXC_LV+EXC_SAVVAL,a6)	* save in case of access error
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A6,a6)		* Save decr value
	move.l	d0,a0
d1645 2
a1646 3
	move.b	#$6,(EXC_LV+EXC_SAVREG,a6)		* save regno, too
	move.b	#restore_flg,(EXC_LV+SPCOND_FLG,a6) 	* set flag
	rts
d1648 4
a1651 2
addr_ind_m_a7:
	move.b	#mda7_flg,(EXC_LV+SPCOND_FLG,a6) * set "special case" flag
d1653 3
a1655 5
	move.l	(EXC_LV+EXC_A7,a6),d0		* Get current a7
	sub.l	a0,d0		* Decrement
	move.l	d0,(EXC_LV+EXC_A7,a6)		* Save decr value
	move.l	d0,a0
	rts
d1657 2
a1658 3
	********************************************************
	* Address register indirect w/ displacement: (d16, An) *
	********************************************************
d1660 4
a1663 3
addr_ind_disp_a0:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
d1665 3
a1667 2
	*bsr	_imem_read_word
	MOVE.W	(a0),d0
d1669 2
a1670 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1672 4
a1675 3
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A0,a6),a0		* a0 + d16
	rts
d1677 3
a1679 5
addr_ind_disp_a1:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word
	MOVE.W	(a0),d0
d1681 2
a1682 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
a1683 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A1,a6),a0		* a1 + d16
d1686 10
a1695 5
addr_ind_disp_a2:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word
	MOVE.W	(a0),d0
d1697 2
a1698 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1700 3
a1702 3
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A2,a6),a0		* a2 + d16
	rts
d1704 3
a1706 5
addr_ind_disp_a3:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word
	MOVE.W	(a0),d0
d1708 2
a1709 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
a1710 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A3,a6),a0		* a3 + d16
d1713 5
a1717 5
addr_ind_disp_a4:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word
	MOVE.W	(a0),d0
d1719 3
a1721 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1723 4
a1726 3
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A4,a6),a0		* a4 + d16
	rts
d1728 2
a1729 5
addr_ind_disp_a5:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word
	MOVE.W	(a0),d0
d1731 1
a1731 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1733 2
a1734 3
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A5,a6),a0		* a5 + d16
	rts
d1736 18
a1753 5
addr_ind_disp_a6:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word
	MOVE.W	(a0),d0
d1755 2
a1756 3
	*move.l	#0,d1
                        *tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1758 2
a1759 3
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A6,a6),a0		* a6 + d16
	rts
d1761 2
a1762 5
addr_ind_disp_a7:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word
	MOVE.W	(a0),d0
d1764 4
a1767 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1769 2
a1770 3
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_A7,a6),a0		* a7 + d16
	rts
d1772 2
a1773 8
	************************************************************************
	* Address register indirect w/ index(8-bit displacement): (dn, An, Xn) *
	*    "       "         "    w/   "  (base displacement): (bd, An, Xn)  *
	* Memory indirect postindexed: ([bd, An], Xn, od)	       *
	* Memory indirect preindexed: ([bd, An, Xn], od)	       *
	************************************************************************
_addr_ind_ext:
	*move.l	d1,-(sp)
d1775 3
a1777 2
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
d1779 1
a1779 2
	*bsr	_imem_read_word
	MOVE.W	(A0),D0		* fetch extword in d0
d1781 1
a1781 4
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
	*move.l	(sp)+,d1
d1783 3
a1785 1
	move.l	(EXC_LV+EXC_AREGS,a6,d1.w*4),a0 * put base in a0
d1787 4
a1790 2
	btst	#$8,d0
	beq.b	addr_ind_index_8bit		* for ext word or not?
d1792 2
a1793 1
	movem.l	d2-d5,-(sp)		* save d2-d5
d1795 1
a1795 4
	move.l	d0,d5		* put extword in d5
	move.l	a0,d3		* put base in d3

	bra	calc_mem_ind		* calc memory indirect
d1797 2
a1798 2
addr_ind_index_8bit:
	move.l	d2,-(sp)		* save old d2
d1800 4
a1803 3
	move.l	d0,d1
	rol.w	#$4,d1
	andi.w	#$f,d1		* extract index regno
d1805 2
a1806 1
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d1 * fetch index reg value
d1808 2
a1809 7
	btst	#$b,d0		* is it word or long?
	bne.b	aii8_long
	ext.l	d1		* sign extend word index
aii8_long:
	move.l	d0,d2
	rol.w	#$7,d2
	andi.l	#$3,d2		* extract scale value
d1811 3
a1813 1
	lsl.l	d2,d1		* shift index by scale
d1815 1
a1815 3
	extb.l	d0		* sign extend displacement
	add.l	d1,d0		* index + disp
	add.l	d0,a0		* An + (index + disp)
a1816 1
	move.l	(sp)+,d2		* restore old d2
d1819 22
a1840 11
	**********************
	* Immediate: *<data> *
	*************************************************************************
	* word, long: <ea> of the data is the current extension word	*
	* 	pointer value. new extension word pointer is simply the old	*
	* 	plus the number of bytes in the data type(2 or 4).	*
	*************************************************************************
immediate:
	move.b	#immed_flg,(EXC_LV+SPCOND_FLG,a6) * set immediate flag
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch extension word ptr
	rts
a1841 6
	***************************
	* Absolute short: (XXX).W *
	***************************
abs_short:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
a1842 2
	*bsr	_imem_read_word		* fetch short address
	MOVE.W	(A0),D0
a1843 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
a1844 2
	move.w	d0,a0		* return <ea> in a0
	rts
a1845 8
	**************************
	* Absolute long: (XXX).L *
	**************************
abs_long:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_long		* fetch long address
	MOVE.L	(a0),d0
a1846 3
	*move.l	#0,d1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
a1847 2
	move.l	d0,a0		* return <ea> in a0
	rts
a1848 8
	*******************************************************
	* Program counter indirect w/ displacement: (d16, PC) *
	*******************************************************
pc_ind:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word		* fetch word displacement
	MOVE.W	(A0),D0
a1849 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
a1850 2
	move.w	d0,a0		* sign extend displacement
	add.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* pc + d16
a1851 1
	* _imem_read_word() increased the extwptr by 2. need to adjust here.
a1852 2
	subq.l	#$2,a0		* adjust <ea>
	rts
a1853 13
	**----------------------------------------------------------
	**----------------------------------------------------------
	* PC indirect w/ index(8-bit displacement): (d8, PC, An) *
	* "     "     w/   "  (base displacement): (bd, PC, An)  *
	* PC memory indirect postindexed: ([bd, PC], Xn, od)     *
	* PC memory indirect preindexed: ([bd, PC, Xn], od)      *
	**----------------------------------------------------------
	**----------------------------------------------------------
pc_ind_ext:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word		* fetch ext word
	MOVE.W	(A0),D0
a1854 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
a1855 2
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* put base in a0
	subq.l	#$2,a0		* adjust base
a1856 2
	btst	#$8,d0		* is disp only 8 bits?
	beq.b	pc_ind_index_8bit		* yes
a1857 2
	* the indexed addressing mode uses a base displacement of size
	* word or long
a1858 1
	movem.l	d2-d5,-(sp)		* save d2-d5
a1859 2
	move.l	d0,d5		* put extword in d5
	move.l	a0,d3		* put base in d3
a1860 1
	bra	calc_mem_ind		* calc memory indirect
d1862 35
a1896 3
	**----------------------------------------------------------
pc_ind_index_8bit:
 	move.l	d2,-(sp)		* create a temp register
d1898 3
a1900 3
	move.l	d0,d1		* make extword copy
	rol.w	#$4,d1		* rotate reg num into place
	andi.w	#$f,d1		* extract register number
d1902 2
a1903 1
	move.l	(EXC_LV+EXC_DREGS,a6,d1.w*4),d1 * fetch index reg value
d1905 1
a1905 7
	btst	#$b,d0		* is index word or long?
	bne.b	pii8_long	* long
	ext.l	d1		* sign extend word index
pii8_long:
	move.l	d0,d2		* make extword copy
	rol.w	#$7,d2		* rotate scale value into place
	andi.l	#$3,d2		* extract scale value
d1907 3
a1909 1
	lsl.l	d2,d1		* shift index by scale
d1911 1
a1911 3
	extb.l	d0		* sign extend displacement
	add.l	d1,d0		* index + disp
	add.l	d0,a0		* An + (index + disp)
d1913 3
a1915 1
	move.l	(sp)+,d2	* restore temp register
d1917 7
a1923 1
	rts
d1925 2
a1926 4
	**----------------------------------------------------------
	* a5 = (EXC_LV+EXC_extwptr	(xdef   to uaeh)
	* a4 = (EXC_LV+EXC_opword	(xdef   to uaeh)
	* a3 = (EXC_LV+EXC_dregs	(xdef   to uaeh)
d1928 6
a1933 4
	* d2 = index	(internal "     "    )
	* d3 = base	(internal "     "    )
	* d4 = od	(internal "     "    )
	* d5 = extword	(internal "     "    )
d1935 2
a1936 21
calc_mem_ind:
	btst	#$6,d5		* is the index suppressed?
	beq.b	calc_index
	clr.l	d2		* yes, so index = 0
	bra.b	base_supp_ck
calc_index:
	bfextu	d5{16:4},d2
	move.l	(EXC_LV+EXC_DREGS,a6,d2.w*4),d2
	btst	#$b,d5		* is index word or long?
	bne.b	no_ext
	ext.l	d2
no_ext:
	bfextu	d5{21:2},d0
	lsl.l	d0,d2
base_supp_ck:
	btst	#$7,d5		* is the bd suppressed?
	beq.b	no_base_sup
	clr.l	d3
no_base_sup:
	bfextu	d5{26:2},d0		* get bd size
*	beq.l	_error		* if (size == 0) it's reserved
d1938 3
a1940 3
	cmp.b	#2,d0
	blt.b	no_bd
	beq.b	get_word_bd
d1942 6
a1947 3
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_long
d1949 4
d1954 2
a1955 4
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
	bra.b	chk_ind
d1957 2
a1958 5
get_word_bd:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word
	MOVE.W	(A0),D0
d1960 2
a1961 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1963 2
a1964 1
	ext.l	d0		* sign extend bd
d1966 2
a1967 8
chk_ind:
	add.l	d0,d3		* base += bd
no_bd:
	bfextu	d5{30:2},d0		* is od suppressed?
	beq.w	aii_bd
	cmp.b	#2,d0
	blt.b	null_od
	beq.b	word_od
d1969 8
a1976 4
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_long
	MOVE.L	(A0),D0
d1978 2
a1979 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1981 2
a1982 1
	bra.b 	add_them
d1984 2
a1985 5
word_od:
	move.l	(EXC_LV+EXC_EXTWPTR,a6),a0	* fetch instruction addr
	addq.l	#$2,(EXC_LV+EXC_EXTWPTR,a6)	* incr instruction ptr
	*bsr	_imem_read_word
	MOVE.W	(A0),D0
d1987 2
a1988 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.l	isp_iacc		* yes
d1990 2
a1991 2
	ext.l	d0		* sign extend od
	bra.b	add_them
d1993 1
a1993 6
null_od:
	clr.l	d0
add_them:
	move.l	d0,d4
	btst	#$2,d5		* pre or post indexing?
	beq.b	pre_indexed
d1995 14
a2008 3
	move.l	d3,a0
	*bsr	_dmem_read_long
	MOVE.L	(A0),D0
d2010 3
a2012 3
	*MOVEQ	#0,D1
	*tst.l	d1		* dfetch error?
	*bne.b	calc_ea_err		* yes
d2014 4
a2017 3
	add.l	d2,d0		* <ea> += index
	add.l	d4,d0		* <ea> += od
	bra.b	done_ea
d2019 2
a2020 5
pre_indexed:
	add.l	d2,d3		* preindexing
	move.l	d3,a0
	*bsr	_dmem_read_long
	MOVE.L	(A0),D0
d2022 1
a2022 3
	*MOVEQ	#0,D1
	*tst.l	d1		* ifetch error?
	*bne.b	calc_ea_err		* yes
d2024 3
a2026 2
	add.l	d4,d0		* ea += od
	bra.b	done_ea
d2028 5
a2032 5
aii_bd:
	add.l	d2,d3		* ea = (base + bd) + index
	move.l	d3,d0
done_ea:	move.l	d0,a0
	movem.l	(sp)+,d2-d5		* restore d2-d5
d2035 1
a2035 1
	* if dmem_read_long() returns a fail message in d1, the package
d2039 2
a2040 2
	* 	read = true
	* 	size = longword
d2043 2
a2044 2
calc_ea_err:
	move.l	d3,a0		* pass failing address
d2048 9
@


1.0.1.11
log
@Cleaned up Mul64
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.10 1997/03/27 17:10:46 schlote Exp schlote $
d1413 2
d1416 5
d1428 1
d1430 5
d1442 1
d1444 5
d1456 1
d1458 5
d1470 1
d1472 5
d1484 1
d1486 5
d1498 1
d1500 5
d1512 1
d1514 5
d1530 2
d1535 1
d1537 6
d1599 2
d1602 5
d1616 1
d1618 5
d1632 1
d1634 5
d1641 1
d1643 1
d1658 6
a1664 1
	MOVE.W	(A0),D0
d1747 1
d1749 4
d1758 1
d1760 5
d1766 1
d1778 1
d1780 5
d1790 1
d1792 5
d1799 1
d1808 1
d1811 4
d1822 1
d1824 5
d1832 2
a1833 1
aii_bd:	add.l	d2,d3		* ea = (base + bd) + index
d1839 12
a1869 242
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------
* XDEF
*	_mul64(): routine to emulate mul{u,s}.l <ea>,Dh:Dl 32x32->64
*
* XREF
*	_calc_ea() - calculate effective address
*	isp_iacc() - handle instruction access error exception
* 	isp_dacc() - handle data access error exception
*	isp_restore() - restore An on access error w/ -() or ()+
*
* INPUT
*	none
*
* OUTPUT
* 	If exiting through isp_dacc...
*	a0 = failing address
*	d0 = FSLW
* 	else
*	none
*
* ALGORITHM
*	First, decode the operand location. If it's in Dn, fetch from
* the stack. If it's in memory, use _calc_ea() to calculate the
* effective address. Use _dmem_read_long() to fetch at that address.
* Unless the operand is immediate data. Then use _imem_read_long().
* Send failures to isp_dacc() or isp_iacc() as appropriate.
*
*	If the operands are signed, make them unsigned and save the
* sign info for later. Perform the multiplication using 16x16->32
* unsigned multiplies and "add" instructions. Store the high and low
* portions of the result in the appropriate data registers on the
* stack. Calculate the condition codes, also.
*
**------------------------------------------------------------------------------------------------------
**------------------------------------------------------------------------------------------------------

	*************
	* mul(u,s)l *
	*************
	xdef  	_mul64
_mul64:
	DBUG	20,'\n MUL64 '

	move.b	(EXC_LV+EXC_OPWORD+1,a6), d0	* extract src {mode,reg}
	cmp.b	#$7,d0		* is src mode Dn or other?
	bgt	mul64_memop		* src is in memory

	* multiplier operand in the the data register file.
	* must extract the register number and fetch the operand from the stack.
mul64_regop:
	andi.w	#$7, d0		* extract Dn
	move.l	(EXC_LV+EXC_DREGS,a6,d0.w*4), d3 * fetch multiplier

	* multiplier is in d3. now, extract Dl and Dh fields and fetch the
	* multiplicand from the data register specified by Dl.
mul64_multiplicand:
	move.w	(EXC_LV+EXC_EXTWORD,a6), d2	* fetch ext word
	clr.w	d1		* clear Dh reg
	move.b	d2, d1		* grab Dh
	rol.w	#$4, d2		* align Dl byte
	andi.w	#$7, d2		* extract Dl

	move.l	(EXC_LV+EXC_DREGS,a6,d2.w*4), d4 * get multiplicand

	* check for the case of "zero" result early

	tst.l	d4		* test multiplicand
	beq.w	mul64_zero		* handle zero separately
	tst.l	d3		* test multiplier
	beq.w	mul64_zero		* handle zero separately

	* multiplier is in d3 and multiplicand is in d4.
	* if the operation is to be signed, then the operands are converted
	* to unsigned and the result sign is saved for the end.

	clr.b	(EXC_LV+EXC_TEMP,a6)		* clear temp space
	btst	#$3, (EXC_LV+EXC_EXTWORD,a6)	* signed or unsigned?
	beq.b	mul64_alg		* unsigned; skip sgn calc

	tst.l	d3		* is multiplier negative?
	bge.b	mul64_chk_md_sgn		* no
	neg.l	d3		* make multiplier positive
	ori.b	#$1, (EXC_LV+EXC_TEMP,a6)	* save multiplier sgn

	* the result sign is the exclusive or of the operand sign bits.
mul64_chk_md_sgn:
	tst.l	d4		* is multiplicand negative?
	bge.b	mul64_alg		* no
	neg.l	d4		* make multiplicand positive
	eori.b	#$1, (EXC_LV+EXC_TEMP,a6)	* calculate correct sign

	**------------------------------------------------------------------------
	**------------------------------------------------------------------------
	*	63   	   32				0
	* 	----------------------------
	* 	| hi(mplier) * hi(mplicand)|
	* 	----------------------------
	*	            -----------------------------
	*	            | hi(mplier) * lo(mplicand) |
	*	            -----------------------------
	*	            -----------------------------
	*	            | lo(mplier) * hi(mplicand) |
	*	            -----------------------------
	*	  |	  -----------------------------
	*	--|--	  | lo(mplier) * lo(mplicand) |
	*	  |	  -----------------------------
	*	========================================================
	*	--------------------------------------------------------
	*	| hi(result)             | 	      lo(result)      |
	*	--------------------------------------------------------
	**------------------------------------------------------------------------
	**------------------------------------------------------------------------

mul64_alg:
	* load temp registers with operands

	move.l	d3, d5		* mr in d5
	move.l	d3, d6		* mr in d6
	move.l	d4, d7		* md in d7
	swap	d6		* hi(mr) in lo d6
	swap	d7		* hi(md) in lo d7

	* complete necessary multiplies:

	mulu.w	d4, d3		* [1] lo(mr) * lo(md)
	mulu.w	d6, d4		* [2] hi(mr) * lo(md)
	mulu.w	d7, d5		* [3] lo(mr) * hi(md)
	mulu.w	d7, d6		* [4] hi(mr) * hi(md)

	* add lo portions of [2],[3] to hi portion of [1].
	* add carries produced from these adds to [4].
	* lo([1]) is the final lo 16 bits of the result.

	clr.l	d7		* load d7 w/ zero value
	swap	d3		* hi([1]) <==> lo([1])
	add.w	d4, d3		* hi([1]) + lo([2])
	addx.l	d7, d6		*    [4]  + carry
	add.w	d5, d3		* hi([1]) + lo([3])
	addx.l	d7, d6		*    [4]  + carry
	swap	d3		* lo([1]) <==> hi([1])

	* lo portions of [2],[3] have been added in to final result.
	* now, clear lo, put hi in lo reg, and add to [4]

	clr.w	d4		* clear lo([2])
	clr.w	d5		* clear hi([3])
	swap	d4		* hi([2]) in lo d4
	swap	d5		* hi([3]) in lo d5
	add.l	d5, d4		*    [4]  + hi([2])
	add.l	d6, d4		*    [4]  + hi([3])

	* unsigned result is now in {d4,d3}

	tst.b	(EXC_LV+EXC_TEMP,a6)		* should result be signed?
	beq.b	mul64_done		* no

	**------------------------------------------------------------------------
	* result should be a signed negative number.
	* compute 2's complement of the unsigned number:
	*   -negate all bits and add 1
mul64_neg:
	not.l	d3		* negate lo(result) bits
	not.l	d4		* negate hi(result) bits
	addq.l	#1, d3		* add 1 to lo(result)
	addx.l	d7, d4		* add carry to hi(result)

	**------------------------------------------------------------------------
	* the result is saved to the register file.
	* for '040 compatability, if Dl == Dh then only the hi(result) is
	* saved. so, saving hi after lo accomplishes this without need to
	* check Dl,Dh equality.
mul64_done:
	move.l	d3, (EXC_LV+EXC_DREGS,a6,d2.w*4) * save lo(result)
	move.w	#$0, ccr
	move.l	d4, (EXC_LV+EXC_DREGS,a6,d1.w*4) * save hi(result)

	**------------------------------------------------------------------------
	* now, grab the condition codes. only one that can be set is 'N'.
	* 'N' CAN be set if the operation is unsigned if bit 63 is set.

	move.w	ccr, d7		* fetch ccrr to see if 'N' set
	andi.b	#$8, d7		* extract 'N' bit
mul64_ccode_set:
	move.b	(EXC_LV+EXC_CC+1,a6), d6 	* fetch previous ccrr
	andi.b	#$10, d6		* all but 'X' bit changes

	or.b	d7, d6		* group 'X' and 'N'
	move.b	d6, (EXC_LV+EXC_CC+1,a6)	* save new ccrr

	rts

	**------------------------------------------------------------------------
	* one or both of the operands is zero so the result is also zero.
	* save the zero result to the register file and set the 'Z' ccode bit.

mul64_zero:
	clr.l	(EXC_LV+EXC_DREGS,a6,d2.w*4) * save lo(result)
	clr.l	(EXC_LV+EXC_DREGS,a6,d1.w*4) * save hi(result)

	moveq.l	#$4, d7		* set 'Z' ccode bit
	bra.b	mul64_ccode_set		* finish ccode set

	**------------------------------------------------------------------------
	* multiplier operand is in memory at the effective address.
	* must calculate the <ea> and go fetch the 32-bit operand.
mul64_memop:
	moveq.l	#size_LONG, d0			* pass * of bytes
	bsr	_calc_ea			* calculate <ea>

	cmp.b	#immed_flg,(EXC_LV+SPCOND_FLG,a6)	* immediate addressing mode?
	beq.b	mul64_immed			* yes
			* fetch src from addr (a0)
	MOVE.L	(a0),d3                * store multiplier in d3
	bra.w	mul64_multiplicand

	**------------------------------------------------------------------------
	* we have to split out immediate data here because it must be read using
	* imem_read() instead of dmem_read(). this becomes especially important
	* if the fetch runs into some deadly fault.
mul64_immed:
	addq.l	#$4,(EXC_LV+EXC_EXTWPTR,a6)
	MOVE.L	(a0),d0                		* read immediate value
	move.l	d0,d3
	bra.w	mul64_multiplicand

















d2341 271
@


1.0.1.12
log
@Cleaned up Div64
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.11 1997/03/27 17:31:37 schlote Exp schlote $
a2053 1
	**---------------------------------------------------------------------------
a2058 1
	**---------------------------------------------------------------------------
a2063 1
	**---------------------------------------------------------------------------
a2071 1
	**---------------------------------------------------------------------------
d2083 3
a2085 4
	**---------------------------------------------------------------------------
	* extract some special cases:
	* 	- is (dividend == 0) ?
	*	- is (hi(dividend) == 0 ## (divisor <= lo(dividend))) ? (32-bit div)
d2093 2
a2094 1
	cmp.l	d6,d7		* is (divisor <= lo(dividend))
d2102 1
d2105 2
a2106 2
	**---------------------------------------------------------------------------
dnormaldivide:	* last special case:
d2109 1
d2112 3
a2114 1
				* perform the divide algorithm:
a2116 1
	**---------------------------------------------------------------------------
a2121 1
	**---------------------------------------------------------------------------
a2131 1
	**---------------------------------------------------------------------------
d2139 1
d2141 1
d2146 1
a2146 1
ddone:	**---------------------------------------------------------------------------
d2172 16
a2187 16
	**------------------------------------------------------------------------------------------------------
	**------------------------------------------------------------------------------------------------------
	* This routine uses the 'classical' Algorithm D from Donald Knuth's
	* Art of Computer Programming, vol II, Seminumerical Algorithms.
	* For this implementation b=2**16, and the target is U1U2U3U4/V1V2,
	* where U,V are words of the quadword dividend and longword divisor,
	* and U1, V1 are the most significant words.
	*
	* The most sig. longword of the 64 bit dividend must be in d5, least
	* in d6. The divisor must be in the variable ddivisor, and the
	* signed/unsigned flag ddusign must be set (0=unsigned,1=signed).
	* The quotient is returned in d6, remainder in d5, unless the
	* v (overflow) bit is set in the saved ccrr. If overflow, the dividend
	* is unchanged.
	**------------------------------------------------------------------------------------------------------
	**------------------------------------------------------------------------------------------------------
a2194 1
	**-------------------------------------------------------------------
a2225 1
	**-------------------------------------------------------------------
a2245 1
	**-------------------------------------------------------------------
d2253 2
a2254 1
	cmp.w 	d3, d2		* V1 = U1 ?
a2265 1
	**-------------------------------------------------------------------
d2289 4
a2292 2
*REMARK:	add.l	d6, d4		* (U1U2 - V1q) + U3
	cmp.l 	d4,d2
a2296 1
	**-------------------------------------------------------------------
a2313 1
	**-------------------------------------------------------------------
a2331 1
	**-------------------------------------------------------------------
d2343 1
a2343 2

ddremain:	**-------------------------------------------------------------------
d2365 1
a2365 2

dmm2:	**-------------------------------------------------------------------
d2399 1
a2399 1
	**-------------------------------------------------------------------
d2402 4
a2405 1
	bsr	_calc_ea			* calc <ea>
d2407 7
a2413 2
	cmp.b	#immed_flg,(EXC_LV+SPCOND_FLG,a6) 	* immediate addressing mode?
	beq.b	dimmed			* yes
d2415 1
a2415 1
	MOVE.L	(A0),D7 	                * fetch divisor from <ea> to d7
a2417 1
	**-------------------------------------------------------------------
d2423 8
a2430 1
	MOVE.L	(A0),D7                        	* read immediate value
d2433 16
d2474 11
a2484 6
*
* _compandset(): 	routine to emulate cas w/ misaligned <ea>  (internal to package)
* _isp_cas_finish(): 	routine called when cas emulation completes  (external and internal to package)
* _isp_cas_restart(): 	restart cas emulation after a fault  (external to package)
* _isp_cas_terminate(): create access error stack frame on fault  (external and internal to package)
* _isp_cas_inrange(): 	checks whether instr addess is within range of core cas/cas2emulation code (external to package)
@


1.0.1.13
log
@Final changes. Maximum code removed. Nearly. CAS & TAS are
unusual these days. Don't waste time.
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.12 1997/03/27 17:48:31 schlote Exp schlote $
d655 85
d2454 1
d2456 1
d2464 2
d2471 2
d2477 3
d2484 2
d2508 4
d2523 16
d2593 5
d2602 23
d2783 1
d2787 1
a2787 2
CASW_ENTER:
          bra.b *+14
d2793 1
a2793 1
          bra.b *+14
d2801 1
a2801 1
          bra.b *+14
d2803 1
a2803 1
CASW_NOUPDATE:        	* Write old EA value back !!!!
d2809 1
a2809 1
          bra.b *+14
d2816 1
a2816 1
          bra.b *+14
d2848 25
d2945 2
a2946 1
CASL_START:	movec	a1,buscr	* assert LOCK*
d2948 1
d2953 1
a2953 1
         bra.b *+14
d2955 2
a2956 1
CASL_UPDATE:   	moves.w	d2,(a0)+	* Update[31:16] -> DEST
d2960 1
a2960 1
         bra.b *+14
d2962 2
a2963 1
CASL_UPDATE2:  	movec	a3,buscr	* unlock the bus
d2969 1
a2969 1
         bra.b *+14
d2971 2
a2972 1
CASL_NOUPDATE: 	swap	d0	* get Dest[31:16]
d2977 1
a2977 1
         bra.b *+14
d2979 2
a2980 1
CASL_NOUPDATE2:    	moves.w	d0,(a0)	* Dest[15:0] -> DEST+$2
d2985 1
a2985 1
         bra.b *+14
d2999 22
d3036 2
d3040 1
a3040 1
	**----------------------------------------------------------------------------
d3082 1
d3105 2
a3106 1
CASL2_START:       	movec	a1,buscr	* assert LOCK*
d3115 2
a3116 1
CASL2_UPDATE:      	moves.b	d2,(a0)+	* Update[31:24] -> DEST
d3122 2
a3123 1
CASL2_UPDATE2:     	moves.b	d5,(a0)	* Update[7:0] -> DEST+$3
d3127 1
a3127 1
           bra.b *+14
d3129 2
a3130 1
CASL2_NOUPDATE:    	rol.l	#$8,d0	* get Dest[31:24]
d3134 2
a3135 2
           	bra.b 	CASL2_NOUPDATE2
           bra.b *+14
d3137 2
a3138 1
CASL2_NOUPDATE2:   	rol.l	#$8,d0	* get Dest[7:0]
d3143 1
a3143 1
           bra.b *+14
d3145 2
a3146 1
CASL2_NOUPDATE3:   	movec	a3,buscr	* unlock the bus
d3151 1
a3151 1
           bra.b *+14
d3165 8
a3195 2
	**---------------------------------------------------------------
	**---------------------------------------------------------------
d3205 1
d3213 1
d3216 9
a3224 1
cas_finish_w_done:	rts
d3231 1
d3239 1
d3242 13
a3254 1
cas_finish_l_done:	rts
d3259 52
d3439 23
d3464 68
d3555 3
a3557 2
_isp_cas2:	DBUG	10,'\n cas2_core'

d3634 1
d3638 2
d3642 2
d3672 1
a3672 2
CAS2L_ENTER:
             bra.b *+14
d3674 3
a3676 1
CAS2L_CONT:	cmp.l	 d2,d0	* Dest1 - Compare1
d3678 1
d3683 1
a3683 1
             bra.b *+14
d3685 2
a3686 1
CAS2L_UPDATE:	movec	a3,buscr	* assert LOCKE*
d3690 1
a3690 1
             bra.b *+14
d3692 2
a3693 1
CAS2L_NOUPDATE:	movec	a3,buscr	* assert LOCKE*
d3697 1
a3697 1
             bra.b *+14
d3749 1
a3749 1
	bra	cas2_finish
d3761 1
a3761 1
            bra.b *+14
d3763 3
a3765 1
CAS2L2_CONT:      	cmp.l	 d2,d0		* Dest1 - Compare1
d3767 1
d3772 1
a3772 1
            bra.b *+14
d3774 2
a3775 1
CAS2L2_UPDATE:   	swap	d4		* get Update1[31:16]
d3780 1
a3780 1
            bra.b *+14
d3782 2
a3783 1
CAS2L2_UPDATE2:  	moves.w	d4,(a0)		* Update1[15:0] -> DEST1+$2
d3787 1
a3787 1
            bra.b *+14
d3789 2
a3790 1
CAS2L2_NOUPDATE: 	swap	d0		* get Dest1[31:16]
d3795 1
a3795 1
            bra.b *+14
d3797 2
a3798 1
CAS2L2_NOUPDATE2:	moves.w	d0,(a0)		* Dest1[15:0] -> DEST1+$2
d3802 1
a3802 1
            bra.b *+14
d3804 2
a3805 1
CAS2L2_FILLER:   	nop
d3823 1
a3823 2
CAS2L3_ENTER:
          bra.b *+14
d3825 3
a3827 1
CAS2L3_CONT:    	cmp.l	 d2,d0	* Dest1 - Compare1
d3829 1
d3834 1
a3834 1
          bra.b *+14
d3836 2
a3837 1
CAS2L3_UPDATE:  	rol.l	#$8,d4	* get Update1[31:24]
d3842 1
a3842 1
          bra.b *+14
d3844 2
a3845 1
CAS2L3_UPDATE2: 	rol.l	#$8,d4	* get Update1[7:0]
d3850 1
a3850 1
          bra.b *+14
d3852 2
a3853 1
CAS2L3_UPDATE3: 	movec	a4,buscr	* unlock the bus
d3858 1
a3858 1
          bra.b *+14
d3860 2
a3861 1
CAS2L3_NOUPDATE:	rol.l	#$8,d0	* get Dest1[31:24]
d3866 1
a3866 1
          bra.b *+14
d3868 2
a3869 1
CAS2L3_NOUPDATE2:	rol.l	#$8,d0	* get Dest1[7:0]
d3874 1
a3874 1
          bra.b *+14
d3876 2
a3877 1
CAS2L3_NOUPDATE3:	movec	a4,buscr	* unlock the bus
d3882 1
a3882 1
          bra.b *+(14-2)
d3884 2
a3885 1
CAS2L3_FILLER:	nop
d3897 2
a3898 1
cas2w:      	DBUG            10,' cas2w '
d3987 1
a3987 1
            bra.b *+14
d3989 3
a3991 1
CAS2W_CONT2:	cmp.w	 d2,d0	* Dest1 - Compare1
d3993 2
a3994 1
	cmp.w	 d3,d1	* Dest2 - Compare2
d3998 1
a3998 1
            bra.b *+14
d4005 1
a4005 1
            bra.b *+14
d4012 1
a4012 1
            bra.b *+14
d4026 2
a4027 1
cas2w_noupdate_done:	move.b	#0,d4		* indicate no update was done
d4030 3
a4032 1
cas2w_update_done:	move.b	#-1,d4		* indicate update was done
a4034 1
	* restore previous interrupt mask level.
a4037 2
	move.w	d7,sr		* restore old SR
	bra	cas2_finish
d4039 1
d4041 1
a4041 21
	**------------------------------------------------------------------
	**------------------------------------------------------------------
cas2_finish:
	DBUG	10,"cas2_finish"

	btst	#$1,(EXC_LV+EXC_OPWORD,a6)
	bne.b	cas2_finish_l

	move.w	(EXC_LV+EXC_CC,a6),ccr		* load old ccodes
	cmp.w	d2,d0
	bne.b	cas2_finish_w_save
	cmp.w	d3,d1
cas2_finish_w_save:     move.w	ccr,(EXC_LV+EXC_CC,a6)		* save new ccodes

	tst.b	d4		* update compare reg?
	bne.b	cas2_finish_w_done		* no

	move.w	(DC2,a6),d3		* fetch Dc2
	move.w	d1,(2+EXC_LV+EXC_DREGS,a6,d3.w*4) * store new Compare2 Op
	move.w	(DC1,a6),d2		* fetch Dc1
	move.w	d0,(2+EXC_LV+EXC_DREGS,a6,d2.w*4) * store new Compare1 Op
d4043 1
a4043 23
cas2_finish_w_done:	btst	#$5,(SFF0_ISR,a6)
	sne	d2
	rts

	**------------------------------------------------------------------
cas2_finish_l:
	move.w	(EXC_LV+EXC_CC,a6),ccr		* load old ccodes
	cmp.l	d2,d0
	bne.b	cas2_finish_l_save
	cmp.l	d3,d1
cas2_finish_l_save:	move.w	ccr,(EXC_LV+EXC_CC,a6)		* save new ccodes

	tst.b	d4		* update compare reg?
	bne.b	cas2_finish_l_done		* no

	move.w	(DC2,a6),d3		* fetch Dc2
	move.l	d1,(EXC_LV+EXC_DREGS,a6,d3.w*4) * store new Compare2 Op
	move.w	(DC1,a6),d2		* fetch Dc1
	move.l	d0,(EXC_LV+EXC_DREGS,a6,d2.w*4) * store new Compare1 Op

cas2_finish_l_done:	btst	#$5,(SFF0_ISR,a6)
	sne	d2
                   	rts
d4055 1
a4055 1
          bra.b  *+14
d4058 1
d4061 1
d4066 1
a4066 1
          bra.b  *+14
d4074 1
a4074 1
          bra.b  *+14
d4081 1
a4081 1
          bra.b  *+14
d4089 1
a4089 1
          bra.b  *+14
d4096 1
a4096 1
          bra.b  *+14
d4109 88
a4196 2
**------------------------------------------------------------------
**------------------------------------------------------------------
@


1.0.1.14
log
@Final version tested so far. Have fun.
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.13 1997/03/27 20:17:15 schlote Exp schlote $
d28 1
a28 1
DEBUG_DETAIL 	set 	5	; Detail Level
d30 1
a30 1
TESTCODE	equ	0	; Add Test Code ?
d44 1
a44 1
	IFGT	TESTCODE	; Some stupid test code
d73 1
a73 1
ISP060_Code:	DBUG	5,'\nInstalling Isp060 patches to VBR'
d81 1
a81 1
	DBUG	5,' - installed.\n'
@


1.0.1.15
log
@Current Amiga Release 43.2  1
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.14 1997/03/27 20:34:09 schlote stable schlote $
a12 4
* Use PhxAss (AmiNet) to compile.
*
* ALL RIGHTS RESERVED BY CARSTEN SCHLOTE, COENOBIUM DEVELOPMENTS
*
a25 1
	include	isp_rev.i	; Some Revision Amiga Magic
a54 1
	XDEF ISP060_Start
d59 1
a59 1
	dc.b	VERSION                             	; Version 43
d65 3
a67 6
ISP060_Name:	dc.b	'MC060 AmigaIsp',0			; name
ISP060_Info:	dc.b	'MC060 Amiga'		   	; give some info
	VERS
	dc.b	'('
                        DATE
	dc.b	') 1997 by Carsten Schlote,'
a86 2

	CPUSHA	DC			; Dump Cache ---
d3741 1
a3741 3
ISP060_End:
	cnop	14,16
	nop
@


1.0.1.16
log
@Minor BugFix
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.15 1997/04/02 15:30:56 schlote Exp schlote $
d35 1
a35 1
*TESTCODE	equ	0	; Add Test Code ?
d49 1
a49 1
	IFD	TESTCODE	; Some stupid test code
@


1.0.1.17
log
@Added XDEF for 060 Lib.
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.16 1997/04/02 16:39:37 schlote Exp schlote $
d81 1
a81 2
	XDEF	_Install_Int_Emulation
_Install_Int_Emulation:
@


1.0.1.18
log
@Minor changes , Revision set to 40.3
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.17 1997/04/07 19:05:07 schlote Exp schlote $
d30 1
a30 1
	include	AmigaIsp_rev.i	; Some Revision Amiga Magic
d71 1
a71 1
ISP060_Name:	dc.b	'AmigaISP',0			; name
@


1.0.1.19
log
@Minor changes of startup.
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.18 1997/04/08 16:25:18 schlote Exp schlote $
d94 1
a94 3
ISP060_SuperCode:
	ORI.W	#$0700,SR
	MOVEC	VBR,A0
d97 1
a97 1
	MOVE.L	a1,(61*4).w
@


1.0.1.20
log
@Vertag corrected
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.19 1997/04/08 20:07:14 schlote Exp schlote $
d72 1
a72 1
ISP060_Info:	dc.b	'MC68060 '		   	; give some info
@


1.0.1.21
log
@Changed Init Jump for Installer Routine, New XDEF
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.20 1997/04/08 21:36:35 schlote Exp schlote $
d81 2
a82 2
	XDEF	_Install_AmigaISP
_Install_AmigaIsp:
d99 1
a99 1
	MOVE.L	A1,(61*4).w
@


1.0.1.22
log
@Bugfix for XDEF
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.21 1997/04/09 19:28:14 schlote Exp schlote $
d82 1
a82 1
_Install_AmigaISP:      nop
@


1.0.1.23
log
@Exeception Handling fixed
@
text
@d9 1
a9 1
* $Id: isp.asm,v 1.0.1.22 1997/04/09 22:45:57 schlote Exp schlote $
a162 2
* *** ON AMIGA THIS CASE SHOULD NEVER HAPPEN !
*
a383 1
_isp_done:
d423 1
a423 9
*	bra	_real_trace
_real_trace:
                        MOVEM.L	a0/a1,-(SP)	* Save two regs
                        movec.l	VBR,A0                 * Now get VBR
                        move.l	(9*4,a0),4(sp)         * Get TRACE Handler to stack
                        MOVEM.L          (sp)+,a0	* Get back only A0
 	rts                                     * rts to Handler :-)
*	rte		* Handler will RTE

d461 1
d479 2
a480 1
	*bra	_real_trace
a481 9
real_chk_end:           * bra	_real_chk

_real_chk:
                        MOVEM.L	a0/a1,-(SP)	* Save two regs
                        movec.l	VBR,A0                 * Now get VBR
                        move.l	(6*4,a0),4(sp)         * Get TRACE Handler to stack
                        MOVEM.L          (sp)+,a0	* Get back only A0
 	rts                                     * rts to Handler :-)
*	rte		* Handler will RTE
a579 1
	*BRA.L	_real_trace
d581 1
a581 6
                        MOVEM.L	a0/a1,-(SP)	* Save two regs
                        movec.l	VBR,A0                 * Now get VBR
                        move.l	(5*4,a0),4(sp)         * Get TRACE Handler to stack
                        MOVEM.L          (sp)+,a0	* Get back only A0
 	rts                                     * rts to Handler :-)
*	rte		* Handler will RTE
d624 1
a624 1
	bra	_real_trace
d656 1
a656 1
	BRA	_isp_done
@






















































































